<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对数运算</title>
    <link href="/articles/Logarithmic/"/>
    <url>/articles/Logarithmic/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文适用范围为高中数学，内容较浅，仅作总结回顾使用。<br>无特殊说明，下面式子的前提条件均为真数大于 $0$、底数大于 $0$ 且不等于 $1$。</p><p>与 $\text{OI}$ 不同，在数学和生活中，$\log x$ 表示 $\log_{10}x$，即以 $10$ 为底的对数。而在 $\text{OI}$ 中默认表示以 $2$ 为底的对数，请注意区分。</p><hr><h3 id="对数的定义"><a href="#对数的定义" class="headerlink" title="对数的定义"></a>对数的定义</h3><p>$a^n&#x3D;m\Leftrightarrow\log_am&#x3D;n\ (m&gt;0,\ a&gt;0\land a\neq 1)$。其中，$a$ 称作<strong>底数</strong>，$m$ 称作<strong>真数</strong>，$n$ 称作<strong>对数</strong>。</p><p>$$<br>\log_\text{底数}\text{真数}&#x3D;\text{对数},\ \text{底数}^\text{对数}&#x3D;\text{真数}<br>$$</p><p>由此可见，对数运算是指数运算的逆运算。</p><hr><h3 id="指数与对数的关系"><a href="#指数与对数的关系" class="headerlink" title="指数与对数的关系"></a>指数与对数的关系</h3><p>$$<br>\begin{array}{c|ccc}<br>&amp;m&#x3D;a^n&amp;n&#x3D;log_am&amp;\text{范围}\\<br>\hline<br>a&amp;\text{底数}&amp;\text{底数}&amp;a&gt;0,a\neq1\\<br>m&amp;\text{幂}&amp;\text{真数}&amp;m&gt;0\\<br>n&amp;\text{指数}&amp;\text{对数}&amp;n\in\mathbb R<br>\end{array}<br>$$</p><hr><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>$2^3&#x3D;8\Leftrightarrow\log_28&#x3D;3$<br>$3^{\frac12}&#x3D;\sqrt3\Leftrightarrow\log_3\sqrt3&#x3D;\frac12$</p><hr><h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a>特殊值</h3><p>$a^1&#x3D;a\Leftrightarrow\log_aa&#x3D;1\ (a&gt;0\land a\neq1)$，即 $1$ 的对数为 $0$。<br>$a^0&#x3D;1\Leftrightarrow\log_a1&#x3D;0\ (a&gt;0\land a\neq1)$，即底数的对数为 $1$。</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><h4 id="对数恒等式"><a href="#对数恒等式" class="headerlink" title="对数恒等式"></a>对数恒等式</h4><p>$$<br>a^{\log_am}&#x3D;m<br>$$<br>基于底数的定义推导而来，揭示了任何一个数($a$)都可作为另一个数($m$)的底数。</p><h4 id="废话恒等式"><a href="#废话恒等式" class="headerlink" title="废话恒等式"></a>废话恒等式</h4><p>$$<br>\log_aa^m&#x3D;m<br>$$<br>等价于 $a^m&#x3D;a^m$。</p><h4 id="同时取对数"><a href="#同时取对数" class="headerlink" title="同时取对数"></a>同时取对数</h4><p>$$<br>A&#x3D;B\Leftrightarrow \log_aA&#x3D;\log_aB<br>$$<br>不难理解，两个相等的数对同一个数取对数，结果依然相等。</p><hr><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="一、积的对数等于对数的积"><a href="#一、积的对数等于对数的积" class="headerlink" title="一、积的对数等于对数的积"></a>一、积的对数等于对数的积</h4><p>$$<br>\log_amn&#x3D;\log_am+\log_an<br>$$<br>证明如下：<br>令 $M&#x3D;\log_am$，$N&#x3D;\log_an$，<br>则 $a^M&#x3D;m$，$a^N&#x3D;n$，<br>所以 $mn&#x3D;a^M\cdot a^N&#x3D;a^{M+N}$；<br>同时取对数，得 $\log_amn&#x3D;\log_aa^{M+N}$；<br>又因为 $\log_aa^{M+N}&#x3D;M+N&#x3D;\log_am+\log_an$，<br>所以 $\log_amn&#x3D;\log_am+\log_an$，得证。</p><h4 id="二、商的对数等于对数的差"><a href="#二、商的对数等于对数的差" class="headerlink" title="二、商的对数等于对数的差"></a>二、商的对数等于对数的差</h4><p>$$<br>\log_a\frac mn&#x3D;\log_am-\log_an<br>$$<br>证明如下：<br>令 $M&#x3D;\log_am$，$N&#x3D;\log_an$，<br>则 $a^M&#x3D;m$，$a^N&#x3D;n$，<br>所以 $\frac mn&#x3D;\frac {a^M}{a^N}&#x3D;a^{M-N}$；<br>同时取对数，得 $\log_a\frac mn&#x3D;\log_aa^{M-N}$；<br>又因为 $\log_aa^{M-N}&#x3D;M-N&#x3D;\log_am-\log_an$，<br>所以 $\log_a\frac mn&#x3D;\log_am-\log_an$，得证。</p><h4 id="三、幂的对数等于对数的积"><a href="#三、幂的对数等于对数的积" class="headerlink" title="三、幂的对数等于对数的积"></a>三、幂的对数等于对数的积</h4><p>$$<br>\log_am^n&#x3D;n\log_am<br>$$<br>证明如下：<br>令 $M&#x3D;\log_am$，则 $a^M&#x3D;m$，<br>所以 $m^n&#x3D;(a^M)^n&#x3D;a^{Mn}$；<br>同时取对数，得 $\log_am^n&#x3D;\log_aa^{Mn}$；<br>又因为 $\log_aa^{Mn}&#x3D;Mn&#x3D;n\log_am$，<br>所以 $\log_am^n&#x3D;n\log_am$，得证。</p><hr><h3 id="特殊底的对数"><a href="#特殊底的对数" class="headerlink" title="特殊底的对数"></a>特殊底的对数</h3><p>对于 $a^n&#x3D;m\Leftrightarrow\log_am&#x3D;n$：</p><ol><li>当 $a&#x3D;10$ 时，$\log_{10}m$ 称为常用对数，记作 $\lg m$；</li><li>当 $a&#x3D;e$ 时，$\log_em$ 称为自然对数，记作 $\ln m$。</li></ol><hr><h3 id="换底公式及其推论"><a href="#换底公式及其推论" class="headerlink" title="换底公式及其推论"></a>换底公式及其推论</h3><h4 id="换底公式"><a href="#换底公式" class="headerlink" title="换底公式"></a>换底公式</h4><p>$$<br>\log_ab&#x3D;\frac{\log_cb}{\log_ca}<br>$$</p><p>证明如下：<br>令 $m&#x3D;\log_ab$，则 $a^m&#x3D;b$，<br>同时取对数，得 $\log_ca^m&#x3D;\log_cb$；<br>幂指数提前，得 $m\log_ca&#x3D;\log_cb$，$m&#x3D;\frac{\log_cb}{\log_ca}$；<br>回代，得 $\log_ab&#x3D;\frac{\log_cb}{\log_ca}$。</p><h4 id="底的幂"><a href="#底的幂" class="headerlink" title="底的幂"></a>底的幂</h4><p>$$<br>\log_{a^n}m&#x3D;\frac1n\log_am<br>$$<br>证明如下：<br>$$<br>\log_{a^n}m&#x3D;\frac{\ln m}{\ln a^n}&#x3D;\frac{\ln m}{n\ln a}&#x3D;\frac1n\log_am<br>$$<br>另外，将该式与幂的对数综合可得：<br>$$<br>\log_{a^n}b^m&#x3D;\frac mn\log_ab<br>$$<br>底数的指数变为分母，在下面；真数的指数变为分子，在上面。</p><h4 id="倒数运算"><a href="#倒数运算" class="headerlink" title="倒数运算"></a>倒数运算</h4><p>$$<br>\log_ab\cdot\log_ba&#x3D;1,\ \text{i.e.}\ \frac1{\log_ab}&#x3D;\log_ba<br>$$<br>证明如下：<br>$$<br>\log_ab\cdot\log_ba&#x3D;\frac{\ln b}{\ln a}\cdot\frac{\ln a}{\ln b}&#x3D;1<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>std::bitset及时间复杂度常数优化</title>
    <link href="/articles/Bitset/"/>
    <url>/articles/Bitset/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文仅介绍了C++14版本下的特性和调用方法，仅供 $\text{OIer}$ 学习和参考使用。</p><p>具体怎么使用，哪些题、什么环境下使用，后面我会单独写一篇文章讲。在此之前，建议看一下大佬的博客，我会放在后面。</p><hr><h3 id="std-bitset"><a href="#std-bitset" class="headerlink" title="std::bitset"></a>std::bitset</h3><p>一种数据类型，可用于压二进制。</p><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><p><code>#include &lt;bitset&gt;</code></p><h4 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h4><p>右侧为低位，左侧为高位，类似二进制数。</p><p>以<code>bitset&lt;6&gt; b(22)</code>为例：<br>$$<br>\begin{array}{|c|c|c|c|c|c|c|}<br>\hline \text{val}&amp;0&amp;1&amp;0&amp;1&amp;1&amp;0\\<br>\hline \text{id}&amp;5&amp;4&amp;3&amp;2&amp;1&amp;0\\<br>\hline<br>\end{array}<br>$$</p><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>构造一个长度为 $N$ 的<code>bitset</code>。</p><p><code>bitset&lt;N&gt; b;</code><br>默认构造，所有位都为 $0$。</p><p><code>bitset&lt;N&gt; b(x);</code><br>从<code>unsigned long long</code>类型构造，最右、最低位有效。<br>有效长度为 $\min(N,64)$。若 $N&lt;64$，则取 $x$ 的低 $N$ 位作为<code>bitset</code>的数据。</p><p><code>bitset&lt;N&gt; b(s);</code><br>从<code>std::basic_string</code>或<code>const Char T*</code>类型构造，最左、最高位有效。<br>有效长度位 $\min(N,len)$。若 $N&lt;len$，则取字符串 $s$ 从左向右前 $N$ 位作为<code>bitset</code>的数据。<br>若 $s$ 中含有除“$0$”、“$1$”之外的字符，会在构造过程中报错。</p><h4 id="值的获取"><a href="#值的获取" class="headerlink" title="值的获取"></a>值的获取</h4><p><code>bool x=b[i];</code><br>直接获取下标为 $i$ 的位值，即从右向左第 $i-1$ 位。</p><p><code>bool x=b.test(i);</code><br>直接获取下标位 $i$ 的位值，但越界会报错。</p><p><code>bool x=b.all();</code><br>若 $b$ 中全部为 $1$，则返回 $1$，若存在 $0$ 则返回 $0$。</p><p><code>bool x=b.any();</code><br>若 $b$ 中存在 $1$，则返回 $1$，若全部为 $0$ 则返回 $0$。</p><p><code>bool x=b.none();</code><br>若 $b$ 中全部为 $0$，则返回 $1$，若存在 $1$ 则返回 $0$。</p><p><code>size_t x=b.count();</code><br>返回 $b$ 中 $1$ 的数量，即 $\text{popcount}$。</p><p><code>cout &lt;&lt; b &lt;&lt; &#39;\n&#39;;</code><br>输出 $b$。从左到右，由高位到低位，下标由 $N-1$ 到 $0$。</p><h4 id="值的修改"><a href="#值的修改" class="headerlink" title="值的修改"></a>值的修改</h4><p><code>b[i]=x;</code><br>将下标为 $i$ 的位修改为 $0&#x2F;1$。</p><p><code>b.set(i);</code><br>将下标为 $i$ 的位修改为 $1$。</p><p><code>b.reset(i);</code><br>将下标为 $i$ 的位修改为 $0$。</p><p><code>b.flip(i);</code><br>将下标为 $i$ 的位反转，从 $0$ 改成 $1$，从 $1$ 改成 $0$。</p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>同二进制位运算，<code>bitset</code>提供了<code>&lt;&lt;</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;</code>、<code>&gt;&gt;=</code>、<code>&amp;</code>、<code>&amp;=</code>、<code>|</code>、<code>|=</code>、<code>~</code>等运算符。<br>位移产生的新位为 $0$。  </p><p>注意，<code>bitset</code>仅能与<code>bitset</code>运算，不可与整型运算。</p><hr><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="对于整型"><a href="#对于整型" class="headerlink" title="对于整型"></a>对于整型</h4><p>在现代CPU中，两个 $32$ 位无符号整型进行位运算的时间复杂度为 $O(1)$，而不是 $O(32)$。其原因有以下三点：</p><ol><li>硬件支持：现代CPU的指令集通常包含专门的位运算指令，这些指令直接由硬件支持，执行速度非常快。</li><li>寄存器操作：位运算通常在CPU的寄存器之间进行，寄存器访问速度非常快，远快于内存访问。</li><li>编译器优化：现代编译器能够识别并优化位运算，生成高效的机器代码。</li></ol><p>整型变量间单次位运算的时间复杂度为 $O(1)$，这是分析时间复杂度的<strong>大前提</strong>，也是<code>bitset</code>能优化时间复杂度的<strong>根本原因</strong>。</p><h4 id="对于bitset"><a href="#对于bitset" class="headerlink" title="对于bitset"></a>对于bitset</h4><p><code>bitset</code>的底层是<code>unsigned long</code>$32$ 位无符号整型变量，<code>bitset</code>间的位运算全部由底层的<code>unsigned long</code>实现。</p><p><code>bitset</code>位运算的具体操作如下图所示。<br><img src="../../img/48-01.jpg" alt="48-01" style="zoom:100%;" /><br>这样，进行<strong>每一个<code>unsigned long</code>单位内位运算</strong>的时间复杂度为 $O(1)$；而长度为 $N$ 的<code>bitset</code>总共有 $\lceil\frac N{32}\rceil$ 个<code>unsigned long</code>单位，故<strong>整个<code>bitset</code>进行位运算</strong>的时间复杂度为 $O(\frac N{32})$。</p><p>这种记法不是很严谨。考虑到时间复杂度不应出现常数，应将其记为 $O(\frac Nw)$，其中位数 $w&#x3D;32$。</p><p>当然，如果使用<code>unsigned long long</code>作为底层类型，常数能降至 $\frac1{64}$，但是<strong>需要手写</strong>。</p><hr><h3 id="博客链接-bitset的应用"><a href="#博客链接-bitset的应用" class="headerlink" title="博客链接 - bitset的应用"></a>博客链接 - bitset的应用</h3><p>bitset 的妙用：乱搞字符串匹配 - <a href="https://www.cnblogs.com/alex-wei/p/bitset_yyds.html">博客园-Alex_Wei</a><br>bitset的用法及例题(对DP过程的优化) - <a href="https://www.cnblogs.com/-ytz/p/16614693.html">博客园-yangtz</a></p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>std::bitset - <a href="https://zh.cppreference.com/w/cpp/utility/bitset">cppreference</a><br>bitset - <a href="https://oi-wiki.org/lang/csl/bitset/">OI-Wiki</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDSC2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有限状态自动机</title>
    <link href="/articles/Deterministic-Finite-Automaton-2/"/>
    <url>/articles/Deterministic-Finite-Automaton-2/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>因本文叙述过于简略和不标准，在阅读本文之前，你需要看一眼<a href="https://oi-wiki.org/string/automaton/">OI-Wiki</a>，并阅读<a href="../Deterministic-Finite-Automaton">这篇文章</a>及其它相关文章，以对DFA有一个初步的认识，并掌握DFA的基础理论知识与形式化描述方法。</p><hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="子串与子序列"><a href="#子串与子序列" class="headerlink" title="子串与子序列"></a>子串与子序列</h4><p>子串是连续的，子序列可以不连续。</p><h4 id="集合的对称差"><a href="#集合的对称差" class="headerlink" title="集合的对称差"></a>集合的对称差</h4><p>对称差是集合论的一个概念，描述两个集合之间的关系。<br>两个集合取对称差会得到一个集合，其符号与运算法则如下：<br>$$<br>A\oplus B&#x3D;(A\cup B)-(A\cap B)<br>$$<br>对称差记录了两个集合中不同的元素。</p><hr><h3 id="什么是有限状态自动机"><a href="#什么是有限状态自动机" class="headerlink" title="什么是有限状态自动机"></a>什么是有限状态自动机</h3><p>一种能在集合内识别特定语言的结构，确定有限状态自动机。</p><p>可以视作一个路线，根据信息沿着边在DFA上走。</p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>DFA有两种状态：拒绝状态和接受状态。在拒绝状态下，答案不可取。<br>需要注意，拒绝状态和接受状态是可以转化的，并不是走到拒绝状态就说明不成立。</p><p>在本文的图片中，接受状态使用绿色节点表示，拒绝状态使用红色节点表示。</p><h4 id="转移"><a href="#转移" class="headerlink" title="转移"></a>转移</h4><p>DFA的不同状态间是可以转移的。只要新传入的数据满足转移条件，就可以从一个节点转移到另一个节点。<br>特别地，当传入的数据对当前节点的所有转移状态都不满足时，它满足通配符<code>*</code>，可以从这里转移。有时省略，表示转移到自身，不改变状态。</p><hr><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>下面这个自动机可以用于判断字串是否含有奇数个字符“$1$”。<br><img src="../../img/47-01.jpg" alt="47-01" style="zoom:50%;" /><br>如图所示，一共两种状态，且仅能通过“$1$”转移。每读入一个“$1$”就转移一次状态，奇数次在状态 $\text{end}$，偶数次在状态 $\text{st}$。<br>读入其它字符时不转移，表示其它字符不影响字符“$1$”的奇偶性。</p><p>下面这个自动机可以用于判断字串中是否含有子序列“$114514$”。<br><img src="../../img/47-02.jpg" alt="47-02" style="zoom:50%;" /><br>仿照上面的例子也不难理解，这里不做解释。</p><p>这个东西叫子序列自动机，可以 $O(n)$ 判断一个长度为 $n$ 的数列是否含有子序列“$114514$”。</p><hr><h3 id="DFA间的运算"><a href="#DFA间的运算" class="headerlink" title="DFA间的运算"></a>DFA间的运算</h3><p>使用笛卡尔积实现。</p><h4 id="DFA的交"><a href="#DFA的交" class="headerlink" title="DFA的交"></a>DFA的交</h4><p>假设我们需要实现判断一个字串是否同时满足：</p><ol><li>包含奇数个字符“$1$”；</li><li>有子序列“$14$”。</li></ol><p>一种朴素的想法是，先跑一遍判断奇数个“$1$”的自动机(上面有)，再跑一边子序列自动机。</p><p>能否将两个DFA整合到一个DFA中，跑一次同时判断两个条件？<br><img src="../../img/47-03.jpg" alt="47-03" style="zoom:75%;" /><br>观察上面这个自动机，如果能从 $\text{st}$ 走到 $\text{ed}$，就表明同时满足以上两种条件。</p><p>程序化地求这个综合DFA的步骤如下：</p><ol><li>写出两个DFA；</li><li>对于每一对转移进行合并：若在第一个DFA中有 $x_1\xrightarrow cy_1$，在第二个中有 $x_2\xrightarrow cy_2$，则在新的自动机上有 $(x_1,x_2)\xrightarrow c(y_1,y_2)$。</li><li>$(y_1,y_2)\leftarrow(y_1,y_2)\land y_1\land y_2$，即 $y_1$ 与 $y_2$ 必须同时为可接受状态，新DFA中的点才为可接受状态，否则为拒绝状态。（显然 $x$ 的状态我们不用管。）</li></ol><p>我们称第 $2$ 个操作为求两个DFA的笛卡尔积。</p><p>再举一个例子，要判断一个字串既不包含“$2$”，又不包含“$3$”，只需构造下面的自动机：<br><img src="../../img/47-04.jpg" alt="47-04" style="zoom:75%;" /><br>注意到有两个状态是没用的，可合并掉，因此可以将新DFA写成右边的形式。</p><h4 id="DFA的并"><a href="#DFA的并" class="headerlink" title="DFA的并"></a>DFA的并</h4><p>与上文相似。若有 $x_1\xrightarrow cy_1$、$x_2\xrightarrow cy_2$，则可连边 $(x_1,y_1)\xrightarrow c(y_1,y_2)$，其中$(y_1,y_2)\leftarrow(y_1,y_2)\lor y_1\lor y_2$。</p><h4 id="DFA的对称差"><a href="#DFA的对称差" class="headerlink" title="DFA的对称差"></a>DFA的对称差</h4><p>与上文相似。若有 $x_1\xrightarrow cy_1$、$x_2\xrightarrow cy_2$，则可连边 $(x_1,y_1)\xrightarrow c(y_1,y_2)$，其中$(y_1,y_2)\leftarrow(y_1,y_2)\lor(\lnot y_1\land y_2)\lor(y_1\land\lnot y_2)$。</p><hr><h3 id="DFA的存储"><a href="#DFA的存储" class="headerlink" title="DFA的存储"></a>DFA的存储</h3><p>DFA中的一条转移边 $u\xrightarrow cv$ 可以记在二维数组 $f$ 中，$f_{u,c}&#x3D;v$。</p><hr><h3 id="DFA最小化"><a href="#DFA最小化" class="headerlink" title="DFA最小化"></a>DFA最小化</h3><p>本蒟蒻还没学会，等学会了再来补吧。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDSC 2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二维哈希 - 洛谷P10474 题解</title>
    <link href="/articles/Two-Dimensional-Hash-Solution-of-P10474/"/>
    <url>/articles/Two-Dimensional-Hash-Solution-of-P10474/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>一种映射，从大值域到小值域。本文中的哈希均指字符串哈希，即将数列 ${a_n}$ 视作 $p$ 进制数后对 $M$ 取模的结果，即 $H(a)&#x3D;(\sum\limits_{i&#x3D;1}^na_i\times p^{n-i})\operatorname{mod}M$。其中，$p$ 称为底，$M$ 称为模数。有以下性质：</p><ol><li>当在数列 ${a_n}$ 的末尾插入数 $d$ 时，数列 ${a_{n+1}}$ 的哈希值 $H(a+d)&#x3D;(H(a)\times p+d)\operatorname{mod} M$。</li><li>已知数列 ${c_{n+m}}$ 的哈希值为 $H(c)$，数列 ${a_n}$ 的哈希值为 $H(a)$ ，而数列 ${c_{n+m}}$ 由数列 ${a_n}$ 和数列 ${b_m}$ 拼接而成，则 $H(b)&#x3D;(H(c)-H(a)\times p^{m})\operatorname{mod}M$。</li></ol><p>上述两条性质不难理解，就是 $p$ 进制数的位移运算与加减运算。</p><p>详见<a href="https://oi-wiki.org/string/hash/">OI-WIki</a>中的第一种定义，或参考李煜东所著的《算法竞赛进阶指南》第75页。</p><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p>二维哈希参考了二维前缀和的思想，使得哈希值可以 $O(1)$ 地从角落哈希值求出。</p><p>设 $Sum_{x_1,y_1,x_2,y_2}&#x3D;\sum\limits_{i&#x3D;x_1}^{x_2}\sum\limits_{j&#x3D;y_1}^{y_2}a_{i,j}$，$S_{x,y}&#x3D;Sum_{1,1,x,y}&#x3D;\sum\limits_{i&#x3D;1}^x\sum\limits_{j&#x3D;1}^ya_{i,j}$，则有：<br>$$<br>\begin{gathered}<br>S_{x,y}&#x3D;a_{x,y}+S_{x-1,y}+S_{x,y-1}-S_{x-1,y-1}\\<br>Sum_{x_1,y_1,x_2,y_2}&#x3D;S_{x_2,y_2}-S_{x_1-1,y_2}-S_{x_2,y_1-1}+S_{x_1-1,y_1-1}<br>\end{gathered}<br>$$<br>自己画个图证明下就会了，详见<a href="https://oi-wiki.org/basic/prefix-sum/#%E4%BA%8C%E7%BB%B4%E5%A4%9A%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C">OI-Wiki</a>。</p><hr><h3 id="二维哈希"><a href="#二维哈希" class="headerlink" title="二维哈希"></a>二维哈希</h3><p>将一个二维矩阵映射到一个值上，即：<br>$$<br>A&#x3D;\begin{bmatrix}<br>a_{1,1}&amp;\cdots&amp;a_{1,m}\\<br>\vdots&amp;\ddots&amp;\vdots\\<br>a_{n,1}&amp;\cdots&amp;a_{n,m}<br>\end{bmatrix}\longrightarrow H(A)\in[0,M)\cap\mathbb Z<br>$$</p><hr><h3 id="整个矩阵哈希值的获取"><a href="#整个矩阵哈希值的获取" class="headerlink" title="整个矩阵哈希值的获取"></a>整个矩阵哈希值的获取</h3><h4 id="步骤一-按行哈希"><a href="#步骤一-按行哈希" class="headerlink" title="步骤一 按行哈希"></a>步骤一 按行哈希</h4><p>将矩阵 $A$ 按行进行哈希得到矩阵 $F$。<br>即，将矩阵 $A$ 视作 $n$ 个长度为 $m$ 的一维数列。<br>$$<br>A&#x3D;\begin{bmatrix}<br>\color{orange}a_{1,1}&amp;\color{orange}\cdots&amp;\color{orange}a_{1,m}\\<br>\vdots&amp;\ddots&amp;\vdots\\<br>a_{n,1}&amp;\cdots&amp;a_{n,m}<br>\end{bmatrix}\longrightarrow<br>F&#x3D;\begin{bmatrix}<br>f_{1,1}&amp;\cdots&amp;\color{orange}f_{1,m}\\<br>\vdots&amp;\ddots&amp;\vdots\\<br>f_{n,1}&amp;\cdots&amp;f_{n,m}<br>\end{bmatrix}<br>$$<br>设底为 $p_1$，模数为 $M$，则转移公式如下：<br>$$<br>f_{x,y}&#x3D;(\sum_{i&#x3D;1}^ya_{x,i}\times p_1^{y-i})\operatorname{mod}M<br>$$<br>根据一维哈希的性质，将公式进行优化：<br>$$<br>f_{x,y}&#x3D;(f_{x,y-1}\times p_1+a_{x,y})\operatorname{mod}M<br>$$</p><h4 id="步骤二-按列哈希"><a href="#步骤二-按列哈希" class="headerlink" title="步骤二 按列哈希"></a>步骤二 按列哈希</h4><p>将矩阵 $F$ 按列进行哈希得到矩阵 $G$。<br>即，将矩阵 $F$ 视作 $m$ 个长度为 $n$ 的一维数列。<br>$$<br>F&#x3D;\begin{bmatrix}<br>\color{orange}f_{1,1}&amp;\cdots&amp;f_{1,m}\\<br>\color{orange}\vdots&amp;\ddots&amp;\vdots\\<br>\color{orange}f_{n,1}&amp;\cdots&amp;f_{n,m}<br>\end{bmatrix}\longrightarrow<br>G&#x3D;\begin{bmatrix}<br>g_{1,1}&amp;\cdots&amp;g_{1,m}\\<br>\vdots&amp;\ddots&amp;\vdots\\<br>\color{orange}g_{n,1}&amp;\cdots&amp;g_{n,m}<br>\end{bmatrix}<br>$$<br>设底为 $p_2$，模数为 $M$，则转移公式如下：<br>$$<br>g_{x,y}&#x3D;(\sum_{i&#x3D;1}^xf_{i,y}\times p_2^{x-i})\operatorname{mod}M<br>$$<br>根据一维哈希的性质，将公式进行优化：<br>$$<br>g_{x,y}&#x3D;(g_{x-1,y}\times p_2+f_{x,y})\operatorname{mod}M<br>$$</p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>先按行和先按列都是一样的。总而言之，不管你先做什么，最终的式子代进去都是这样的：<br>$$<br>g_{x,y}&#x3D;(\sum_{i&#x3D;1}^x\sum_{j&#x3D;1}^ya_{i,j}\times p_2^{x-i}\times p_1^{y-j})\operatorname{mod}M<br>$$<br>依据总公式，仿照前缀和，你也可以在外面循环行，在里面循环列，同时求：<br>$$<br>g_{x,y}&#x3D;(a_{x,y}+g_{x-1,y}\times p_2+g_{x,y-1}\times p_1-g_{x-1,y-1}\times p_1\times p_2)\operatorname{mod}M<br>$$<br>这个公式就有一部分包含下文子矩阵的思想了。</p><h4 id="步骤三-获取哈希值"><a href="#步骤三-获取哈希值" class="headerlink" title="步骤三 获取哈希值"></a>步骤三 获取哈希值</h4><p>经过上面两个步骤后，矩阵 $G$ 的右下角 $g_{n,m}$ 就是矩阵 $A$ 的哈希值。</p><p>另外，如果对上面的步骤保留矩阵，$G$ 数组的值也是 $A$ 左上角子矩阵的哈希值，如图所示。<br>$$<br>A&#x3D;\begin{bmatrix}<br>\color{orange}a_{1,1}&amp;\color{orange}a_{1,2}&amp;a_{1,3}&amp;\cdots&amp;a_{1,m}\\<br>\color{orange}a_{2,1}&amp;\color{orange}a_{2,2}&amp;a_{2,3}&amp;\cdots&amp;a_{2,m}\\<br>\color{orange}a_{3,1}&amp;\color{orange}a_{3,2}&amp;a_{3,3}&amp;\cdots&amp;a_{3,m}\\<br>a_{4,1}&amp;a_{4,2}&amp;a_{4,3}&amp;\cdots&amp;a_{4,m}\\<br>\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>a_{n,1}&amp;a_{n,2}&amp;a_{n,3}&amp;\cdots&amp;a_{n,m}<br>\end{bmatrix}\longrightarrow<br>G&#x3D;\begin{bmatrix}<br>g_{1,1}&amp;g_{1,2}&amp;g_{1,3}&amp;\cdots&amp;g_{1,m}\\<br>g_{2,1}&amp;g_{2,2}&amp;g_{2,3}&amp;\cdots&amp;g_{2,m}\\<br>g_{3,1}&amp;\color{orange}g_{3,2}&amp;g_{3,3}&amp;\cdots&amp;g_{3,m}\\<br>g_{4,1}&amp;g_{4,2}&amp;g_{4,3}&amp;\cdots&amp;g_{4,m}\\<br>\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>g_{n,1}&amp;g_{n,2}&amp;g_{n,3}&amp;\cdots&amp;g_{n,m}<br>\end{bmatrix}<br>$$<br>在不发生冲突的情况下，$g_{n,m}$ 表示唯一的矩阵 $A$。可以依据哈希值判断矩阵是否相同。</p><h4 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h4><p>先对行进行哈希，再对列进行哈希，使得不同位置的元素有不同的权重，确保了较小的冲突概率。</p><h4 id="需要知道的风险"><a href="#需要知道的风险" class="headerlink" title="需要知道的风险"></a>需要知道的风险</h4><p>在将较大的矩阵处理到较小的值域上时，冲突风险会加大。请选取适当的底和模数以减小出现问题的概率。<br>如果不放心，可以使用<a href="https://oi-wiki.org/string/hash/#%E9%94%99%E8%AF%AF%E7%8E%87">双模数哈希</a>，或不使用二维哈希，考虑其它算法。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>开 <code>unsigned long long</code> 存储，使用自然溢出的方式取模。此时模数 $M&#x3D;2^{64}$。具体代码见下方例题。</p><hr><h3 id="子矩阵的哈希值获取"><a href="#子矩阵的哈希值获取" class="headerlink" title="子矩阵的哈希值获取"></a>子矩阵的哈希值获取</h3><p>这一部分比较难以理解，建议自己算一下看看。</p><p>设行数在 $x_1$ 到 $x_2$ 之间、列数在 $y_1$ 到 $y_2$ 之间子矩阵的哈希值为 $H(x_1,y_1,x_2,y_2)$。<br>根据上述步骤，我们已经知道了所有的 $H(1,1,x,y)$，其中 $x\in[1,n]$，$y\in[1,m]$。</p><p>参考一维哈希的方法，视作 $p$ 进制数。不过这里将不同列视为 $p_1$ 进制数（因为按行哈希时列转移乘了 $p_1$），将不同行视为 $p_2$ 进制数。</p><p>这样，在原矩阵的右侧添加一列空列，矩阵的哈希值 $H(A)$ 变为 $(H(A)\times p_1)\operatorname{mod}M$。<br>在原矩阵的下方添加一行空行，矩阵的哈希值 $H(A)$ 变为 $(H(A)\times p_2)\operatorname{mod}M$。<br>感性理解一下，证明我不会。</p><p>虽然矩阵是先对每一行哈希，再对每一列哈希，先以 $p_1$ 为底再以 $p_2$ 为底，但是最后乘上 $p_1$ 依旧是左移。就相当于原本是以第 $x$ 列做哈希，现在以第 $x-1$ 列做哈希，先后顺序不影响。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>现在，我们需要 $O(1)$ 求解所有的 $H_(x_1,y_1,x_2,y_2)$。根据上述结论，易推得：<br>$$<br>\begin{aligned}<br>H(x_1&amp;,y_1,x_2,y_2)&#x3D;\\<br>&amp;\hspace{0.4cm}(H(1,1,x_2,y_2)&amp;\small\text{全部}\\<br>&amp;-H(1,1,x_1-1,y_2)\times p_2^{x_2-x_1+1}&amp;\small\text{减上方}\\<br>&amp;-H(1,1,x_2,y_1-1)\times p_1^{y_2-y_1+1}&amp;\small\text{减左侧}\\<br>&amp;+H(1,1,x_1-1,y_1-1)\times p_2^{x_2-x_1+1}\times p_1^{y_2-y_1+1}&amp;\small\text{加左上角}\\<br>&amp;\hspace{0.4cm})\operatorname{mod}M\\<br>\end{aligned}<br>$$<br>画出来是这样的：<br>$$<br>\begin{bmatrix}<br>\color{purple}g_{1,1}&amp;\color{purple}\cdots&amp;\color{purple}g_{1,x_1-1}&amp;\color{red}g_{1,x_1}&amp;\color{red}\cdots&amp;\color{red}g_{1,x_2}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}g_{1,m}\\<br>\color{purple}\vdots&amp;\color{purple}\ddots&amp;\color{purple}\vdots&amp;\color{red}\vdots&amp;\color{red}\ddots&amp;\color{red}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots\\<br>\color{purple}g_{y_1-1,1}&amp;\color{purple}\cdots&amp;\color{purple}g_{y_1-1,x_1-1}&amp;\color{red}g_{y_1-1,x_1}&amp;\color{red}\cdots&amp;\color{red}g_{y_1-1,x_2}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}g_{y_1-1,m}\\<br>\color{blue}g_{y_1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_1,x_1-1}&amp;\color{green}g_{y_1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_1,x_2}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}g_{y_1,m}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots&amp;\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}&amp;\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}g_{y_2,m}\\<br>\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots&amp;\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots\\<br>\color{darkgrey}g_{m,1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}g_{m,x_1-1}&amp;\color{darkgrey}g_{m,x_1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}g_{m,x_2}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}g_{n,m}<br>\end{bmatrix}<br>$$<br>其中，绿色为目标区域，(绿色+红色+蓝色+紫色)为全部区域，(红色+紫色)为上方区域，(蓝色+紫色)为左侧区域，紫色为重复的左上角区域，灰色为无关区域。</p><h4 id="为什么要乘"><a href="#为什么要乘" class="headerlink" title="为什么要乘"></a>为什么要乘</h4><p>此处的颜色标记与上面的不同，请注意区分。<br>下面的矩阵在哈希意义下，不是普通的矩阵，详细规则见上。请将矩阵视作哈希。<br>为方便理解，矩阵中的 $0$ 记作 $0_{x,y}$ 以标识位置。<br>下文证明及其不严谨，仅作理解。</p><p>首先，左侧区域原本是这样的：<br>$$<br>A&#x3D;\begin{bmatrix}<br>\color{blue}g_{1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{1,x_1-1}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}<br>\end{bmatrix}<br>$$<br>整体长这样：<br>$$<br>C&#x3D;\begin{bmatrix}<br>\color{blue}g_{1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{1,x_1-1}&amp;\color{green}g_{1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{1,x_2}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots&amp;\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}&amp;\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}<br>\end{bmatrix}<br>$$<br>我们想要得到：<br>$$<br>B&#x3D;\begin{bmatrix}<br>\color{green}g_{1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{1,x_2}\\<br>\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots\\<br>\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}<br>\end{bmatrix}<br>$$<br>注意，在上文所述的哈希（视作 $p_1$、$p_2$ 进制）中，可以向上方和左侧补前导零。所以有：<br>$$<br>B&#x3D;\begin{bmatrix}<br>\color{green}g_{1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{1,x_2}\\<br>\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots\\<br>\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>\color{darkgrey}0_{1,1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{1,x_1-1}&amp;\color{green}g_{1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{1,x_2}\\<br>\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots&amp;\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots\\<br>\color{darkgrey}0_{y_2,1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{y_2,x_1-1}&amp;\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}<br>\end{bmatrix}<br>$$<br>但不能在下方或右侧补零，因为这样改变了哈希大小。所以：<br>$$<br>A&#x3D;\begin{bmatrix}<br>\color{blue}g_{1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{1,x_1-1}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}<br>\end{bmatrix}\neq\begin{bmatrix}<br>\color{blue}g_{1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{1,x_1-1}&amp;\color{darkgrey}0_{1,x_1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{1,x_2}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots&amp;\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}&amp;\color{darkgrey}0_{y_2,x_1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{y_2,x_2}<br>\end{bmatrix}<br>$$<br>因此，我们不能直接将 $H(C)-H(A)$ 作为目标 $H(B)$ 的答案，因为 $A$ 没有与 $C$ 对齐。<br>要想对齐，就要将 $A$ 左移 $(x_2-x_1+1)$ 列，也就是在 $A$ 的右边插入 $(x_2-x_1+1)$ 个空列。按照上面的证明方式，只需将 $A$ 的哈希值乘 $p_2^{x_2-x_1+1}$ 即可。<br>$$<br>A\times p_2^{x_2-x_1+1}&#x3D;<br>\begin{bmatrix}<br>\color{blue}g_{1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{1,x_1-1}&amp;\color{darkgrey}0_{1,x_1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{1,x_2}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots&amp;\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}&amp;\color{darkgrey}0_{y_2,x_1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{y_2,x_2}<br>\end{bmatrix}<br>$$<br>这样，$A$ 与 $C$ 对齐后我们就可以相减得到答案。<br>$$<br>\begin{gathered}\begin{aligned}B&#x3D;&amp;\begin{bmatrix}<br>\color{green}g_{1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{1,x_2}\\<br>\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots\\<br>\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}<br>\end{bmatrix}&#x3D;\begin{bmatrix}<br>\color{darkgrey}0_{1,1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{1,x_1-1}&amp;\color{green}g_{1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{1,x_2}\\<br>\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots&amp;\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots\\<br>\color{darkgrey}0_{y_2,1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{y_2,x_1-1}&amp;\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}<br>\end{bmatrix}\\&#x3D;&amp;\begin{bmatrix}<br>\color{blue}g_{1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{1,x_1-1}&amp;\color{green}g_{1,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{1,x_2}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots&amp;\color{green}\vdots&amp;\color{green}\ddots&amp;\color{green}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}&amp;\color{green}g_{y_2,x_1}&amp;\color{green}\cdots&amp;\color{green}g_{y_2,x_2}<br>\end{bmatrix}-\begin{bmatrix}<br>\color{blue}g_{1,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{1,x_1-1}&amp;\color{darkgrey}0_{1,x_1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{1,x_2}\\<br>\color{blue}\vdots&amp;\color{blue}\ddots&amp;\color{blue}\vdots&amp;\color{darkgrey}\vdots&amp;\color{darkgrey}\ddots&amp;\color{darkgrey}\vdots\\<br>\color{blue}g_{y_2,1}&amp;\color{blue}\cdots&amp;\color{blue}g_{y_2,x_1-1}&amp;\color{darkgrey}0_{y_2,x_1}&amp;\color{darkgrey}\cdots&amp;\color{darkgrey}0_{y_2,x_2}<br>\end{bmatrix}\\&#x3D;&amp;C-A\times p_2^{x_2-x_1+1}\end{aligned}\\<br>H(B)&#x3D;(H(C)-H(A)\times p_2^{x_2-x_1+1})\operatorname{mod}M\end{gathered}<br>$$<br>同样地，通过位移操作，我们可以完成上方和左上角的矩阵操作，只需要对应乘 $p_1$、$p_2$ 的幂即可。</p><p>在程序中，由于会频繁进行 $p_1$、$p_2$ 的幂运算，我们通常会预处理出它们的 $1\sim n$ 次方，并存储到 <code>unsigned long long</code> 数组中。</p><hr><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>$p_1&#x3D;7$，$p_2&#x3D;239$，$M&#x3D;+\infty$。<br>$$<br>\begin{gathered}<br>A&#x3D;\begin{bmatrix}<br>1&amp;2&amp;3\\4&amp;5&amp;6<br>\end{bmatrix},\<br>F&#x3D;\begin{bmatrix}<br>1&amp;9&amp;66\\4&amp;33&amp;237<br>\end{bmatrix},\<br>G&#x3D;\begin{bmatrix}<br>1&amp;9&amp;66\\<br>143&amp;2184&amp;16011<br>\end{bmatrix}\\<br>\text{对于子矩阵：}<br>A’&#x3D;\begin{bmatrix}<br>2&amp;3\\5&amp;6<br>\end{bmatrix},\<br>F’&#x3D;\begin{bmatrix}<br>2&amp;17\\5&amp;41<br>\end{bmatrix},\<br>G’&#x3D;\begin{bmatrix}<br>2&amp;17\\483&amp;4104<br>\end{bmatrix}<br>\end{gathered}<br>$$<br>验证：$16011-0\times57121-243\times49&#x3D;16011-11907&#x3D;4104$，成立。</p><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P10474">洛谷P10474</a> [BeiJing2011] Matrix 矩阵哈希<br>注：为方便书写，本文将题目中的 $M$ 和 $N$ 替换为了 $n$ 和 $m$，与原题目有出入。</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个 $n$ 行 $m$ 列的 $01$ 矩阵，以及 $q$ 个 $A$ 行 $B$ 列的 $01$ 矩阵，你需要求出这 $q$ 个矩阵中有哪些矩阵是大矩阵的子矩阵。</p><p>数据范围：$1\le n,m\le1000$，$q&#x3D;1000$。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>先对整体取哈希，把每个大小为 $A\times B$ 的存入 <code>unordered_map</code>；然后对每个子矩阵取哈希，判断是否在 <code>map</code> 中即可。时间复杂度 $O(n^2)$。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/169139975">AC</a> 49.65MB 1.08s</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ull;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1010</span><br><span class="hljs-type">int</span> n, m, A, B, q;<br>ull a[N][N];<br>unordered_map&lt;ull, <span class="hljs-type">bool</span>&gt; mp;<br><br><span class="hljs-keyword">namespace</span> tdh &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> P1 503ULL</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> P2 1013ULL</span><br><span class="hljs-type">int</span> n, m;<br>ull f[N][N], g[N][N];<br>ull p1[N], p2[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ull d[N][N], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>p1[<span class="hljs-number">0</span>]=p2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;N; ++i) p1[i]=p1[i<span class="hljs-number">-1</span>]*P1, p2[i]=p2[i<span class="hljs-number">-1</span>]*P2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; ++j) &#123;<br>f[i][j]=f[i][j<span class="hljs-number">-1</span>]*P1+d[i][j];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; ++j) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br>g[i][j]=g[i<span class="hljs-number">-1</span>][j]*P2+f[i][j];<br>&#125;<br>&#125;<br><span class="hljs-function">ull <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> g[x2][y2]-g[x1<span class="hljs-number">-1</span>][y2]*p2[x2-x1+<span class="hljs-number">1</span>]-g[x2][y1<span class="hljs-number">-1</span>]*p1[y2-y1+<span class="hljs-number">1</span>]<br>+g[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>]*p1[y2-y1+<span class="hljs-number">1</span>]*p2[x2-x1+<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), A=<span class="hljs-built_in">read</span>(), B=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; ++j) &#123;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>(); <span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;1&#x27;</span>) ch=<span class="hljs-built_in">getchar</span>(); a[i][j]=ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>tdh::<span class="hljs-built_in">init</span>(a, n, m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n-A+<span class="hljs-number">1</span>; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m-B+<span class="hljs-number">1</span>; ++j) &#123;<br>mp[(<span class="hljs-type">int</span>)tdh::<span class="hljs-built_in">get</span>(i, j, i+A<span class="hljs-number">-1</span>, j+B<span class="hljs-number">-1</span>)]=<span class="hljs-number">1</span>;<br>&#125;<br>q=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span> (q--) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=A; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=B; ++j) &#123;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>(); <span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;1&#x27;</span>) ch=<span class="hljs-built_in">getchar</span>(); a[i][j]=ch-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>tdh::<span class="hljs-built_in">init</span>(a, A, B), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, mp[(<span class="hljs-type">int</span>)tdh::<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,A,B)]);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>使用 $(x,y)$ 的方式表示行列真的不标准，大家不要学我（<br>$p_1$ 表示行内（不同 $y$ 之间）的底，$p_2$ 表示列内（不同 $x$ 之间）的底，为方便理解可自行替换为 $p_x$、$p_y$。</p><p>这个算法很冷，学了很大概率也用不上，随缘吧。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDSC 2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整系数线性组合的最小正数</title>
    <link href="/articles/Minimum-Positive-Number-of-Linear-Combinations-of-Coefficients/"/>
    <url>/articles/Minimum-Positive-Number-of-Linear-Combinations-of-Coefficients/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="带余除法与线性组合"><a href="#带余除法与线性组合" class="headerlink" title="带余除法与线性组合"></a>带余除法与线性组合</h3><p>带余除法得到的商和余数是一种线性组合。</p><p>$a\div b&#x3D;q\dots r$，亦可记作 $a&#x3D;bq+r\r&#x3D;a-bq$。<br>注意到此时 $r$ 是 $a$ 与 $b$ 的一种线性组合。</p><hr><h3 id="线性组合"><a href="#线性组合" class="headerlink" title="线性组合"></a>线性组合</h3><p>标量的线性组合为标量集合 ${a_1,a_2,\dots,a_n}$ 与权重集合 ${w_1,w_2,\dots,w_n}$ 一一对应相乘后再相加，即 $a_1w_1+a_2w_2+\dots+a_nw_n$。详见<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88/8664061">百度百科</a>。</p><hr><h3 id="两个数整系数线性组合的最小正数"><a href="#两个数整系数线性组合的最小正数" class="headerlink" title="两个数整系数线性组合的最小正数"></a>两个数整系数线性组合的最小正数</h3><p>设两个整数为 $a,b$。求它们的整系数线性组合的最小正数，就是寻找一个正数 $c&#x3D;ax+by$，其中 $x,y\in\mathbb Z$。</p><hr><h3 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h3><p>两个数整系数线性组合的最小整数等于它们的最大公因数，即 $c&#x3D;\gcd(a,b)&#x3D;d$。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设 $c$ 为 $a,b$ 两个数的整系数线性组合的最小整数。</p><p>设 $q&#x3D;\lfloor\frac ac\rfloor$，$r&#x3D;a\operatorname{mod}c$。<br>此时余数 $r$ 满足 $0\le r&#x3D;a-cq&lt;c$。<br>将 $c&#x3D;ax+by$ 代入，得 $r&#x3D;a-axq-byq&#x3D;a(1-xq)+b(-yq)$，其中 $1-xq,-yq\in\mathbb Z$。<br>根据线性组合的定义，$r$ 是 $a$ 与 $b$ 的<strong>整系数线性组合</strong>。<br>因为 $c$ 为 $a,b$ 的<strong>整系数线性组合的最小正数</strong>，而 $0\le r&lt;c$，所以 $r&#x3D;0$。<br>所以 $a&#x3D;cq$，$c\mid a$。</p><p>同理可证 $c\mid b$，所以 $c\mid d&#x3D;\gcd(a,b)$。</p><p>$c&#x3D;ax+by$，其中 $a,b,x,y\in\mathbb Z$。<br>因为 $d\mid a$，$d\mid b$，所以 $d\mid ax$，$d\mid ay$，$d\mid c&#x3D;ax+ay$。</p><p>综上，$c\mid d$，$d\mid c$，可得 $d&#x3D;c$ ，即两个数整系数线性组合的最小整数等于它们的最大公因数。得证。</p><hr><h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p>$\forall a,b\in\mathbb Z$，$\gcd(a,b)&#x3D;d$，则对于 $\forall x,y\in\mathbb Z$，$d\mid ax+by$。特别地，$\exists x,y\in\mathbb Z$，使得 $ax+by&#x3D;d$。</p><p>证明：对于命题 $1$，可使用整除性质解释。对于命题 $2$，可使用引理 $1$ 证明。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>线性组合 - <a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88/8664061">百度百科</a><br>裴蜀定理 - <a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593">百度百科</a><br>裴蜀定理 - <a href="https://oi-wiki.org/math/number-theory/bezouts/">OI-Wiki</a><br>数论入门 - SDSC 2024 D1</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDSC 2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于值域预处理的快速GCD算法</title>
    <link href="/articles/Fast-GCD-Algorithm-Based-on-Range-Preprocessing/"/>
    <url>/articles/Fast-GCD-Algorithm-Based-on-Range-Preprocessing/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="算法内容"><a href="#算法内容" class="headerlink" title="算法内容"></a>算法内容</h3><p>$O(N)$ 预处理、$O(1)$ 查询任意 $\gcd(x,y)$。</p><hr><h3 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h3><p>对于 $\forall n\in\mathbb{N_+}$，$\exists n&#x3D;xyz$，使得 $a\le b\le c$，$a,b\le\sqrt n\ \land\ (c\le\sqrt n\ \lor\ c\in\operatorname{Prime})$。</p><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>使用数学归纳法证明。</p><ul><li>当 $n&#x3D;1$ 时，存在 $a&#x3D;b&#x3D;c&#x3D;1$ 使得 $n&#x3D;abc$ 且 $a,b,c\le\sqrt n&#x3D;1$。</li><li>当 $n&gt;1$ 时，假设对于 $\forall n’\in\mathbb{N_+}$，$n’&lt;n$，$n’$ 都可按上述命题拆分，即 $n$ 之前的数均已证明成立。<ul><li>若 $n$ 中存在大于等于 $\sqrt n$ 的质因子，按 $a,b\le\sqrt n\ \land\ c\in\operatorname{Prime}$ 划分。<br>令 $c$ 为 $n$ 的最大质因子，则 $c\ge \sqrt n$，$ab&#x3D;\frac n c\le\sqrt n$，成立。</li><li>若 $n$ 中不存在大于等于 $\sqrt n$ 的质因子，按 $a,b,c\le\sqrt n$ 划分。<br>设 $p$ 为 $n$ 的最小质因子，则令 $x&#x3D;\frac np$，有 $x\in\mathbb{N_+}$，$x&lt;n$。令 $x&#x3D;a_1b_1c_1$，$a_1\le b_1\le c_1$。<br>因为 $a_1^3\le a_1b_1c_1&#x3D;x&#x3D;\frac np$，所以 $a_1\le\sqrt[3]{\frac np}$。<br>因为 $x&lt;n$，由归纳和分类讨论条件得 $b_1\le\sqrt x&#x3D;\sqrt{\frac np}$，$c_1\le\sqrt n$ 且 $c_1\le\sqrt{\frac nq}\ \lor\ c_1\in\operatorname{Prime}$。<ul><li>若 $a_1&#x3D;1$，显然有 $p,b_1,c_1\le\sqrt n$，成立。此时 $p&gt;\sqrt[4]n$。</li><li>若 $a_1\neq1$，由于 $p$ 为最小质因子，有 $p\le a_1\le b_1\le c_1$，则有 $p\le\sqrt[4] n$，$a_1p\le\sqrt[3]{\frac np}\cdot p&#x3D;\sqrt[3]{np^2}\le\sqrt[3]{n\sqrt n}&#x3D;\sqrt n$。又由 $b_1\le\sqrt{\frac np}&lt;\sqrt n$，$c_1\le\sqrt n$，可得 $n&#x3D;a_1p\cdot b_1\cdot c_1$ 为一种可行拆分方案。故成立。</li></ul></li></ul></li></ul><hr><h3 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h3><p>对于 $\forall x&#x3D;abc$，有 $\gcd(x,y)&#x3D;\gcd(y\operatorname{mod}a,a)\times\gcd(b,\frac y{\gcd(a,y)})\times\gcd(c,\frac y{\gcd(ab,y)})$。</p><h4 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h4><p>从容斥原理方面理解。</p><p>$\gcd(a,y)$ 是 $a$ 与 $y$ 共有的因数，记作 $a’$；$\frac y{\gcd(a,y)}$ 是 $y$ 剖去 $a$ 的因数后所独有的因数，记作 $y_1$。<br>$\gcd(b,y_1)$ 是 $b$ 与 $y_1$ 共有的因数，记作 $b’$；$\frac{y_1}{\gcd(b,y_1)}$ 是 $y_1$ 剖去 $b$ 的因数后所独有的因数，记作 $y_2$。<br>$\gcd(c,y_2)$ 是 $c$ 与 $y_2$ 共有的因数，记作 $c’$。</p><p>带入，得：$y_1&#x3D;\frac y{\gcd(a,y)}$，$y_2&#x3D;\frac{\frac y{\gcd(a,y)}}{\gcd(b,\frac y{\gcd(a,y)})}&#x3D;\frac y{\gcd(b\cdot\gcd(a,y),y)}&#x3D;\frac y{\gcd(ab,y)}$。<br>因为 $x&#x3D;abc$，所以 $x$ 与 $y$ 共有的因数为 $a$、$b$、$c$ 与 $y$ 共有因数的并的积，即 $\gcd(x,y)&#x3D;a’b’c’&#x3D;\gcd(a,y)\times\gcd(b,\frac y{\gcd(a,y)})\times\gcd(c,\frac y{\gcd(ab,y)})$。<br>又因为 $\gcd(a,y)&#x3D;\gcd(y\operatorname{mod}a,a)$，所以 $\gcd(x,y)&#x3D;\gcd(y\operatorname{mod}a,a)\times\gcd(b,\frac y{\gcd(a,y)})\times\gcd(c,\frac y{\gcd(ab,y)})$，得证。</p><hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>假设需要 $O(1)$ 求解 $\gcd(x,y)$，其中 $x,y\in\mathbb{N_+}$ 且 $x,y\le N$。</p><p>对于所有 $i,j\le\sqrt N$，预处理出 $\gcd(i,j)$。这一步时间复杂度 $O(N)$。</p><p>令 $x&#x3D;abc$，其中 $a\le b\le c$。  </p><ul><li>若 $c\in\operatorname{Prime}$，只需判断 $c$ 是否整除 $y$，再进一步迭代即可。<ul><li>若 $c\mid y$，则 $\gcd(c,y)&#x3D;c$，$\gcd(x,y)&#x3D;\gcd(ab,\frac yc)$。</li><li>若 $c\nmid y$，则 $\gcd(c,y)&#x3D;1$，$\gcd(x,y)&#x3D;\gcd(ab,y)$。</li></ul></li><li>若 $c\notin\operatorname{Prime}$，<br>根据<a href="#%E5%BC%95%E7%90%861">引理1</a>，可得：$a,b,c\le\sqrt x\le\sqrt N$；<br>根据<a href="#%E5%BC%95%E7%90%862">引理2</a>，可得：$\gcd(x,y)&#x3D;\gcd(y\operatorname{mod}c,c)\times\gcd(b,\frac y{\gcd(c,y)})\times\gcd(a,\frac y{\gcd(bc,y)})$。<br>此时 $y\operatorname{mod} c$，$c$，$b$，$\frac y{\gcd(c,y)}$，$a$，$\frac y{\gcd(bc,y)}$ 均小于等于 $\sqrt N$，可以 $O(1)$ 查表。</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>快速GCD算法 - <a href="https://blog.csdn.net/qq_42101694/article/details/122503771">CSDN-OneInDark</a><br>数论入门 - SDSC 2024 D1</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDSC 2024</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>乘法逆元</title>
    <link href="/articles/Modular-Multiplicative-Inverse/"/>
    <url>/articles/Modular-Multiplicative-Inverse/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>若 $p$ 为素数，$\gcd(a,p)&#x3D;1$，则 $a^{p-1}\equiv1\ (\operatorname{mod} p)$，证明过程详见<a href="https://oi-wiki.org/math/number-theory/fermat/#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86">OI-WIki</a>。</p><h4 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h4><p>见另<a href="../Group-Theory/">一篇文章</a>，另外建议读完本文后详细阅读<a href="../Group-Theory/#%E6%AD%A3%E6%95%B4%E6%95%B0%E9%9B%86%E4%B8%8E%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E7%9A%84%E4%B9%98%E6%B3%95">这一段</a>，你也许会对乘法逆元有更深的理解。</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>若线性同余方程 $ax\equiv 1\ (\operatorname{mod} b)$，则称 $x$ 为 $a\operatorname{mod}b$ 的逆元，记作 $a^{-1}$。</p><hr><h3 id="欧几里得算法求解逆元"><a href="#欧几里得算法求解逆元" class="headerlink" title="欧几里得算法求解逆元"></a>欧几里得算法求解逆元</h3><p>当 $a$ 与 $b$ 互质时，$a^{-1}$ 有解，反之无解。然后你就可以发现这是个线性同余方程问题。</p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p>由于蒟蒻还不会打 $\LaTeX$ 伪代码，所以就先这样写了。</p><ol start="0"><li>$\quad$假设要求 $a$ 关于 $f$ 的逆元 $x&#x3D;a^{-1}$。</li><li>$\quad(x_1,x_2,x_3)\leftarrow(1,0,b)$</li><li>$\quad(y_1,y_2,y_3)\leftarrow(0,1,a)$</li><li>$\quad\operatorname{while}\ \operatorname{true}$</li><li>$\quad\qquad\operatorname{if}\ y_3&#x3D;0\ \operatorname{then}$</li><li>$\quad\qquad\qquad\operatorname{do}\ x\leftarrow\operatorname{null}$</li><li>$\quad\qquad\qquad\operatorname{break}$</li><li>$\quad\qquad\operatorname{if}\ y_3&#x3D;1\ \operatorname{then}$</li><li>$\quad\qquad\qquad\operatorname{do}\ x\leftarrow y_2$</li><li>$\quad\qquad\qquad\operatorname{break}$</li><li>$\quad\qquad q\leftarrow \lfloor\frac{x_3}{y_3}\rfloor$</li><li>$\quad\qquad(t_1,t_2,t_3)\leftarrow(x_1-qy_1,x_2-qy_2,x_3-qy_3)$</li><li>$\quad\qquad(x_1,x_2,x_3)\leftarrow(y_1,y_2,y_3)$</li><li>$\quad\qquad(y_1,y_2,y_3)\leftarrow(t_1,t_2,t_3)$</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ll <span class="hljs-title">exgcd</span><span class="hljs-params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!a&amp;&amp;!b) <span class="hljs-keyword">return</span> <span class="hljs-number">-1ll</span>;<br><span class="hljs-keyword">if</span> (!b) <span class="hljs-keyword">return</span> x=<span class="hljs-number">1</span>, y=<span class="hljs-number">0</span>, a;<br>ll res=<span class="hljs-built_in">exgcd</span>(b, a%b, y, x);<br><span class="hljs-keyword">return</span> y-=a/b*x, res;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, res=<span class="hljs-built_in">exgcd</span>(a, b, x, y);<br><span class="hljs-keyword">if</span> (res!=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1ll</span>;<br><span class="hljs-keyword">return</span> x%b&lt;=<span class="hljs-number">0</span>?x%b+b:x%b;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="快速幂求解逆元"><a href="#快速幂求解逆元" class="headerlink" title="快速幂求解逆元"></a>快速幂求解逆元</h3><p>由于使用到了费马小定理，该方法的前提条件是 $b$ 为<strong>素数</strong>（其实只要互质就可以）。</p><p>$\because ax\equiv1\ (\operatorname{mod}b)\\therefore ax\equiv a^{b-1}\ (\operatorname{mod}b)\\therefore x\equiv a^{b-2}\ (\operatorname{mod} b)$<br>然后就可以使用快速幂来求逆元了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> inv(a, b) qpow(a, b-2, b)</span><br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll b, ll mod)</span> </span>&#123;<br>ll ans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (b) &#123;<br><span class="hljs-keyword">if</span> (b&amp;<span class="hljs-number">1</span>) ans=ans*a%mod;<br>a=a*a%mod, b&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h3><p>求 $1\sim n$ 关于 $p$ 的逆元，时间复杂度 $O(n)$。<br>为方便分析，先采用递归的方式转移逆元。</p><h4 id="递归终点"><a href="#递归终点" class="headerlink" title="递归终点"></a>递归终点</h4><p>$1^{-1}\equiv1\ (\operatorname{mod} p)$。</p><h4 id="转移过程"><a href="#转移过程" class="headerlink" title="转移过程"></a>转移过程</h4><p>对于 $i^{-1}$，令 $k&#x3D;\lfloor\frac pi\rfloor$，$j&#x3D;p\operatorname{mod} i$，有 $p&#x3D;ki+j$，在 $\operatorname{mod} p$ 意义下为 $ki+j\equiv 0\ (\operatorname{mod} p)$。</p><p>同余号两边同时乘上 $i^{-1}\times j^{-1}$，可得 $kj^{-1}+i^{-1}\equiv0$，$i^{-1}\equiv -kj^{-1}$。</p><p>此时将 $j&#x3D;p\operatorname{mod} i$ 代入回来，得 $i^{-1}\equiv-\lfloor\frac pi\rfloor(p\operatorname{mod}i)^{-1}\ (\operatorname{mod}p)$，说明 $i$ 的逆元可以由 $p\operatorname{mod}i$ 的逆元转移得来。</p><p>由此，我们可以写下转移式：<br>$$<br>i^{-1}&#x3D;\begin{cases}<br>1,&amp;\operatorname{if}\ i&#x3D;1\\<br>-\lfloor\frac pi\rfloor(p\operatorname{mod}i)^{-1},&amp;\operatorname{otherwise}<br>\end{cases}\ (\operatorname{mod} p)<br>$$</p><h4 id="递归转递推"><a href="#递归转递推" class="headerlink" title="递归转递推"></a>递归转递推</h4><p>注意到转移过程中总是满足 $p\operatorname{mod}i&lt;i$，所以可以直接按 $i$ 从小到大递推得到答案。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><p><a href="https://www.luogu.com.cn/problem/P3811">洛谷P3811</a> 模意义下的乘法逆元</p><p><a href="https://www.luogu.com.cn/record/166768230">AC</a> 23.43MB 415ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 3000010</span><br>ll n, p, inv[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), p=<span class="hljs-built_in">read</span>(), inv[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; ++i) &#123;<br>inv[i]=<span class="hljs-number">1LL</span>*(p-p/i)*inv[p%i]%p;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, inv[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>乘法逆元 - <a href="https://oi-wiki.org/math/number-theory/inverse/">OI-Wiki</a><br>乘法逆元 - <a href="https://baike.baidu.com/item/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/5831857">百度百科</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>群论简介</title>
    <link href="/articles/Group-Theory/"/>
    <url>/articles/Group-Theory/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>若 $p$ 为素数，$\gcd(a,p)&#x3D;1$，则 $a^{p-1}\equiv1$。</p><h4 id="模运算对积的性质"><a href="#模运算对积的性质" class="headerlink" title="模运算对积的性质"></a>模运算对积的性质</h4><p>对于 $\forall a,b,m\in\mathbb N$，令 $a’&#x3D;a\operatorname{mod}m$，$b’&#x3D;b\operatorname{mod} m$，有 $a\times b\equiv a’\times b’\ (\operatorname{mod} m)$。</p><h4 id="函数的复合"><a href="#函数的复合" class="headerlink" title="函数的复合"></a>函数的复合</h4><p>指将一个函数的输出作为另一个函数的输入。具体来说，如果有两个函数 $f:X\rightarrow Y$ 和 $g:Y\rightarrow Z$，它们的复合函数 $g\circ f:X\rightarrow Z$ 定义为 $(g \circ f)(x) &#x3D; g(f(x))$。</p><hr><h3 id="群的定义"><a href="#群的定义" class="headerlink" title="群的定义"></a>群的定义</h3><p>群是由一种集合及一个二元运算所组成的。</p><p>设 $G$ 是一个非空集合，“$\cdot$”是它的一个二元运算。若 $G$ 对 $\cdot$ 构成一个群，则 $G$ 与 $\cdot$ 满足以下性质：</p><ul><li>封闭性：对于 $\forall a,b\in G$，有 $a\cdot b\in G$。</li><li>满足结合律：对于 $\forall a,b,c\in G$，有 $(a\cdot b)\cdot c&#x3D;a\cdot(b\cdot c)$。</li><li>存在单位元：$\exists e\in G$，使得 $\forall a\in G$，$a\cdot e&#x3D;e\cdot a&#x3D;a$。则称 $e$ 为群 $(G,\cdot)$ 的单位元。</li><li>存在逆元：对于 $\forall a\in G$，$\exists b\in G$ 使得 $a\cdot b&#x3D;b\cdot a&#x3D;e$，则称 $a$ 与 $b$ 互为逆元。$b$ 记作 $a^{-1}$。</li></ul><p>通常来说，$G$ 对 $\cdot$ 构成的群，记作 $(G,\cdot)$。“$\cdot$”称为“乘法”，“$a\cdot b$”称为“$a$ 与 $b$ 的积”，简写为“$ab$”。</p><p>若 $G$ 的元素个数有限，则构成的群为有限群，反之则构成无限群。</p><p><strong>注意</strong>：此处的“乘法 $\cdot$”不是一般意义上四则运算的乘法。它可以是任何对应的运算，例如集合的交与并、函数的卷积与符合等等。另外，该运算<strong>不一定满足交换律</strong>，即 $a\cdot b$ 的运算结果可能不等于 $b\cdot a$ 的运算结果。</p><hr><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="整数集与加法"><a href="#整数集与加法" class="headerlink" title="整数集与加法"></a>整数集与加法</h4><p>整数集对加法构成群 $(\mathbb Z,+)$：</p><ul><li>对于 $\forall a,b\in\mathbb Z$，$a+b\in\mathbb Z$。</li><li>对于 $\forall a,b,c\in\mathbb Z$，$(a+b)+c&#x3D;a+(b+c)$。</li><li>$\exists e&#x3D;0\in\mathbb Z$，使得 $\forall a\in\mathbb Z$，$a+e&#x3D;e+a&#x3D;a$，群的单位元为 $0$。</li><li>对于 $\forall a\in\mathbb Z$，$\exists b&#x3D;-a\in\mathbb Z$ 使得 $a+b&#x3D;b+a&#x3D;e$，即 $a$ 在群中的逆元为 $-a$。</li></ul><h4 id="正整数集与模意义下的乘法"><a href="#正整数集与模意义下的乘法" class="headerlink" title="正整数集与模意义下的乘法"></a>正整数集与模意义下的乘法</h4><p>定义模意义下的乘法 $a\cdot b&#x3D;(a\times b)\operatorname{mod}p$，其中 $p$ 是一个被定义的素数。</p><p>非负整数集对模意义下的乘法构成群 $(\mathbb N,\cdot)$：</p><ul><li>对于 $\forall a,b\in\mathbb N$，$a\cdot b\in\mathbb N$。</li><li>对于 $\forall a,b,c\in\mathbb N$，由模运算对积的性质可得 $(a\cdot b)\cdot c&#x3D;a\cdot(b\cdot c)$。</li><li>$\exists e&#x3D;1\in\mathbb Z$，使得 $\forall a\in\mathbb N$，$a\cdot e&#x3D;e\cdot a&#x3D;a$，群的单位元为 $1$。</li><li>对于 $\forall a\in\mathbb N$，由费马小定理可得 $\exists b&#x3D;a^{p-2}\operatorname{mod}p\in\mathbb N$ 使得 $a\cdot b&#x3D;b\cdot a&#x3D;e$，即 $a$ 在群中的逆元为 $a^{p-2}$。</li></ul><hr><h3 id="群的运算"><a href="#群的运算" class="headerlink" title="群的运算"></a>群的运算</h3><p>对于 $g\in G,\ H\subseteq G$，定义 $g\cdot H&#x3D;{g\cdot h|h\in H}$，简写为 $gH$；$H\cdot g&#x3D;{h\cdot g|h\in H}$。</p><p>对于 $A,B\subseteq G$，定义 $A\cdot B&#x3D;{a\cdot b|a\in A,b\in B}$，简写为 $AB$。</p><p>对于 $H\subseteq G$，定义 $H^{-1}&#x3D;{h^{-1}|h\in H}$。</p><hr><h3 id="替换定理"><a href="#替换定理" class="headerlink" title="替换定理"></a>替换定理</h3><p>若 $(G,\cdot)$ 是群，对于 $\forall g\in G$，$gG&#x3D;Gg&#x3D;G$。<br>解释：从 $G$ 中取出一个元素 $g$，再将其与原来的每个元素做乘法，得到的新集合与原集合相同。</p><p>感性理解：根据群的封闭性，再原集合 $G$ 中，任意两个数相乘的结果都在 $G$ 中。此时用 $g$ 再乘，得到的结果也只能在 $G$ 中。根据集合互异性，结果数量与原集合数量相等，所以两集合相同。</p><hr><h3 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h3><p>若 $(G,\cdot)$ 是群，$H\neq\emptyset$，$H\subseteq G$ 且 $(H,\cdot)$ 也是群，则称 $(H,\cdot)$ 为 $(G,\cdot)$ 的子群。</p><hr><h3 id="阿贝尔群"><a href="#阿贝尔群" class="headerlink" title="阿贝尔群"></a>阿贝尔群</h3><p>若群 $(G,\cdot)$ 满足交换律，即对于 $\forall a,b\in G$，满足 $a\cdot b&#x3D;b\cdot a$，则称其为阿贝尔群，又称交换群。</p><hr><h3 id="函数群"><a href="#函数群" class="headerlink" title="函数群"></a>函数群</h3><p>函数群是群概念在函数空间中的应用。例如，考虑所有从实数到实数的连续函数的集合，如果定义适当的运算（如函数的乘积或和），这个集合可以形成一个群。</p><h4 id="乘法群"><a href="#乘法群" class="headerlink" title="乘法群"></a>乘法群</h4><p>函数的运算是逐点乘积。<br>如果 $f$ 和 $g$ 是两个函数，它们的运算结果是 $(f\cdot g)(x)&#x3D;f(x)\cdot g(x)$。</p><h4 id="复合群"><a href="#复合群" class="headerlink" title="复合群"></a>复合群</h4><p>在函数群的背景下，复合群指的是函数之间的运算是通过函数的符合来定义的。<br>如果 $f$ 和 $g$ 是两个函数，它们的运算结果是 $(f\circ g)(x)&#x3D;f(g(x))$。</p><ul><li>单位元：一个恒等函数 $e$，有 $e\circ f&#x3D;f\circ e&#x3D;f$。</li><li>逆元：逆函数 $f^{-1}$，满足 $f\circ f^{-1}&#x3D;f^{-1}\circ f&#x3D;e$。</li></ul><p>一个典型的例子：</p><blockquote><p><strong>所有连续函数的集合</strong>对复合运算构成函数群。在这种情况下，如果两个函数复合在一起，其结果仍然是一个函数，这就满足了<strong>封闭性</strong>。结合律则意味着函数复合是<strong>可结合</strong>的，即 $(f\circ g)\circ h&#x3D;f\circ(g\circ h)$。而单位元存在性则意味着存在一个恒等函数，它与任何函数的复合<strong>都不会改变</strong>函数的结果。</p></blockquote><p>通过这种方式，群论为研究函数的性质和变换提供了一种强大的代数框架。</p><hr><h3 id="群的应用"><a href="#群的应用" class="headerlink" title="群的应用"></a>群的应用</h3><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><p>群论在数学上被广泛地运用，通常以自同构群的形式体现某些结构的内部对称性。结构的内部对称性常常和一种不变式性质同时存在。如果在一类操作中存在不变式，那这些操作转换的组合和不变式统称为一个对称群。</p><p>阿贝尔群概括了另外几种抽象集合研究的结构，例如环、域、模。在代数拓扑中，群用于描述拓扑空间转换中不变的性质，例如基本群和透射群。</p><p>李群的概念在微分方程和流形中都有很重要的角色，因其结合了群论和分析数学，李群能很好的描述分析数学结构中的对称性。对这类群的分析又叫调和分析。在组合数学中，交换群和群作用常用来简化在某些集合内的元素的计算。</p><h4 id="物理"><a href="#物理" class="headerlink" title="物理"></a>物理</h4><p>群论在物理学中也有着重要的应用。对称性是物理学中一个重要的概念，而群论提供了一种严密的数学工具来研究对称性。</p><ul><li>群论在粒子物理中用于分类基本粒子和它们的相互作用，通过对称性原理揭示物理定律的内在结构。</li><li>群论在量子力学中用于描述粒子的对称性和守恒定律，帮助理解和预测粒子的行为和相互作用。</li><li>群论在凝聚态物理学中，帮助描述固体材料的对称性质，指导材料的电子结构和性质研究。</li></ul><h4 id="化学"><a href="#化学" class="headerlink" title="化学"></a>化学</h4><p>群论被广泛应用于研究晶体结构，因为它提供了一种系统化的方法来分析和分类晶体的结构和性质。</p><p>晶体的许多物理性质，如电导率、热导率和光学性质，与其对称性密切相关。群论可以帮助我们理解这些性质，并预测在改变晶体对称性时它们的变化。<br>晶体中的缺陷，如位错和杂质，也会影响其对称性。群论可以用来分析这些缺陷对晶体结构和性质的影响。</p><h4 id="计算机科学"><a href="#计算机科学" class="headerlink" title="计算机科学"></a>计算机科学</h4><p>群论在计算机科学上也有广泛的应用，可以帮助设计高效的算法和数据结构。</p><p>群论提供了一种优化算法的思路。群论中的群操作具有封闭性、结合律、单位元和逆元等性质，这些性质可以被用于算法设计中。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>群论作为一种抽象代数学的分支，具有广泛的应用前景。它不仅能帮我们更好地理解和研究实际问题，也为各个领域的发展和创新提供了数学支持和指导。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>群论 - <a href="https://oi-wiki.org/math/group-theory/">OI-Wiki</a><br>群论 - <a href="https://baike.baidu.com/item/%E7%BE%A4%E8%AE%BA/10980672">百度百科</a><br>数学中的群论应用 - <a href="https://wenku.baidu.com/view/6c8c515e270c844769eae009581b6bd97e19bc26.html">百度文库</a><br>揭秘数学中的群论：函数的集合与代数的新篇章 - <a href="https://baijiahao.baidu.com/s?id=1790891085022022783">百家号-闻讯百通</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>卡特兰数</title>
    <link href="/articles/Catalan/"/>
    <url>/articles/Catalan/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h4><p>详见<a href="https://oi-wiki.org/math/combinatorics/combination/">OI-Wiki</a>，后面会出一篇文章专门讲。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>先进先出的数据结构，详见<a href="https://oi-wiki.org/ds/stack/">OI-WIki</a>。</p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p><strong>左子树</strong>点权均<strong>小于</strong>根节点，<strong>右子树</strong>点权都<strong>大于</strong>根节点的二叉树。<br>它有很多好的性质，详见<a href="https://oi-wiki.org/ds/bst/#%E5%AE%9A%E4%B9%89">OI-Wiki</a>。</p><hr><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>以下问题的答案<strong>都可以</strong>用 $\text{Catalan}$ 数 $H_n$ 表示。</p><h4 id="一、进出栈问题"><a href="#一、进出栈问题" class="headerlink" title="一、进出栈问题"></a>一、进出栈问题</h4><p>一个容量无穷大的栈，若进栈序列为 $1,2,3,\dots,n$，求共有多少种不同的出栈序列。</p><p>进一步，这个问题可以扩展为：<br>给定 $n$ 对括号，求合法配对的序列数。</p><h4 id="二、凸多边形三角划分问题"><a href="#二、凸多边形三角划分问题" class="headerlink" title="二、凸多边形三角划分问题"></a>二、凸多边形三角划分问题</h4><p>在凸 $n$ 变形中，连接 $n-3$ 对不相邻顶点，使原多 $n$ 边形划分为 $n-2$ 个三角形，求划分方案数。<br><img src="../../img/41-01.png" alt="41-01" style="zoom:50%;" />  </p><p>进一步，这个问题可以扩展为：<br>在圆上选择 $2n$ 个点，求使用 $n$ 条不相交线段连接这些点的方案数。</p><h4 id="三、二叉树"><a href="#三、二叉树" class="headerlink" title="三、二叉树"></a>三、二叉树</h4><p>给定 $n$ 个有不同<strong>序号</strong>的节点，求能构成的不同的二叉搜索树的个数。<br>或，给定 $n$ 个<strong>无序号</strong>节点，求能构成的不同的二叉树的个数。</p><h4 id="四、矩阵路径问题"><a href="#四、矩阵路径问题" class="headerlink" title="四、矩阵路径问题"></a>四、矩阵路径问题</h4><p>在大小 $n\times n$ 的矩阵中，从起点 $(0,0)$ 走到终点 $(n,n)$，且不可走到对角线 $y&#x3D;x$ 上方，求不同的路径条数。<br><img src="../../img/41-02.jpg" alt="41-02" style="zoom:50%;" />  </p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设 $H_n$ 表示 $\text{Catalan}$ 数列中的第 $n$ 项，则有：<br>$$<br>\begin{array}{ccccccc}<br>H_0&amp;H_1&amp;H_2&amp;H_3&amp;H_4&amp;H_5&amp;H_6\\<br>\hline 1&amp;1&amp;2&amp;5&amp;14&amp;42&amp;132<br>\end{array}<br>$$<br>满足递推式及通项公式：<br>$$<br>\begin{gathered}<br>H_0&#x3D;1, H_1&#x3D;1,\ H_{n+1}&#x3D;\sum_{i&#x3D;0}^nH_i\times H_{n-i}\\<br>H_n&#x3D;\frac{\begin{pmatrix}2n\\n\end{pmatrix}}{n+1}<br>\end{gathered}<br>$$</p><hr><h3 id="其他公式"><a href="#其他公式" class="headerlink" title="其他公式"></a>其他公式</h3><p>$$<br>\begin{align}<br>H_n&#x3D;\frac{H_{n-1}(4n-2)}{n-1}\\<br>H_n&#x3D;\begin{pmatrix}2n\\n\end{pmatrix}-\begin{pmatrix}2n\\n-1\end{pmatrix}<br>\end{align}<br>$$<br>一般地，在程序设计中，通常使用公式 $H_n&#x3D;\frac{H_{n-1}(4n-2)}{n-1}$，而手算通常采用公式 $H_n&#x3D;\frac{\begin{pmatrix}2n\\n\end{pmatrix}}{n+1}$。</p><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P1044">洛谷P1044</a> 栈</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一个容量无穷大的栈，若进栈序列为 $1,2,3,\dots,n$，求共有多少种不同的出栈序列。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/166261131">AC</a> 680.00KB 15ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 30</span><br>ll n, h[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br>n=<span class="hljs-built_in">read</span>(), h[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) h[i]=h[i<span class="hljs-number">-1</span>]*(i*<span class="hljs-number">4</span><span class="hljs-number">-2</span>)/(i+<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, h[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>注意事项：$\text{Catalan}$ 数列的前 $6$ 项 $1,2,5,14,42,132$ 在考 $\text{CSP-J1&#x2F;S1}$ 前是要背过的。</p><p>在赛场上，不论是初赛还是复赛，你都不一定能看得出一道题是卡特兰数。<br>遇到排列组合题目，如果普通方法算不出来，优先往上面四种基本模型上套，看看是不是卡特兰数。</p><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>卡特兰数 - <a href="https://oi-wiki.org/math/combinatorics/catalan/">OI-Wiki</a><br>卡特兰数 - <a href="https://baike.baidu.com/item/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/6125746">百度百科</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSP-S1 2024 注意事项</title>
    <link href="/articles/CSP-S1-2024-Caution/"/>
    <url>/articles/CSP-S1-2024-Caution/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h3><ul><li><code>cd</code>进入目录，<code>cd ..</code>返回上一级目录。</li><li><code>ls</code>查看目录，<code>-a</code>用于查看隐藏文件。</li><li><code>mv</code>修改文件名。</li><li><code>&gt;</code>将结果打印到文件。</li><li><code>./文件名</code>执行可执行文件。</li><li><code>time ./文件名</code>测量可执行文件运行时间。</li><li><code>mkdir</code>创建新目录。</li><li><code>killall 进程名</code>杀掉后台进程</li></ul><hr><h3 id="寻址空间"><a href="#寻址空间" class="headerlink" title="寻址空间"></a>寻址空间</h3><p>32位系统最大支持 $4$ GB内存，64位系统很大。<br>指针变量：32位机上长度为 $4$ 字节，64位机上长度为 $8$ 字节。</p><hr><h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><p>KB、MB等是以 $10$ 为底的，进率 $1000$；KiB、Mib是以 $2$ 为底的，进率 $1024$。</p><hr><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><code>bool</code>类型只有<code>true</code>和<code>false</code>两种值，不是 $0$ 和 $1$。</li><li><code>short</code>二字节，<code>int=long</code>四字节，<code>long long</code>八字节。</li></ul><hr><h3 id="原码、补码和反码"><a href="#原码、补码和反码" class="headerlink" title="原码、补码和反码"></a>原码、补码和反码</h3><h4 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h4><p>符号位+真值的绝对值。<br>$+3\rightarrow 0000\ 0011$<br>$-3\rightarrow 1000\ 0011$</p><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>在原码的基础上，除符号位以外，各位取反。<br>$+3\rightarrow 0111\ 1100$<br>$-3\rightarrow 1111\ 1100$</p><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>正数的补码是其本身。<br>$+3\rightarrow 0000\ 0011$<br>负数的补码是除符号位外，各位取反后加 $1$，即反码 $+1$。<br>$-3\rightarrow 1111\ 1101$</p><hr><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>先根据结构将运算拆分成表达式树。</p><ul><li>前序遍历 - 前缀表达式 - 波兰式</li><li>中序遍历 - 中缀表达式</li><li>后序遍历 - 后缀表达式 - 逆波兰式</li></ul><hr><h3 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h3><p>详见<a href="https://oi-wiki.org/lang/op/#c-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E6%80%BB%E8%A1%A8">OI-Wiki</a>。</p><hr><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h4><p>在排序时不改变其序列，相等元素的相对位置不变。</p><p>对于序列 ${a_n}$，设其排序后为 ${b_n}$。<br>设 $a_{i_1}&#x3D;b_{i_2},\ a_{j_1}&#x3D;b_{j_2}$，对于所有的 $a_{i_1}&#x3D;a_{i_2}$，若满足 $i_1&lt;i_2$ 且 $j_1&lt;j_2$，则称该排序算法是稳定的。</p><p><strong>稳定</strong>的排序算法有插入排序、<strong>基数排序</strong>、<strong>归并排序</strong>、<strong>冒泡排序</strong>、计数排序等。<br><strong>不稳定</strong>的排序算法有<strong>快速排序</strong>、希尔排序、简单选择排序、<strong>堆排序</strong>等。</p><hr><h3 id="图的着色"><a href="#图的着色" class="headerlink" title="图的着色"></a>图的着色</h3><h4 id="点着色"><a href="#点着色" class="headerlink" title="点着色"></a>点着色</h4><p>对无向图顶点着色，且相邻顶点不能同色。</p><h4 id="边着色"><a href="#边着色" class="headerlink" title="边着色"></a>边着色</h4><p>对无向图的边着色，要求相邻的边涂不同种颜色。</p><hr><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>无向图，将所有节点排序，使得排在前面的节点不能依赖于排在后面的节点。</p><p>每次先将入度为 $0$ 的点删除后放入列表，再将其连接的所有边删除，新产生的入度为 $0$ 的点进入队列。重复直到队列为空。<br>若列表元素个数 $&#x3D;n$，则说明原图无环，列表里即为已排序的点；<br>若列表元素个数 $&lt;n$，则说明原图有环。</p><hr><h3 id="待学习"><a href="#待学习" class="headerlink" title="待学习"></a>待学习</h3><ul><li>CCF成立时间、NOI系列赛事开始时间等。</li><li>期望和概率。</li><li>信息学相关奖项。</li><li>信息学历史人物。</li><li>计算机基本结构和发展历程。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分块思想</title>
    <link href="/articles/Chunking/"/>
    <url>/articles/Chunking/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="分块的基本思想"><a href="#分块的基本思想" class="headerlink" title="分块的基本思想"></a>分块的基本思想</h3><p>解决序列问题。<br>通过对原数据进行适当划分，再对操作分成整块和零块，从而通过一般的暴力算法取得较优秀的时间复杂度。</p><p>本文将针对分块思想的三种经典应用场景，简要说明分块的一般形式，以及如何具体运用。</p><hr><h3 id="分块的基本性质"><a href="#分块的基本性质" class="headerlink" title="分块的基本性质"></a>分块的基本性质</h3><p>分块的时间复杂度和空间复杂度都不及线段树优秀，但能处理许多线段树无法处理的区间问题。<br>它的时空复杂度与分的块长密切相关，所以需要针对特定题目做出合适的块长选择。</p><hr><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><p><a href="https://www.luogu.com.cn/problem/P3372">洛谷P3372</a> 线段树 1</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>维护数列，支持以下操作：<br>1.区间 $[l,r]$ 全部加 $k$；<br>2.求区间 $[l,r]$ 的和。</p><h4 id="数据分块"><a href="#数据分块" class="headerlink" title="数据分块"></a>数据分块</h4><p>我们将数列 ${a_n}$ 按每 $s$ 个元素分一个块，那么它看起来是这样的：<br>${a_n}&#x3D;\underline{a_1,a_2,a_3,\dots,a_s},\underline{a_{s+1},a_{s+2},\dots,a_{2s}},\dots,\underline{a_{n-?},\dots,a_{n-1},a_{n}}$<br>这样，原数据就被分为了 $\lceil\frac n s\rceil$ 块。</p><p>不难发现，受 $n$ 的限制，最后一块往往不是整块。</p><p>针对区间加&#x2F;查询操作，设 $sum_i$ 为第 $i$ 块的和；$add_i$ 为第 $i$ 块的懒标记，表示这一块额外加了多少(类似线段树中的LazyTag)。<br>对整块的懒标记 $add_i$ 不计入 $sum_i$ 中。</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>将 $a_i$ 读入，预处理出 $sum_i$，将 $add_i$ 赋值为 $0$。<br>设 $t$ 为总块数，则 $t&#x3D;\lceil\frac ns\rceil$。<br>设 $bel_i$ 为 $a_i$ 所处的块，则 $bel_i&#x3D;\lfloor\frac{n-1}s\rfloor+1$。<br>设 $st_i$ 为第 $i$ 个块的起始位置(含)，则 $st_i&#x3D;(i-1)\times s+1$。<br>设 $ed_i$ 为第 $i$ 个块的结束位置(含)，则 $ed_i&#x3D;i\times s$。</p><p>这样，第 $i$ 个数属于第 $bel_i$ 块，第 $i$ 个块对应数列下标 $[st_i,ed_i]$。</p><h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><p>操作：区间 $[l,r]$ 所有数加 $k$。<br>为表示方便和代码简洁，设 $pl&#x3D;bel_l$，$pr&#x3D;bel_r$。</p><p>当 $l$ 与 $r$ 在同一块内，即 $pl&#x3D;pr$ 时，直接暴力处理。<br>遍历 $i\in[l,r]$，$a_i\leftarrow a_i+k$。</p><p>当 $l$ 与 $r$ 不在同一块内，即 $pl\neq pr$ 时，为充分发挥分块的优势，整块的应整块处理，零散的单独处理。<br>针对整块，其序号区间为 $[pl+1,pr-1]$ (因为 $pl$ 和 $pr$ 都是散块)。遍历 $i\in[pl+1,pr-1]$，$add_i\leftarrow add_i+k$。<br>针对散块，其对应数列下标为 $[l,ed_{pl}]\cup[st_{pr},r]$。遍历 $i\in[l,ed_{pl}]\cup[st_{pr},r]$，$a_i\leftarrow a_i+k$，$sum_i\leftarrow sum_i+k$。</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>操作：查询区间 $[l,r]$ 所有树的和。<br>为表示方便和代码简洁，设 $pl&#x3D;bel_l$，$pr&#x3D;bel_r$。</p><p>当 $l$ 与 $r$ 在同一块内，即 $pl&#x3D;pr$ 时，直接暴力处理。<br>遍历 $i\in[l,r]$，$ans\leftarrow ans+a_i$。</p><p>当 $l$ 与 $r$ 不在同一块内，即 $pl\neq pr$ 时，整块零散分别处理。<br>针对整块，其序号区间为 $[pl+1,pr-1]$ (因为 $pl$ 和 $pr$ 都是散块)。遍历 $i\in[pl+1,pr-1]$，$ans\leftarrow ans+sum_i$，$ans\leftarrow ans+add_i\times (ed_i-st_i+1)$。(这里不直接用块长是防止缺的块，虽然确实不可能对短块进行这个操作，但还是这样计算比较好。)<br>针对散块，其对应数列下标为 $[l,ed_{pl}]\cup[st_{pr},r]$。遍历 $i\in[l,ed_{pl}]\cup[st_{pr},r]$，$ans\leftarrow ans+k$，$ans\leftarrow ans+add_{pl&#x2F;pr}$。</p><h4 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h4><p>注意到零散数据中，修改时的 $sum$ 每次都加了 $k$，查询时的 $add$ 每次都需要加。直接乘起来一起加即可，具体实现见代码。</p><h4 id="确定块长"><a href="#确定块长" class="headerlink" title="确定块长"></a>确定块长</h4><p>时间复杂度 $O(\frac ns+s)$，由均值不等式得 $s&#x3D;\sqrt n$ 时最优。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/164148062">AC</a> 4.66MB 143ms (比我的线段树快了23ms)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br>ll n;<br>ll buildSource[N];<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunking_summation</span> &#123;<br>ll block, t;<br>ll st[N], ed[N], pos[N];<br>T a[N], sum[N], add[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>block=<span class="hljs-built_in">sqrt</span>(n), t=n/block; <span class="hljs-keyword">if</span> (n%block) ++t;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=t; ++i) st[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>, ed[i]=i*block; ed[t]=n;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) pos[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>, a[i]=buildSource[i];<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=t; ++i) <span class="hljs-keyword">for</span> (ll j=st[i]; j&lt;=ed[i]; ++j) sum[i]+=a[j];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll l, ll r, T k)</span> </span>&#123;<br>ll pl=pos[l], pr=pos[r];<br><span class="hljs-keyword">if</span> (pl==pr) &#123;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=r; ++i) a[i]+=k;<br>sum[pl]+=k*(r-l+<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i=pl+<span class="hljs-number">1</span>; i&lt;=pr<span class="hljs-number">-1</span>; ++i) add[i]+=k;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=ed[pl]; ++i) a[i]+=k; sum[pl]+=k*(ed[pl]-l+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (ll i=st[pr]; i&lt;=r; ++i) a[i]+=k; sum[pr]+=k*(r-st[pr]+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function">T <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r)</span> </span>&#123;<br>ll pl=pos[l], pr=pos[r]; T ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (pl==pr) &#123;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=r; ++i) ans+=a[i];<br>ans+=add[pl]*(r-l+<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i=pl+<span class="hljs-number">1</span>; i&lt;=pr<span class="hljs-number">-1</span>; ++i) ans+=sum[i]+add[i]*(ed[i]-st[i]+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=ed[pl]; ++i) ans+=a[i]; ans+=add[pl]*(ed[pl]-l+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (ll i=st[pr]; i&lt;=r; ++i) ans+=a[i]; ans+=add[pr]*(r-st[pr]+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><hr><h3 id="区间排名"><a href="#区间排名" class="headerlink" title="区间排名"></a>区间排名</h3><p><a href="https://www.luogu.com.cn/problem/P2801">洛谷P2801</a> 教主的魔法</p><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>维护序列，支持以下操作：<br>1.区间 $[l,r]$ 整体加 $k$；<br>2.求区间 $[l,r]$ 由多少数大于等于 $k$。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>维护另一个块内单调不降序列 $b_i$。<br>修改后重新排序，保持单调性；查询时整块区间二分查找 $k$ 的位置，后面的就都是合法的。</p><h4 id="数据分块-1"><a href="#数据分块-1" class="headerlink" title="数据分块"></a>数据分块</h4><p>区别于“区间和”，不需要维护 $sum$，需要对每个区间维护排序数组 $b_i$，确保 $b_i$ 单调不降。</p><h4 id="预处理-1"><a href="#预处理-1" class="headerlink" title="预处理"></a>预处理</h4><p>每个区间内的 $b_i$ 排序，其余同上。</p><h4 id="修改操作-1"><a href="#修改操作-1" class="headerlink" title="修改操作"></a>修改操作</h4><p>修改后每个区间内的 $b_i$ 排序，其余同上。</p><h4 id="查询操作-1"><a href="#查询操作-1" class="headerlink" title="查询操作"></a>查询操作</h4><p>对于整块，二分查找 $k$ 的位置，根据单调性确定符合要求的数的数量；针对散数，暴力遍历，统计大于等于 $k$ 的数。其余同上。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/164168788">AC</a> 38.92MB 415ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000010</span><br>ll n;<br>ll buildSource[N];<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunking_ranking</span> &#123;<br>ll block, t;<br>ll st[N], ed[N], pos[N];<br>T a[N], b[N], add[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>block=<span class="hljs-built_in">sqrt</span>(n), t=n/block; <span class="hljs-keyword">if</span> (n%block) ++t;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=t; ++i) st[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>, ed[i]=i*block; ed[t]=n;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) pos[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>, a[i]=b[i]=buildSource[i];<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=t; ++i) <span class="hljs-built_in">sort</span>(b+st[i], b+ed[i]+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(ll p)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (ll i=st[p]; i&lt;=ed[p]; ++i) b[i]=a[i]; <span class="hljs-built_in">sort</span>(b+st[p], b+ed[p]+<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">find</span><span class="hljs-params">(ll p, T k)</span> </span>&#123;<br>ll l=st[p], r=ed[p], mid=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (l&lt;=r) mid=l+r&gt;&gt;<span class="hljs-number">1</span>, (b[mid]&gt;=k)?r=mid<span class="hljs-number">-1</span>:l=mid+<span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> ed[p]-l+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll l, ll r, T k)</span> </span>&#123;<br>ll pl=pos[l], pr=pos[r];<br><span class="hljs-keyword">if</span> (pl==pr) &#123;<span class="hljs-keyword">for</span> (ll i=l; i&lt;=r; ++i) a[i]+=k; <span class="hljs-built_in">reset</span>(pl); <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">for</span> (ll i=pl+<span class="hljs-number">1</span>; i&lt;=pr<span class="hljs-number">-1</span>; ++i) add[i]+=k;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=ed[pl]; ++i) a[i]+=k; <span class="hljs-built_in">reset</span>(pl);<br><span class="hljs-keyword">for</span> (ll i=st[pr]; i&lt;=r; ++i) a[i]+=k; <span class="hljs-built_in">reset</span>(pr);<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, T k)</span> </span>&#123;<br>ll pl=pos[l], pr=pos[r], ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (pl==pr) &#123;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=r; ++i) <span class="hljs-keyword">if</span> (a[i]+add[pl]&gt;=k) ++ans;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i=pl+<span class="hljs-number">1</span>; i&lt;=pr<span class="hljs-number">-1</span>; ++i) ans+=<span class="hljs-built_in">find</span>(i, k-add[i]);<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=ed[pl]; ++i) <span class="hljs-keyword">if</span> (a[i]+add[pl]&gt;=k) ++ans;<br><span class="hljs-keyword">for</span> (ll i=st[pr]; i&lt;=r; ++i) <span class="hljs-keyword">if</span> (a[i]+add[pr]&gt;=k) ++ans;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><hr><h3 id="分块哈希"><a href="#分块哈希" class="headerlink" title="分块哈希"></a>分块哈希</h3><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=4391">HDU4391</a> Paint The Wall</p><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>维护一个序列，支持以下操作：<br>1.区间 $[l,r]$ 全部变为 $k$；<br>2.查询区间 $[l,r]$ 有多少值为 $k$。</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>对每个块开一个map $mp$ 记录出现次数，$tag$ 表示全部设为多少。</p><h4 id="预处理-2"><a href="#预处理-2" class="headerlink" title="预处理"></a>预处理</h4><p>$mp$ 清空，$tag\leftarrow -1$。</p><h4 id="修改操作-2"><a href="#修改操作-2" class="headerlink" title="修改操作"></a>修改操作</h4><p>对于整块，$tag\leftarrow k$；对于散块，暴力修改 $map$ 即可。</p><h4 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h4><p>将 $tag$ 清空并将数据转移到 $mp$ 上，用于每次散块操作前。</p><h4 id="查询操作-2"><a href="#查询操作-2" class="headerlink" title="查询操作"></a>查询操作</h4><p>对于整块，判断是否有 $tag$，若有按全覆盖算，若无则统计 $mp$；对于散块，循环枚举统计即可。</p><h4 id="确定块长-1"><a href="#确定块长-1" class="headerlink" title="确定块长"></a>确定块长</h4><p>由于使用了map，块长应为 $\sqrt{n\log n}$，但是我这里用了 $\sqrt n$。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p><a href="https://acm.hdu.edu.cn/viewcode.php?rid=39418125">AC</a> 19.21MB 3775ms <a href="https://vjudge.net/solution/52351917/zYyyz9BeEubG7leSMxzF">Another Link</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 200010</span><br>ll n;<br>ll buildSource[N];<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">chunking_hashing</span> &#123;<br>ll block, t, st[N], ed[N], pos[N];<br>T a[N], tag[N]; map&lt;T, ll&gt; mp[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>block=<span class="hljs-built_in">sqrt</span>(n), t=n/block; <span class="hljs-keyword">if</span> (n%block) ++t;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=t; ++i) st[i]=(i<span class="hljs-number">-1</span>)*block+<span class="hljs-number">1</span>, ed[i]=<span class="hljs-built_in">min</span>(n,i*block);<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) pos[i]=(i<span class="hljs-number">-1</span>)/block+<span class="hljs-number">1</span>, a[i]=buildSource[i];<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=t; ++i) mp[i].<span class="hljs-built_in">clear</span>(), tag[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) mp[pos[i]][a[i]]++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_down</span><span class="hljs-params">(ll p)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!~tag[p]) <span class="hljs-keyword">return</span>; <span class="hljs-keyword">for</span> (ll i=st[p]; i&lt;=ed[p]; ++i) a[i]=tag[p];<br>mp[p].<span class="hljs-built_in">clear</span>(), mp[p][tag[p]]=ed[p]-st[p]+<span class="hljs-number">1</span>, tag[p]=<span class="hljs-number">-1</span>; <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ll l, ll r, T k)</span> </span>&#123;<br>ll pl=pos[l], pr=pos[r]; <span class="hljs-built_in">push_down</span>(pl), <span class="hljs-built_in">push_down</span>(pr);<br><span class="hljs-keyword">if</span> (pl==pr) &#123;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=r; ++i) --mp[pl][a[i]], a[i]=k, ++mp[pl][a[i]];<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i=pl+<span class="hljs-number">1</span>; i&lt;=pr<span class="hljs-number">-1</span>; ++i) tag[i]=k;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=ed[pl]; ++i) --mp[pl][a[i]], a[i]=k, ++mp[pl][a[i]];<br><span class="hljs-keyword">for</span> (ll i=st[pr]; i&lt;=r; ++i) --mp[pr][a[i]], a[i]=k, ++mp[pr][a[i]];<br>&#125;<br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll l, ll r, T k)</span> </span>&#123;<br>ll pl=pos[l], pr=pos[r], ans=<span class="hljs-number">0</span>; <span class="hljs-built_in">push_down</span>(pl), <span class="hljs-built_in">push_down</span>(pr);<br><span class="hljs-keyword">if</span> (pl==pr) &#123;<span class="hljs-keyword">for</span> (ll i=l; i&lt;=r; ++i) ans+=a[i]==k; <span class="hljs-keyword">return</span> ans;&#125;<br><span class="hljs-keyword">for</span> (ll i=pl+<span class="hljs-number">1</span>; i&lt;=pr<span class="hljs-number">-1</span>; ++i) &#123;<br><span class="hljs-keyword">if</span> (~tag[i]) &#123;<span class="hljs-keyword">if</span> (tag[i]==k) ans+=ed[i]-st[i]+<span class="hljs-number">1</span>;&#125;<br><span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> (mp[i].<span class="hljs-built_in">count</span>(k)) ans+=mp[i][k];&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i=l; i&lt;=ed[pl]; ++i) ans+=a[i]==k;<br><span class="hljs-keyword">for</span> (ll i=st[pr]; i&lt;=r; ++i) ans+=a[i]==k;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>分块是一种思想，不同的题目有不同的做法，具体情况具体分析。<br>分块强调整块的统一处理，算法设计十分重要。</p><p>块长直接决定了时间复杂度，合理选择块长能做到更短的时间。<br>有的题会卡分块，这时块长可以改 $\sqrt n\pm1$、$\sqrt{\frac n{\lg n}}$ 或常数 $\sqrt N$。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Tarjan算法求强连通分量</title>
    <link href="/articles/The-Tarjan-Algorithm-for-Strongly-Connected-Components/"/>
    <url>/articles/The-Tarjan-Algorithm-for-Strongly-Connected-Components/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="罗伯特·塔扬"><a href="#罗伯特·塔扬" class="headerlink" title="罗伯特·塔扬"></a>罗伯特·塔扬</h4><p>图灵奖得主，追求坚持和创新。<br>发明了许多算法，持续在数学和计算机领域发光发热。</p><p>并查集、Toptree、Splay等算法都是他发明的。</p><h4 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h4><p>在对树进行深度优先搜索遍历时，对于每个节点，在刚进入递归后记录一次该点的编号，得到的最后产生的长度为 $N$ 的节点序列。<br>设点 $u$ 入栈时时间为 $dfs_u&#x3D;l_u$，出栈时时间为 $r_u$，若 $v\in T_u$，则 $dfn_v\in[l_u,r_u]$。详见<a href="https://oi-wiki.org/graph/dfs/#dfs-%E5%BA%8F%E5%88%97">OI-Wiki</a>。</p><h4 id="DFS搜索树"><a href="#DFS搜索树" class="headerlink" title="DFS搜索树"></a>DFS搜索树</h4><p>如图所示，在一个有向图上跑DFS所生成的树。<br>DFS搜索树的所有边都由原图中的边组成。</p><p>有以下几条边：<br>1.树边：表示DFS搜索顺序；<br>2.横叉边(斜向边)：兄弟节点之间的边；<br>3.前向边：由祖先指向儿子的边(不包含父亲)；<br>4.返祖边(后向边)：由子节点指向父亲或祖先的边。<br>对于后三种边，要求指向的节点已被访问。一般意义上，“搜索树上的边”仅指树边。</p><p>如图所示：<br><img src="../../img/38-01.gif" alt="38-02" style="zoom:100%;" />  </p><h4 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h4><p>本文所述的<strong>强连通</strong>是对于有向图而言的。</p><p>若有向图 $G&#x3D;(V,E)$ 强连通，则说明对于 $\forall u,v\in V$，总存在路径 $u\rightsquigarrow v$，使得 $u$、$v$ 两点联通。强连通分量指极大的强联通子图。</p><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><p>先进后出的数据结构，详见<a href="https://oi-wiki.org/ds/stack/">OI-Wiki</a>。</p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>约定：$T_u$ 表示以 $u$ 为根的子树，且包含 $u$；一个点的祖先不包括其父节点。</p><p>注意：DFS序 $\neq$ DFN。<br>DFN是一个时间戳，是一棵树在DFS过程中访问的相应次序。<br>DFS序记录了树上每个点进出的时间戳。</p><hr><h3 id="DFS生成树与强连通分量的关系"><a href="#DFS生成树与强连通分量的关系" class="headerlink" title="DFS生成树与强连通分量的关系"></a>DFS生成树与强连通分量的关系</h3><p>如果节点 $u$ 是DFS过程中遇到的第一个强连通分量中的点，则强连通分量中剩余的节点一定在 $T_u$ 中。我们称 $u$ 为强连通分量的根。</p><hr><h3 id="Tarjan算法求强连通分量"><a href="#Tarjan算法求强连通分量" class="headerlink" title="Tarjan算法求强连通分量"></a>Tarjan算法求强连通分量</h3><h4 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h4><p>点集 $S$ 表示 $T_u$ 中的节点及从 $T_u$ 通过一条不在搜索树上的边能到达的节点。</p><p>$dfn_u$：点 $u$ 第一次被遍历的时间。<br>$low_u$：在 $T_u$ 中能够回溯到最早的已经在栈中的节点的 $dfn$，且 $low_u&#x3D;\min\limits_{v\in S}dfn_v$。至于为什么这两个是一个意思，后面会解释到。<br>$scc_u$：答案统计，表示 $u$ 在哪个强连通分量中。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>从根节点开始的一条路径中，$dfn$ 严格递增，$low$ 严格非降。即，$dfn_{fa}&lt;dfn_u$，$low_{fa}\le low_u$。<br>$dfn$ 递增性质可由定义得知。由于子节点的 $low$ 会被父节点取一次 $\min$，所以父节点的 $low$ 会大于或等于子节点的，$low$ 数组满足非降性质。</p><h4 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h4><p>从根节点开始DFS，让搜索到的点入栈。每找到一个强连通分量就让强连通分量中的点出栈。<br>正确性：由于强连通分量是<strong>极大的联通子图</strong>，所以不会出现一个强连通分量包含另一个的情况。另外，使用栈维护，<strong>先进后出</strong>，可以确保当前强连通分量仅处于栈顶及附近位置，弹出时不会干扰到上层强连通分量的检索和记录。</p><p>假设当前搜索到了点 $u$ ，先将点 $u$ 入栈。设 $u$ 可通过边 $e&#x3D;u\rightarrow v$ 到达点 $v$，则：<br>1.若 $v$ 未被访问，说明 $e$ 是搜索树上的边，$v\in T_u$。根据定义，$low_u&#x3D;\min{low_u,low_v}$。此时需继续对 $v$ 进行DFS。<br>2.若 $v$ 已被访问且在栈中，说明 $v\notin T_u$，$e$ 也不在搜索树中。根据定义，$low_u&#x3D;\min{low_u,dfn_v}$。此时不可继续对 $v$ 进行DFS，否则会死循环，且不满足 $low$ 的定义，答案正确性无法保证。<br>3.若 $v$ 已被访问且未在栈中，说明 $v$ 已搜索完毕，且所在强连通分量已被处理，无需进行任何操作。</p><h4 id="答案处理"><a href="#答案处理" class="headerlink" title="答案处理"></a>答案处理</h4><p>根据 $low$ 的定义，当且仅当节点 $u$ 为强连通分量的根时，$dfn_u&#x3D;low_u$。<br>因为在强连通分量中，所有点都可到达根 $u$。这些点的 $low$ 值只可能大于或等于 $u$。<br>另外，强连通分量的剩余节点都在 $T_u$ 且都已搜索入栈，所以栈中 $u$ 之上的都是强连通分量中的点，而在 $u$ 之下的都不是。</p><p>统计答案只需弹栈，弹完 $u$ 为止，弹栈前 $cnt$ 需要加一，表示新的强连通分量。设 $x$ 为栈顶元素，只需将 $scc_x$ 设为标记 $cnt$ 即可。</p><h4 id="关于-low-的问题解答"><a href="#关于-low-的问题解答" class="headerlink" title="关于 $low$ 的问题解答"></a>关于 $low$ 的问题解答</h4><p>Q: 为什么 $low$ 也是在 $T_u$ 中能够回溯到最早的已经在栈中的节点的 $dfn$？<br>A: 分析上述维护过程，前两种情况中的 $v$ 都在栈中。(情况1在对 $v$ DFS之后 $v$ 就进了栈。)</p><p>Q: 为什么需要一个 $low$ 辅助算法完成？为什么这样设计 $low$？<br>A: 通过 $low$ 的特殊性质，可以保证算法实现简便，同时有正确的答案和相当优秀的时间复杂度。至于如何想出来的，只能说是Tarjan的神力。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><a href="https://www.luogu.com.cn/problem/B3609">洛谷B3609</a> 强连通分量</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一张 $n$ 个点 $m$ 条边的有向图，求出其所有的强连通分量。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/163839824">AC</a> 2.36MB 8ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 100005</span><br><span class="hljs-type">int</span> n, m, t1, t2;<br><span class="hljs-type">int</span> dfn[N], tim, low[N];<br><span class="hljs-type">int</span> stk[N], top; <span class="hljs-type">bool</span> instk[N];<br><span class="hljs-type">int</span> scc[N], cnt, siz[N];<br><br><span class="hljs-type">int</span> vis[N];<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br><span class="hljs-type">int</span> head[N], tot;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<span class="hljs-type">int</span> to, nxt;&#125; e[M&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;e[++tot]=&#123;y, head[x]&#125;, head[x]=tot;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>dfn[u]=low[u]=++tim, stk[++top]=u, instk[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (!dfn[v]) <span class="hljs-built_in">tarjan</span>(v), low[u]=<span class="hljs-built_in">min</span>(low[u], low[v]);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instk[v]) low[u]=<span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>&#125;<br><span class="hljs-keyword">if</span> (dfn[u]==low[u]) &#123;<br>++cnt;<br><span class="hljs-keyword">while</span> (stk[top+<span class="hljs-number">1</span>]!=u) scc[stk[top]]=cnt, instk[stk[top--]]=<span class="hljs-number">0</span>, ++siz[cnt];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>(), <span class="hljs-built_in">add_edge</span>(t1, t2);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-keyword">if</span> (!dfn[i]) <span class="hljs-built_in">tarjan</span>(i);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>; <span class="hljs-type">int</span> x=scc[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j) <span class="hljs-keyword">if</span> (scc[j]==x) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, j), vis[j]=<span class="hljs-number">1</span>;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>无特殊说明，图均可能不连通，且均可能有重边或自环，所以<strong>特判</strong>千万不能忘！<br>一般关于scc的题目，都需要循环 $1\sim n$ DFS，以寻找全部的强连通分量。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Tarjan算法求强连通分量关键在于 $low$ 的理解与运用。Tarjan算法还有许多变形，需要根据情况调整代码解决问题。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FHQ Treap</title>
    <link href="/articles/FHQ-Treap/"/>
    <url>/articles/FHQ-Treap/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p><strong>左子树</strong>点权均<strong>小于</strong>根节点，<strong>右子树</strong>点权都<strong>大于</strong>根节点的二叉树。<br>它有很多好的性质，详见<a href="https://oi-wiki.org/ds/bst/#%E5%AE%9A%E4%B9%89">OI-Wiki</a>。</p><h4 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h4><p>左右子树高度差不太大的二叉树，详见<a href="https://oi-wiki.org/ds/bst/#%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%AE%80%E4%BB%8B">OI-Wiki</a>。<br>阅读本文，你并不需要了解平衡树的旋转操作。</p><h4 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h4><p>&#x3D;Tree+Heap，同时满足二叉搜索树和堆的性质。详见<a href="https://oi-wiki.org/ds/treap/">OI-Wiki</a>。</p><h4 id="范浩强"><a href="#范浩强" class="headerlink" title="范浩强"></a>范浩强</h4><p>IOI金牌，天才AI少年，旷世奇才。自己<a href="https://www.baidu.com/s?wd=%E8%8C%83%E6%B5%A9%E5%BC%BA">百度一下</a>感受强者风范。<br>本文所介绍的FHQ Treap正是这位大佬发明的，实现方法尤为<strong>精妙</strong>。</p><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>FHQ Treap (也叫非旋Treap)，是一个数据结构，可以通过分裂和合并完成插入、删除和查询排名等操作。<br>与其它维护平衡树的基本算法不同，FHQ Treap不需要旋转。</p><p>维护信息：左右儿子 $ls$、$rs$，权值 $val$、子树大小 $siz$ 及随机优先级 $rnd$。</p><hr><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="新建节点"><a href="#新建节点" class="headerlink" title="新建节点"></a>新建节点</h4><p>赋值 $val\leftarrow v$，$siz\leftarrow1$。<br>$rnd$ 赋值为某个随机数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-keyword">return</span> val[++tot]=v, rnd[tot]=<span class="hljs-built_in">rand</span>(), siz[tot]=<span class="hljs-number">1</span>, tot;&#125;<br></code></pre></td></tr></table></figure><h4 id="更新答案"><a href="#更新答案" class="headerlink" title="更新答案"></a>更新答案</h4><p>将左右儿子的答案更新到父节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;siz[p]=siz[ls[p]]+siz[rs[p]]+<span class="hljs-number">1</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>一般按权值分裂，少数题目需要按子树大小分裂。(按大小分裂我还没搞明白，可以多看看相关题目的题解自主学习。)</p><p>通过按权值分裂与合并维护的FHQ Treap满足右儿子大于左儿子。即，对于任意节点 $u$，满足 $val_{ls}\le val_u&lt;val_{rs}$。</p><p>若将原平衡树 $T$ 按权值 $v$ 分裂为两个平衡树 $T_x$ 和 $T_y$，则对于任意 $i\in T_x$，$j\in T_y$，均满足 $val_i\le v&lt;val_j$。</p><p>设当前节点为 $p$。<br>1.如果 $val_p\le v$，则 $p$ 属于 $T_x$，同时 $p$ 的左子树 $T_{ls_p}$ 中所有节点权值也均小于或等于 $v$，属于 $T_x$。<br>2.如果 $val_p&gt;v$，则 $p$ 属于 $T_y$，同时 $p$ 的右子树 $T_{rs_p}$ 中所有节点权值也均大于 $v$，属于 $T_y$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将子树p按权值v分裂为以x和y为根节点的两棵树</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spl</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br><span class="hljs-keyword">if</span> (val[p]&lt;=v) <span class="hljs-built_in">spl</span>(rs[p], v, rs[x=p], y);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">spl</span>(ls[p], v, x, ls[y=p]);<br><span class="hljs-built_in">push</span>(p);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>合并两棵树 $T_x$、$T_y$，必须满足对于任意 $i\in T_x$，$j\in T_y$，都有 $val_i&lt;val_j$，即 $T_x$ 树上最大节点小于 $T_y$ 树上最小节点。</p><p>FHQ Treap的合并遵循Treap的原则，以 $rnd$ 作为判断节点父子关系的标准，以 $val$ 作为判断左右儿子的标准。至于为什么 $rnd$ 决定上下，在后文里会解释。</p><p>假设合并节点 $x$、$y$，且 $val_x&lt;val_y$。<br>1.当 $rnd_x&gt;rnd_y$，即 $x$ 为 $y$ 的父亲时，$y$ 是 $x$ 的右儿子。将 $T_y$ 合并到 $x$ 右子树上，$rs_x$ 赋值为 $\operatorname{merge}(rs_x,y)$ 即可。<br>2.当 $rnd_x\le rnd_y$，即 $y$ 为 $x$ 的父亲时，$x$ 是 $y$ 的左儿子。将 $T_x$ 合并到 $y$ 左子树上，$ls_y$ 赋值为 $\operatorname{merge}(ls_y,x)$ 即可。<br>3.当 $T_x$ 或 $T_y$ 为空时，返回非空的那棵树即可。<br>合并完成后需要更新答案(push)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 将根节点为x和y的两棵数合并，返回合并后的根节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mer</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x||!y) <span class="hljs-keyword">return</span> x|y;<br><span class="hljs-keyword">if</span> (rnd[x]&lt;rnd[y]) <span class="hljs-keyword">return</span> ls[y]=<span class="hljs-built_in">mer</span>(x, ls[y]), <span class="hljs-built_in">push</span>(y), y;<br><span class="hljs-keyword">return</span> rs[x]=<span class="hljs-built_in">mer</span>(rs[x], y), <span class="hljs-built_in">push</span>(x), x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mer</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">mer</span>(x, <span class="hljs-built_in">mer</span>(y, z));&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="复杂操作"><a href="#复杂操作" class="headerlink" title="复杂操作"></a>复杂操作</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>将树分裂为两部分后，在中间插入新节点。<br>分裂时按新节点权值分裂，以保证有序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在树rt中插入权值为v的点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>; <span class="hljs-built_in">spl</span>(rt, v<span class="hljs-number">-1</span>, x, y), rt=<span class="hljs-built_in">mer</span>(x, <span class="hljs-built_in">add</span>(v), y);&#125;<br></code></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>假设需要删除的点的权值为 $k$，将原树 $T$ 按 $v$ 拆为 $T_x$、$T_y$、$T_z$ 三个子树。<br>对于任意 $p\in T_x$，$val_p\le v-1$；<br>对于任意 $p\in T_y$，$val_p&#x3D;v$；<br>对于任意 $p\in T_z$，$val_p&gt; v$。</p><p>接着，将 $T_y$ 的根节点删除，再将左右子树合并构成新的 $T_y$，然后将 $T_x$、$T_y$ 和 $T_z$ 依次合并还原原树 $T$。<br>这样，保证删去的点恰为一个，且权值为 $k$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在树rt中删除一个权值为v的点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, z=<span class="hljs-number">0</span>; <span class="hljs-built_in">spl</span>(rt, v<span class="hljs-number">-1</span>, x, y), <span class="hljs-built_in">spl</span>(y, v, y, z);<br>y=<span class="hljs-built_in">mer</span>(ls[y], rs[y]), rt=<span class="hljs-built_in">mer</span>(x, y, z);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查询第k大"><a href="#查询第k大" class="headerlink" title="查询第k大"></a>查询第k大</h4><p>根据FHQ Treap的有序性，只需要根据子树大小决定前往左&#x2F;右子树查找即可。</p><p>假设需要查找第 $k$ 大，且当前遍历到了点 $p$。<br>1.若 $k&lt;siz_{ls_p}+1$，则说明找的 $p$ 过了，需要向左儿子递归。<br>2.若 $k&#x3D;siz_{ls_p}+1$，则说明找的 $p$ 恰好是第 $k$ 个，返回即可。<br>3.若 $k&gt;siz_{ls_p}+1$，则说明找的 $p$ 少了，需要向右儿子递归。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 查询第k大的节点权值并返回</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=rt; ; ) &#123;<br><span class="hljs-keyword">if</span> (k&lt;siz[ls[p]]+<span class="hljs-number">1</span>) p=ls[p];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k&gt;siz[ls[p]]+<span class="hljs-number">1</span>) k-=siz[ls[p]]+<span class="hljs-number">1</span>, p=rs[p];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> val[p];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查询前驱-后继"><a href="#查询前驱-后继" class="headerlink" title="查询前驱&#x2F;后继"></a>查询前驱&#x2F;后继</h4><p>下面是第一种做法，在 $T$ 中查询 $val_p&#x3D;v\plusmn1$ 的点。<br>借助FHQ Treap的有序性，大了向左子树找，小了向右子树找，直到叶子节点。每一次存下答案，以便找小于 $k$ 的最大值(前驱)或大于 $k$ 的最小值(后继)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 查询权值小于v的最大权值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=rt, ans=<span class="hljs-number">0</span>; ; ) &#123;<br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v&lt;=val[p]) p=ls[p];<br><span class="hljs-keyword">else</span> ans=val[p], p=rs[p];<br>&#125;<br>&#125;<br><span class="hljs-comment">// 查询权值大于v的最小权值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=rt, ans=<span class="hljs-number">0</span>; ; ) &#123;<br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v&gt;=val[p]) p=rs[p];<br><span class="hljs-keyword">else</span> ans=val[p], p=ls[p];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种基于分裂的做法。<br>1.前驱：按权值 $v-1$ 将原树 $T$ 分为 $T_x$ 和 $T_y$，使得任意 $p\in T_x$，均满足 $val_p\le v-1$。再从 $T_x$ 中沿右儿子遍历到叶子节点，找最大节点，即为前缀。<br>2.后继：按权值 $v$ 将原树 $T$ 分为 $T_x$ 和 $T_y$，使得任意 $p\in T_y$，均满足 $val_p&gt;v$。再从 $T_y$ 中沿左儿子遍历到叶子节点，找最小节点，即为后继。<br>3.合并 $T_x$、$T_y$，复原原树 $T$。</p><p>代码很简单不再写了，这种做法相较上一种常数较大。</p><h4 id="查询排名"><a href="#查询排名" class="headerlink" title="查询排名"></a>查询排名</h4><p>按权值 $v-1$ 将原树 $T$ 分为 $T_x$ 和 $T_y$，使得任意 $p\in T_x$，均满足 $val_p\le v-1$。<br>这样，小于 $v$ 的点均位于 $T_x$ 上，$siz_x$ 即为前面的点的总数，而 $siz_x+1$ 即为排名。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 查询权值v的排名，相同大小的不跳过</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rnk</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">spl</span>(rt, v<span class="hljs-number">-1</span>, x, y), ans=siz[x]+<span class="hljs-number">1</span>, rt=<span class="hljs-built_in">mer</span>(x, y);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="rnd生成目的"><a href="#rnd生成目的" class="headerlink" title="rnd生成目的"></a>rnd生成目的</h3><p>感性理解：Treap需要一个关键字 $val$，用以满足二叉树(Tree)的性质；需要一个顺序 $rnd$，以满足堆(Heap)的性质。<br>理性理解：如果没有 $rnd$，Treap会退化成一条<strong>链</strong>，进而无法达到 $O(\log n)$ 的时间复杂度，变为了 $O(n)$。</p><p>我们需要一个 $rnd$ 保证Treap不会退化成链，保持其有层次；还需要一个权值 $val$ 保证Treap有秩序以解决问题。故 $rnd$ 是为了满足大根堆性质而取的随机数，真正的权值 $val$ 是关键字。</p><p>由于 $rnd$ 是随机取的，所以FHQ Treap是期望平衡，不是严格平衡。而这也是其常数大于Splay算法的根本原因。</p><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P3369">洛谷P3369</a> 普通平衡树</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>您需要写一种数据结构，来维护一些数，其中需要提供以下操作：<br>1.插入一个数 $x$。<br>2.删除一个数 $x$（若有多个相同的数，应只删除一个）。<br>3.定义排名为比当前数小的数的个数 $+1$。查询 $x$ 的排名。<br>4.查询数据结构中排名为 $x$ 的数。<br>5.求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。<br>6.求 $x$ 的后继（后继定义为大于 $x$，且最小的数）。</p><p>对于操作 3,5,6，不保证当前数据结构中存在数 $x$。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/161257312">AC</a> 2.21MB 194ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br><span class="hljs-type">int</span> n, opt, x;<br><br><span class="hljs-keyword">namespace</span> FHQ &#123;<br><span class="hljs-type">int</span> rt, tot;<br><span class="hljs-type">int</span> ls[N], rs[N], val[N], rnd[N], siz[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;siz[p]=siz[ls[p]]+siz[rs[p]]+<span class="hljs-number">1</span>;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spl</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> x=y=<span class="hljs-number">0</span>, <span class="hljs-built_in">void</span>();<br><span class="hljs-keyword">if</span> (val[p]&lt;=v) <span class="hljs-built_in">spl</span>(rs[p], v, rs[x=p], y);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">spl</span>(ls[p], v, x, ls[y=p]);<br><span class="hljs-built_in">push</span>(p);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mer</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (!x||!y) <span class="hljs-keyword">return</span> x|y;<br><span class="hljs-keyword">if</span> (rnd[x]&lt;rnd[y]) <span class="hljs-keyword">return</span> ls[y]=<span class="hljs-built_in">mer</span>(x, ls[y]), <span class="hljs-built_in">push</span>(y), y;<br><span class="hljs-keyword">return</span> rs[x]=<span class="hljs-built_in">mer</span>(rs[x], y), <span class="hljs-built_in">push</span>(x), x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mer</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">mer</span>(x, <span class="hljs-built_in">mer</span>(y, z));&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-keyword">return</span> val[++tot]=v, rnd[tot]=<span class="hljs-built_in">rand</span>(), siz[tot]=<span class="hljs-number">1</span>, tot;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>; <span class="hljs-built_in">spl</span>(rt, v<span class="hljs-number">-1</span>, x, y), rt=<span class="hljs-built_in">mer</span>(x, <span class="hljs-built_in">add</span>(v), y);&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, z=<span class="hljs-number">0</span>; <span class="hljs-built_in">spl</span>(rt, v<span class="hljs-number">-1</span>, x, y), <span class="hljs-built_in">spl</span>(y, v, y, z);<br>y=<span class="hljs-built_in">mer</span>(ls[y], rs[y]), rt=<span class="hljs-built_in">mer</span>(x, y, z);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=rt; ; ) &#123;<br><span class="hljs-keyword">if</span> (k&lt;siz[ls[p]]+<span class="hljs-number">1</span>) p=ls[p];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k&gt;siz[ls[p]]+<span class="hljs-number">1</span>) k-=siz[ls[p]]+<span class="hljs-number">1</span>, p=rs[p];<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> val[p];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=rt, ans=<span class="hljs-number">0</span>; ; ) &#123;<br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v&lt;=val[p]) p=ls[p];<br><span class="hljs-keyword">else</span> ans=val[p], p=rs[p];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">suc</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p=rt, ans=<span class="hljs-number">0</span>; ; ) &#123;<br><span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> ans;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v&gt;=val[p]) p=rs[p];<br><span class="hljs-keyword">else</span> ans=val[p], p=ls[p];<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rnk</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">0</span>, y=<span class="hljs-number">0</span>, ans=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">spl</span>(rt, v<span class="hljs-number">-1</span>, x, y), ans=siz[x]+<span class="hljs-number">1</span>, rt=<span class="hljs-built_in">mer</span>(x, y);<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br>opt=<span class="hljs-built_in">read</span>(), x=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">if</span> (opt==<span class="hljs-number">1</span>) FHQ::<span class="hljs-built_in">ins</span>(x);<br><span class="hljs-keyword">if</span> (opt==<span class="hljs-number">2</span>) FHQ::<span class="hljs-built_in">del</span>(x);<br><span class="hljs-keyword">if</span> (opt==<span class="hljs-number">3</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, FHQ::<span class="hljs-built_in">rnk</span>(x));<br><span class="hljs-keyword">if</span> (opt==<span class="hljs-number">4</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, FHQ::<span class="hljs-built_in">kth</span>(x));<br><span class="hljs-keyword">if</span> (opt==<span class="hljs-number">5</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, FHQ::<span class="hljs-built_in">pre</span>(x));<br><span class="hljs-keyword">if</span> (opt==<span class="hljs-number">6</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, FHQ::<span class="hljs-built_in">suc</span>(x));<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>范浩强太强了，能想出如此巧妙的平衡树实现方法！<br>FHQ Treap代码简洁，通俗易懂。虽速度最慢，但对初学选手相当友好。</p><p>FHQ Treap通过分裂与合并，完成平衡树的插入、删除和查询等操作。<br>注意分裂时按什么标准去分，是 $v$，还是 $v+1$、$v-1$。<br>注意递归&#x2F;循环查询的终止条件。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>火箭发动机工作过程中的性能参数</title>
    <link href="/articles/Performance-Parameters-of-Rocket-Engines-During-Operation/"/>
    <url>/articles/Performance-Parameters-of-Rocket-Engines-During-Operation/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="对于整个火箭发动机系统"><a href="#对于整个火箭发动机系统" class="headerlink" title="对于整个火箭发动机系统"></a>对于整个火箭发动机系统</h3><p>下面这个公式适用于多火箭发动机的总参数。</p><p>$$(I_s)_{oa}&#x3D;\frac{\sum F}{\sum \dot\omega}&#x3D;\frac{\sum F}{g_0\sum\dot m}$$</p><p>$$\dot\omega_{oa}&#x3D;\sum\dot\omega\ \text{或}\ \dot m_{oa}&#x3D;\sum\dot m$$</p><p>$$\gamma_{oa}&#x3D;\frac{\sum\dot\omega_0}{\sum\dot\omega_f}&#x3D;\frac{\sum\dot m_0}{\sum\dot m_f}$$</p><p>下标$oa$、$o$和$f$分别表示整个发动机系统、氧化剂和燃料。<br>$\dot\omega$表示流量重力，单位$N&#x2F;s$。<br>$\dot m$表示流量质量，单位$kg&#x2F;s$。<br>$\gamma_{oa}$表示表示整个系统的混合比。</p><hr><h3 id="总冲"><a href="#总冲" class="headerlink" title="总冲"></a>总冲</h3><p>整个燃烧时间$t$内推力$P$的积分，单位$N\cdot s$，即<br>$$I_t&#x3D;\int_0^tPdt$$<br>总冲是火箭发动机的重要性能参数，它包括发动机推力所持续的时间，反应了综合工作能力的大小。</p><hr><h3 id="比冲"><a href="#比冲" class="headerlink" title="比冲"></a>比冲</h3><p>指燃料燃烧$1kg$推进剂所产生的冲量，单位$s$。设$m_p$为推进剂有效总质量，则平均比冲<br>$$I_s&#x3D;\frac{I_t}{m_p}$$<br>对液体火箭发动机而言，比冲的含义是每秒钟消耗$1kg$质量的推进剂所产生的推力大小，即<br>$$I_s&#x3D;\frac{I_t}{\dot m}\ \text{或}\ I_s&#x3D;\frac P{\dot m}$$<br>比冲是火箭发动机的一个重要性能参数，它对运载火箭、航天器性能有较大影响。比冲越高，意味着在消耗相同质量的推进剂时，火箭发动机能够产生更大的推力，或者在产生相同推力的情况下消耗更少的推进剂。高比冲的发动机可以更有效地将火箭送入太空，因为它们能够更有效地转换推进剂的化学能为火箭的动能。</p><hr><h3 id="密度比冲"><a href="#密度比冲" class="headerlink" title="密度比冲"></a>密度比冲</h3><p>定义为单位体积推进剂流量所产生的推力，单位$s\cdot kg&#x2F;m^3$，即<br>$$I_{s,\rho}&#x3D;\frac PV&#x3D;\frac P{\dot m&#x2F;\rho_T}&#x3D;I_s\rho_t$$<br>其中$\rho_T$表示推进剂密度。</p><hr><h3 id="推进剂混合比"><a href="#推进剂混合比" class="headerlink" title="推进剂混合比"></a>推进剂混合比</h3><p>定义为氧化剂流量与燃烧剂流量之比，即<br>$$MR&#x3D;\frac{m_0}{m_f}$$<br>混合比直接影响燃烧室内的化学反应。一个适当的混合比可以确保燃料和氧化剂完全燃烧，从而最大化能量的释放。混合比会影响比冲的大小，一个合适的混合比可以提高比冲，从而提高火箭的有效载荷能力。</p><hr><h3 id="书籍参考"><a href="#书籍参考" class="headerlink" title="书籍参考"></a>书籍参考</h3><p>液体火箭发动机燃烧过程建模与数值仿真&#x2F;王振国编著.—北京：国防工业出版社，2012.10<br>ISBN 978-7-118-08525-9</p><p>I. ①液··· II. ①王··· III. ①液体推进剂火箭发动机—燃烧过程—建立模型②液体推进剂火箭发动机—燃烧过程—数值方法 IV ①V434</p><p>中国版本图书馆CIP数据核字（2012）第279370号</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>液体火箭发动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>研究笔记 24-06-30</title>
    <link href="/articles/Note-24-06-30/"/>
    <url>/articles/Note-24-06-30/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h3><p>研制气氧乙醇液体火箭发动机。</p><hr><h3 id="液体火箭发动机基本结构"><a href="#液体火箭发动机基本结构" class="headerlink" title="液体火箭发动机基本结构"></a>液体火箭发动机基本结构</h3><p>由推力室（由喷注器、燃烧室和喷管构成）、推进剂供应系统、推进剂贮箱和各种自动调节器等部分组成。</p><hr><h3 id="推进剂供应系统"><a href="#推进剂供应系统" class="headerlink" title="推进剂供应系统"></a>推进剂供应系统</h3><ul><li>挤压式供应系统：使用挤压气体的方式输送推进剂，高压储存于气瓶或由燃气发生器生成，通常使用惰性气体。</li><li>泵压式供应系统：通过涡轮驱动泵实现供应，最常见循环方案：燃气发生器循环、膨胀循环和分级燃烧循环。</li><li>电泵循环供应系统：书里面没写，以后需要查。</li></ul><hr><h3 id="推力室"><a href="#推力室" class="headerlink" title="推力室"></a>推力室</h3><h4 id="喷注器"><a href="#喷注器" class="headerlink" title="喷注器"></a>喷注器</h4><p>将推进剂雾化混合。<br>常见的包括直流式喷注器、离心式喷注器和同轴管式喷注器。</p><ul><li>互击式喷注器：燃料与氧化剂相撞，形成液扇，有助于将液体液化并均匀分散。</li><li>自击式喷注器：燃料与燃料相撞，氧化剂与氧化剂相撞。</li><li>三击式喷注器：一组元的一股射流与另一组元的两股射流相撞，适用于氧化剂与燃料流量不同时。</li><li>淋浴头式喷注器：通过紊流和扩散完成混合。</li><li>溅板式喷注器：推进器射流与固体表面相撞完成雾化。</li><li>离心式喷注器：使推进剂在喷嘴中形成漩涡流动，喷入燃烧室后可造成较大角度的锥形喷雾。结构复杂，尺寸较大。</li><li>同轴管式喷注器：内管外有外套管，内管一端位于喷注器面后方。广泛应用于液氧&#x2F;液氢为推进剂的发动机中。液氢沿环形管道进入，液化为气氢，流速高。液氧沿内管进入，流速差发生剪切作用，帮助液氧束破碎为小液滴。</li></ul><p>喷注器由若干个喷嘴组成，它们的结构和性能决定了喷注器的性能，对推进剂在燃烧室内的完全燃烧和稳定燃烧有较大影响。</p><h4 id="燃烧室"><a href="#燃烧室" class="headerlink" title="燃烧室"></a>燃烧室</h4><p>推进剂雾化、混合和燃烧的容腔，前接喷注器，后接喷管。燃烧室形状及容积大小对推进剂的燃烧效率有重要影响。</p><ul><li>球形燃烧室：有较好的承压能力和燃烧稳定性，同体积质量轻受热面积小，但是加工困难。</li><li>环形燃烧室：实际应用很小。</li><li>圆筒形燃烧室：被广泛采用，结构简单、容易制造、经济性好。</li></ul><h4 id="喷管"><a href="#喷管" class="headerlink" title="喷管"></a>喷管</h4><p>高温气体在喷管中膨胀加速，将内能转化为动能。喷管由收敛段、喉段和扩张段三部分组成，分为锥形喷管、钟形喷管、塞式喷管和膨胀偏流喷管。喷管出口气流应与发动机轴线平行。</p><ul><li>锥形喷管：有设计简单、成本低等优点，适合初学者和小型火箭的使用，但效率较低、长度较长。小角度喷管能提供更大的推力，但是会更长更重，而大角度喷管会降低低空性能。</li><li>钟形喷管：也称拉瓦尔喷管，有高效率、设计紧凑等优点，但是制造复杂、成本较高。同时特定的喇叭口形状只能在某一特定高度上达到最佳效果。</li></ul><p>下面这张图给出了特定条件、五种设计下最佳喷嘴的尺寸比较。从左到右、从上到下分别是锥形喷管、钟形喷管、塞式喷管、膨胀偏流喷管、反射流喷管和混合流喷管。(摘自Huzel &amp; Huang, 1967)<br><img src="https://aerospaceweb.org/design/aerospike/figures/fig02.jpg" alt="35-01" style="zoom:75%;" />  </p><hr><h3 id="推力室冷却"><a href="#推力室冷却" class="headerlink" title="推力室冷却"></a>推力室冷却</h3><p>冷却的目的是防止燃烧室和喷管壁面过热造成损坏。<br>冷却方式分为稳态冷却和非稳态冷却两类。稳态冷却意味着释放的热量与吸收的热量会最终达到平衡，而发动机可以持续运行；而非稳态冷却意味着无法达到热平衡，燃烧室壁和喷管壁热量会持续上升。</p><h4 id="再生冷却"><a href="#再生冷却" class="headerlink" title="再生冷却"></a>再生冷却</h4><p>一种稳态冷却技术。一种推进剂组元流入喷注器之前，先流过燃烧室周围的冷却管道。再生一词，说明推进剂吸收热量后再燃烧，释放的热量给后面的推进剂吸收，实现了热量的再利用。<br>这一技术要求有薄的燃烧室内壁，以完成热量交换。</p><p>再生冷却的结构形式一般有下面几种：</p><ul><li>内外壁间形成的光滑缝隙式冷却通道：推进剂再内外壁的狭小缝隙间高速通过，结构简单但对结构强度要求很高。</li><li>内外壁相互连接的冷却通道：内外壁间构建通道，可以构建肋条或波纹板。这样既保证了结构强度，又有冷却效果。</li><li>管束式冷却通道：直接使用紧密排列的细管作为燃烧室壁，通常使用加强箍或承力外套加强推力室结构强度。</li></ul><h4 id="辐射冷却"><a href="#辐射冷却" class="headerlink" title="辐射冷却"></a>辐射冷却</h4><p>一种稳态冷却技术。热量从推力室外表面辐射散失，冷却能力取决于推力室温度及表面情况。广泛用于燃气温度较低的发动机中，要求使用熔点高的金属或合金作推力室壁。</p><h4 id="热沉冷却"><a href="#热沉冷却" class="headerlink" title="热沉冷却"></a>热沉冷却</h4><p>一种非稳态冷却技术。在实验中常用，需要非常厚的推力室壁，且推力室壁材料的吸热能力决定了实验时间。</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><ul><li>烧蚀冷却：一种非稳态冷却技术。推力室壁由烧蚀材料制成，高温下分解带走热量。</li><li>膜冷却：建立气膜，隔绝推进剂与推力室壁，以降低推力室壁温度。</li></ul><hr><h3 id="我的整理"><a href="#我的整理" class="headerlink" title="我的整理"></a>我的整理</h3><h4 id="推进剂选择"><a href="#推进剂选择" class="headerlink" title="推进剂选择"></a>推进剂选择</h4><p>考虑到获取及运输储存安全性等，选用气氧乙醇作推进剂。<br>考虑到燃烧室内壁热承受能力有限，选用$75\%$乙醇作燃料。<br>注：$75\%$是体积分数。</p><h4 id="推进剂配比"><a href="#推进剂配比" class="headerlink" title="推进剂配比"></a>推进剂配比</h4><p>氧气与酒精燃烧方程式：<br>$$C_2H_5OH+3O_2\xlongequal{\text{点燃}}2CO_2\uparrow+3H_2O$$<br>氧化剂&#x2F;燃料比例：</p><!--$$n(O_2):n(C_2H_5OH)=3:1\\m(O_2):m(C_2H_5OH)=16:23$$--><!--$$\rho_{O_2(g)}=1.404\times10^{-3}kg/L,\ \rho_{O_2(l)}=1.143kg/L,\ \rho_{C_2H_5OH}=0.789kg/L$$--><!--$$V_{O_2(l)}:V_{C_2H_5OH}=0.48$$--><p>$$V_{O_2(g)}:V_{C_2H_5OH}&#x3D;390.93$$<br>结论：$521.24$份体积氧气配$1$份体积$75\%$乙醇。</p><h4 id="推进剂供应系统选择"><a href="#推进剂供应系统选择" class="headerlink" title="推进剂供应系统选择"></a>推进剂供应系统选择</h4><p>乙醇的供应使用电泵，气氧通过压差自流，使用阀门控制实现。</p><h4 id="喷注器设计"><a href="#喷注器设计" class="headerlink" title="喷注器设计"></a>喷注器设计</h4><p>目前有互击式喷注器和气液同轴剪切喷嘴两种设计。</p><ul><li>互击式喷注器：中心为氧气喷孔，两侧为乙醇喷孔。乙醇喷孔以一定角度对撞，形成细小的液滴，与中心喷出的氧气混合。</li><li>气液同轴剪切喷嘴：气体和液体喷孔同轴布置，气体喷孔位于外侧，液体喷孔位于内侧。气体和液体在喷注器出口处发生剪切作用，增强混合效果。</li></ul><h4 id="燃烧室选择"><a href="#燃烧室选择" class="headerlink" title="燃烧室选择"></a>燃烧室选择</h4><p>使用技术成熟、造价低廉的圆筒形燃烧室。</p><h4 id="喷管选择"><a href="#喷管选择" class="headerlink" title="喷管选择"></a>喷管选择</h4><p>鉴于时间和资金问题，暂时采用锥形喷管，后面再研制钟形喷管。</p><h4 id="冷却方案选择"><a href="#冷却方案选择" class="headerlink" title="冷却方案选择"></a>冷却方案选择</h4><p>鉴于目前发动机设计和方便后续实验，结合电泵完成技术成熟、实现成本较低的再生冷却技术。</p><hr><h3 id="书籍参考"><a href="#书籍参考" class="headerlink" title="书籍参考"></a>书籍参考</h3><p>液体火箭发动机燃烧过程建模与数值仿真&#x2F;王振国编著.—北京：国防工业出版社，2012.10<br>ISBN 978-7-118-08525-9</p><p>I. ①液··· II. ①王··· III. ①液体推进剂火箭发动机—燃烧过程—建立模型②液体推进剂火箭发动机—燃烧过程—数值方法 IV ①V434</p><p>中国版本图书馆CIP数据核字（2012）第279370号</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>液体火箭发动机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>莫比乌斯反演</title>
    <link href="/articles/Mobius-Inversion/"/>
    <url>/articles/Mobius-Inversion/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h4><p>又称线性筛，可以$O(n)$求$n$以内的素数，详见<a href="https://oi-wiki.org/math/number-theory/sieve/#%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95">OI-Wiki</a>。</p><h4 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h4><p>又称数论函数，指定义域为正整数、陪域为复数的函数，每个算术函数都可视为复数的序列。详见<a href="https://baike.baidu.com/item/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/8555075">百度百科</a>。<br>无特殊声明，本文函数均为算术函数。</p><h4 id="数论分块"><a href="#数论分块" class="headerlink" title="数论分块"></a>数论分块</h4><p>又称整除分块，在预处理出$f$前缀和的条件下，可以$O(\sqrt n)$处理形如$\sum\limits_{i&#x3D;1}^nf(i)g(\lfloor\frac ni\rfloor)$。详见<a href="https://oi-wiki.org/math/number-theory/sqrt-decomposition/">OI-Wiki</a>。</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于某一特定的函数$f(d)$，若有$F(n)&#x3D;\sum\limits_{d|n}f(d)$，其中$n,d\in\mathbb{N_+}$，则一定存在函数$\mu(d)$，使得$f(n)&#x3D;\sum\limits_{n|d}\mu(d)F(\frac dn)$。<br>更通俗地，在因数下，$F(n)$由$f(n)$推得，而借助$\mu(n)$就可以通过$F(n)$反推$f(n)$。</p><p>函数$\mu(n)$被称为<strong>莫比乌斯函数</strong>，而等式$f(n)&#x3D;\sum\limits_{n|d}\mu(d)F(\frac dn)$则被称为<strong>莫比乌斯反演公式</strong>。</p><h4 id="为什么一定存在-f-n-？"><a href="#为什么一定存在-f-n-？" class="headerlink" title="为什么一定存在$f(n)$？"></a>为什么一定存在$f(n)$？</h4><p>感性理解，因为$F(n)$是由若干个$f(n)$相加得到的，所以我们可以有选择地选取$F(n)$，相加或相间得到原函数$F(n)$。</p><h4 id="mu-n-的具体值"><a href="#mu-n-的具体值" class="headerlink" title="$\mu(n)$的具体值"></a>$\mu(n)$的具体值</h4><p>先给出结论：<br>$$\mu(n)&#x3D;\begin{cases}<br>1,\ n&#x3D;1\\<br>(-1)^k,\ n&#x3D;p_1p_2\dots p_k\\<br>0,\ Otherwise<br>\end{cases}$$<br>更通俗的解释：</p><ul><li>如果$n&#x3D;1$，$\mu(n)&#x3D;1$；</li><li>如果$n$是由$k$个不同的质数相乘，$k$奇则$\mu(n)&#x3D;-1$，$k$偶则$\mu(n)&#x3D;1$；</li><li>如果$n$中含平方因子，则$\mu(n)&#x3D;0$。</li></ul><p>性质：<br>$$F(n)&#x3D;\sum_{d|n}\mu(d)&#x3D;[n&#x3D;1]&#x3D;\begin{cases}<br>1,\ n&#x3D;1\\<br>0,\ n\neq1<br>\end{cases}$$</p><h4 id="具体值的枚举验证"><a href="#具体值的枚举验证" class="headerlink" title="具体值的枚举验证"></a>具体值的枚举验证</h4><p>不妨令$f(n)&#x3D;n$，枚举，得：<br>$f(1)&#x3D;1$，$f(2)&#x3D;2$，$f(3)&#x3D;3$，$f(4)&#x3D;4$，$f(5)&#x3D;5$，$f(6)&#x3D;6$，$\dots$；<br>$F(1)&#x3D;1$，$F(2)&#x3D;3$，$F(3)&#x3D;4$，$F(4)&#x3D;7$，$F(5)&#x3D;6$，$F(6)&#x3D;12$，$\dots$；<br>$\mu(1)&#x3D;1$，$\mu(2)&#x3D;-1$，$\mu(3)&#x3D;-1$，$\mu(4)&#x3D;0$，$\mu(5)&#x3D;-1$，$\mu(6)&#x3D;1$，$\dots$；</p><p>$f(1)&#x3D;\mu(1)F(1)&#x3D;1$，$f(2)&#x3D;\mu(1)F(2)+\mu(2)F(1)&#x3D;3-1&#x3D;2$，$f(3)&#x3D;\mu(1)F(3)+\mu(3)F(1)&#x3D;4-1&#x3D;3$，$f(4)&#x3D;\mu(1)F(4)+\mu(2)F(2)+\mu(4)F(1)&#x3D;7-3&#x3D;4$，$f(5)&#x3D;\mu(1)F(5)+\mu(5)F(1)&#x3D;6-1&#x3D;5$，$f(6)&#x3D;\mu(1)F(6)+\mu(2)F(3)+mu(3)F(2)+\mu(6)F(1)&#x3D;12-4-3+1&#x3D;6$，$\dots$；</p><p>通过更换不同的$f(n)$表达式和增加枚举个数，这个结论都是成立的。而且对于每一个不同的$f(n)$，$\mu(d)$的表达式总是相同的。</p><h4 id="具体值的证明"><a href="#具体值的证明" class="headerlink" title="具体值的证明"></a>具体值的证明</h4><p>充分性证明：<br>$$\begin{gather}<br>F(n)&#x3D;\sum_{d|n}f(d)&#x3D;\sum_{d|n}f(\frac dn)\\<br>\sum_{d|n}\mu(d)F(\frac nd)&#x3D;\sum_{d|n}\mu(d)\sum_{d_1|\frac nd}f(d_1)\\<br>\sum_{d|n}\sum_{d_1|\frac nd}\mu(d)f(d_1)\\<br>\sum_{d_1|n}\sum_{d|\frac n{d_1}}\mu(d)f(d_1)&#x3D;\sum_{d_1|n}f(d_1)\sum_{d|\frac n{d_1}}\mu(d)&#x3D;f(n)\\<br>\because\sum_{d|\frac n{d_1}}&#x3D;\begin{cases}1,\ d_1&#x3D;1\\0,\ d_1&lt;n\end{cases}\\<br>\therefore f(n)&#x3D;\sum_{d|n}\mu(d)F(\frac nd)&#x3D;\sum_{d|n}\mu(\frac nd)F(d)\\<br>\end{gather}$$<br>必要性证明：<br>$$\begin{gather}<br>f(n)&#x3D;\sum_{d|n}\mu(d)F(\frac nd)&#x3D;\sum_{d|n}\mu(\frac nd)F(d)\\<br>\begin{aligned}<br>\sum_{d|n}F(d)&amp;&#x3D;\sum_{d|n}f(\frac nd)\\<br>&amp;&#x3D;\sum_{d|n}\sum_{d_1|\frac nd}\mu(\frac n{dd_1})F(d_1)\\<br>&amp;&#x3D;\sum_{dd_1|n}\mu(\frac n{dd_1})F(d_1)\\<br>&amp;&#x3D;\sum_{d_1|n}F(d_1)\sum_{d|\frac nd}\mu(\frac n{dd_1})\\<br>&amp;&#x3D;F(n)<br>\end{aligned}\\<br>\because\sum_{d|\frac n{d_1}}\mu(\frac n{dd_1})&#x3D;\sum_{d|\frac n{d_1}}\mu(d)&#x3D;\begin{cases}1,\ d_1&#x3D;1\\0,\ d_1&lt;n\end{cases}\\<br>\therefore F(n)&#x3D;\sum_{d|n}f(d)&#x3D;\sum_{d|n}f(\frac nd)<br>\end{gather}$$</p><hr><h3 id="手推莫比乌斯函数"><a href="#手推莫比乌斯函数" class="headerlink" title="手推莫比乌斯函数"></a>手推莫比乌斯函数</h3><p>根据定义和一个数$n$，我们可以通过分解质因数来手动求$\mu(n)$，只需要判断质因子数量和指数即可。</p><p>示例：<br>$\mu(1)&#x3D;1$；<br>$6&#x3D;2^1\times3^1,\ \mu(6)&#x3D;1$；<br>$30&#x3D;2^1\times3^1\times5^1,\ \mu(30)&#x3D;-1$；<br>$12&#x3D;2^2\times3^1,\ \mu(12)&#x3D;0$；<br>$\dots$</p><hr><h3 id="欧拉筛求莫比乌斯函数"><a href="#欧拉筛求莫比乌斯函数" class="headerlink" title="欧拉筛求莫比乌斯函数"></a>欧拉筛求莫比乌斯函数</h3><p>考虑将上述过程转移到计算机上，就是暴力分解质因数之后判断质因子。<br>优化一下，可以在筛质数的过程中顺便处理莫比乌斯函数。</p><p>具体地，可以参考如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> n, cnt, prime[N], vis[N], mu[N];<br><span class="hljs-comment">// in function main():</span><br>vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, mu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) prime[++cnt]=i, mu[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=cnt&amp;&amp;i*prime[j]&lt;=n; ++j) &#123;<br>vis[i*prime[j]]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i%prime[j]==<span class="hljs-number">0</span>) &#123;mu[i*prime[j]]=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;&#125;<br><span class="hljs-keyword">else</span> mu[i*prime[j]]=-mu[i];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行原理：</p><ul><li>$\mu(p)&#x3D;-1$；</li><li>$\mu(x\times k)&#x3D;0,\ k|x$；</li><li>$\mu(x\times k)&#x3D;-\mu(x),\ x\ mod\ k\neq0$。</li></ul><hr><h3 id="重要式子"><a href="#重要式子" class="headerlink" title="重要式子"></a>重要式子</h3><p>由性质$F(n)&#x3D;\sum\limits_{d|n}\mu(d)&#x3D;[n&#x3D;1]$，易得：<br>$$[\gcd(i,j)&#x3D;1]&#x3D;\sum_{d|gcd(i,j)}\mu(d)$$<br>变形，得：<br>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;1]&#x3D;\sum_{d&#x3D;1}^{\min(n,m)}\mu(d)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$$<br>再变形，得：<br>$$\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m[gcd(i,j)&#x3D;k]&#x3D;\sum_{i&#x3D;1}^{\lfloor\frac nk\rfloor}\sum_{j&#x3D;1}^{\lfloor\frac mk\rfloor}[gcd(i,j)&#x3D;1]&#x3D;\sum_{d&#x3D;1}^{\min(\lfloor\frac nk\rfloor,\lfloor\frac mk\rfloor)}\mu(d)\lfloor\frac {\lfloor\frac nk\rfloor}d\rfloor\lfloor\frac {\lfloor\frac mk\rfloor}d\rfloor$$<br>然后你可以发现这两个东西都可以使用整除分块求解。</p><hr><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><p>给定$n$、$m$和$k$，求满足条件$1\le i\le n$，$1\le j\le m$，$\gcd(i,j)&#x3D;k$的个数。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>莫比乌斯反演板子题，公式推导参照重要式子(3)，加上整除分块优化。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/162616994">AC</a> 2.32s 2.28MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 50010</span><br>ll T, n, m, k, cnt, ans;<br>ll prime[N], vis[N], mu[N], sum[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>T=<span class="hljs-built_in">read</span>(), vis[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>, mu[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">2</span>; i&lt;N; ++i) &#123;<br><span class="hljs-keyword">if</span> (!vis[i]) prime[++cnt]=i, mu[i]=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (ll j=<span class="hljs-number">1</span>; j&lt;=cnt&amp;&amp;i*prime[j]&lt;N; ++j) &#123;<br>vis[i*prime[j]]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i%prime[j]==<span class="hljs-number">0</span>) &#123;mu[i*prime[j]]=<span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>;&#125;<br>mu[i*prime[j]]=-mu[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;N; ++i) sum[i]=sum[i<span class="hljs-number">-1</span>]+mu[i];<br><span class="hljs-keyword">while</span> (T--) &#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), k=<span class="hljs-built_in">read</span>(), n/=k, m/=k, ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (ll l=<span class="hljs-number">1</span>, r; l&lt;=<span class="hljs-built_in">min</span>(n, m); l=r+<span class="hljs-number">1</span>) &#123;<br>r=<span class="hljs-built_in">min</span>(n/(n/l), m/(m/l));<br>ans+=(sum[r]-sum[l<span class="hljs-number">-1</span>])*(n/l)*(m/l);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="积函数反演"><a href="#积函数反演" class="headerlink" title="积函数反演"></a>积函数反演</h3><p>对于某一特定的函数$f(d)$，若有$F(n)&#x3D;\prod\limits_{d|n}f(d)$，其中$n,d\in\mathbb{N_+}$，则一定存在函数$\mu(d)$，使得$f(n)&#x3D;\prod\limits_{n|d}F(\frac dn)^{\mu(d)}$。<br>此处的$\mu(d)$就是莫比乌斯函数，也就是说，莫比乌斯函数不止可以完成和函数反演，也可以完成积函数反演，只需要“积化幂”即可。</p><hr><h3 id="莫反做题方法"><a href="#莫反做题方法" class="headerlink" title="莫反做题方法"></a>莫反做题方法</h3><h4 id="一、基本公式"><a href="#一、基本公式" class="headerlink" title="一、基本公式"></a>一、基本公式</h4><p>$[k&#x3D;1]&#x3D;\sum\limits_{d|k}\mu(d)$，一切问题往这里靠。</p><h4 id="二、变形"><a href="#二、变形" class="headerlink" title="二、变形"></a>二、变形</h4><p>$[n&#x3D;k]&#x3D;[\frac nk&#x3D;1]&#x3D;\sum\limits_{d|\frac nk}\mu(d)$</p><h4 id="三、改变求和顺序"><a href="#三、改变求和顺序" class="headerlink" title="三、改变求和顺序"></a>三、改变求和顺序</h4><p>$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m[gcd(i,j)&#x3D;1]&#x3D;\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^m\sum\limits_{d|gcd(i,j)}\mu(d)&#x3D;\sum\limits_{d&#x3D;1}^{\min(n,m)}\mu(d)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$</p><p>思路：$d|\gcd(i,j)\Leftrightarrow d|i\ \&amp;\&amp;\ d|j$，将$d\Leftarrow i,j$转化为$d\Rightarrow i,j$。</p><p>原理：因为$d|gcd(i,j)$，令$i&#x3D;k_1d\le n$，$j&#x3D;k_2d\le m$，考虑哪些$i,j$对答案做了贡献。<br>显然，所有的整数$k_1,k_2\le \min(n,m)$都会对答案做贡献。而对于一个确定的$d$，其对应的$k_1,k_2$数量为$\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$个，对应的$\mu(d)$值也是相同的，故单个$d$对答案的贡献为$\mu(d)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$。<br>再考虑$d$的数量，因为$d|gcd(i,j),\ i\le n,\ j\le m$，$d$的范围可能是$1\sim\min(n,m)$之内的任意整数。枚举$d$进行求和即可。</p><p>这样我们就完成了改变求和顺序，时间复杂度$O(n^2\log n)\rightarrow O(n)$。其他题目大多也有类似解题思路。</p><h4 id="四、预处理"><a href="#四、预处理" class="headerlink" title="四、预处理"></a>四、预处理</h4><p>因公式过于复杂，我们设$n&#x3D;\min(n,m)$。<br>$\sum\limits_{p&#x3D;1}^n[p\ prime]\sum\limits_{i&#x3D;1}^{\lfloor\frac np\rfloor}\sum\limits_{j&#x3D;1}^{\lfloor\frac mp\rfloor}[gcd(i,j)&#x3D;1]&#x3D;\sum\limits_{p&#x3D;1}^n[p\ prime]\sum\limits_{d&#x3D;1}^{\lfloor\frac np\rfloor}\mu(d)\lfloor\frac n{d\cdot p}\rfloor\lfloor\frac m{d\cdot p}\rfloor$</p><p>令$d\cdot p&#x3D;T$，后面的一坨（第二个$\Sigma$）就可以预处理。<br>$\dots&#x3D;\sum\limits_{T&#x3D;1}^n\mu(d)\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor\sum\limits_{p|T}\mu(\frac Tp)[p\ prime]$<br>这样时间复杂度$O(n)\rightarrow O(\sqrt n)$。</p><h4 id="五、整除分块"><a href="#五、整除分块" class="headerlink" title="五、整除分块"></a>五、整除分块</h4><p>数论中很多都是$\lfloor\frac nd\rfloor$求和，只有$\sqrt n$个取值，因此可以优化时间复杂度。<br>例如：对于$\sum\limits_{d&#x3D;1}^n\mu(d){\lfloor\frac nd\rfloor}^2$，只需求出$\mu(d)$前缀和，再判断$\frac nd$何时取整，即可使用整除分块优化时间复杂度$O(n)\rightarrow O(\sqrt n)$。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>带权并查集</title>
    <link href="/articles/Union-Find-with-Weights/"/>
    <url>/articles/Union-Find-with-Weights/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>一个维护元素所属集合的数据结构，基本操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fa[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) fa[i]=i;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> fa[x]==x?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">chk</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);&#125;<br></code></pre></td></tr></table></figure><h4 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h4><p>详见<a href="https://oi-wiki.org/basic/divide-and-conquer/#%E9%80%92%E5%BD%92">OI-Wiki</a>。</p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>如果你将<code>merge</code>函数单独写，并且RE了，不妨检查一下你的<code>merge</code>函数返回类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);&#125; <span class="hljs-comment">// 你可能写成了这样</span><br></code></pre></td></tr></table></figure><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>在对并查集进行路径压缩和合并操作时，这些权值具有一定属性，即可将他们与父节点的关系，变化为与所在树的根结点关系。<br>在并查集的边上定义某种权值、以及这种权值在路径压缩时产生的运算，从而解决更多的问题，这种算法叫带权并查集。</p><hr><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>以最普遍的维护到父节点距离为例。<br>合并操作一般不以函数形式独立呈现，而是在主函数内。这里为了展示方便，独立写成了<code>merge()</code>函数。</p><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>原理如图，<code>x</code>断开与<code>t</code>的联系，直接连到祖先根节点。<br><img src="../../img/34-01.jpg" alt="34-01" style="zoom:75%;" />  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (fa[x]!=x) &#123;<span class="hljs-type">int</span> t=fa[x]; fa[x]=<span class="hljs-built_in">find</span>(fa[x]), d[x]+=d[t];&#125;<br><span class="hljs-keyword">return</span> fa[x];<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在原先路径压缩的基础上，添加了对$d$数组的维护操作。即在路径压缩时，将到父节点的距离额外加上父节点到父父节点的距离，递归后即可直接得到当前节点到根节点的距离。<br>注意：一定要先记录<code>t</code>，完成对父节点的路径压缩后，再处理<code>x</code>，三个顺序不可颠倒。</p><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>原理如图，合并后<code>fx</code>断开与<code>fa[fx]</code>的连接，直接连接<code>fy</code>。路径压缩可由处理前的<code>find()</code>完成。<br><img src="../../img/34-02.jpg" alt="34-02" style="zoom:75%;" />  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br><span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x), fy=<span class="hljs-built_in">find</span>(y);<br>d[fx]=d[y]+z-d[x], fa[fx]=fy;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在原先合并的基础上，添加了对$d$数组的维护操作。即在合并时，将$X$父节点的距离替换为到$Y$父节点的距离。</p><h4 id="判断合法性"><a href="#判断合法性" class="headerlink" title="判断合法性"></a>判断合法性</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x=<span class="hljs-built_in">read</span>(), y=<span class="hljs-built_in">read</span>(), c=<span class="hljs-built_in">read</span>(), fx=<span class="hljs-built_in">find</span>(x), fy=<span class="hljs-built_in">find</span>(y);<br><span class="hljs-keyword">if</span> (fx==fy) &#123;<br><span class="hljs-keyword">if</span>(d[x]-d[y]!=c) &#123;++cnt; <span class="hljs-keyword">continue</span>;&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-built_in">merge</span>(x, y, c);<br></code></pre></td></tr></table></figure><p>判断已推导出的$x$与$y$的距离是否等于$c$。这里<code>fx==fy</code>意味着它们在同一集合内，可以判断关系；而<code>d[x]-d[y]</code>表示到父节点的距离差，即为两点距离差。<br>注意，如果查询不保证类似左小右大的关系，<strong>取绝对值</strong>后再判断。</p><hr><h3 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h3><p><a href="https://www.luogu.com.cn/problem/P2024">洛谷P2024</a> [NOI2001] 食物链</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>$A$吃$B$，$B$吃$C$，$C$吃$A$。<br>现有$N$个动物，以$1 \sim N$编号。每个动物都是$A,B,C$中的一种。<br>给定两种关系：<code>1 X Y</code>表示$X$与$Y$是同类，<code>2 X Y</code>表示$X$吃$Y$。<br>一共有$K$条描述关系的话，有的是真的，有的是假的。与前面冲突或不符合逻辑的是假话。输出假话的总数。</p><p>数据范围：$1\le N\le5\times10^4$，$1\le k\le1\times10^5$。</p><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>扩展域并查集，开三倍空间，维护三个并查集。<br>设$x$为自身，$x+n$为猎物，$x+2n$为天敌。<br>对于$1$操作，如果$X$与$Y$互为猎物-天敌关系，则是假话；否则合并三组并查集，共享猎物与天敌。<br>对于$2$操作，如果$X$与$Y$是同类，则是假话；否则合并三组并查集，建立猎物-天敌关系。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000010</span><br><span class="hljs-type">int</span> n, m, opt, t1, t2, ans, fa[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> x==fa[x]?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]);&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;fa[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;b.in&quot;, &quot;r&quot;, stdin);</span><br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n*<span class="hljs-number">3</span>; ++i) fa[i]=i;<br><span class="hljs-keyword">while</span> (m--) &#123;<br>opt=<span class="hljs-built_in">read</span>(), t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">if</span> (t1&gt;n||t2&gt;n) &#123;++ans; <span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-keyword">if</span> (opt==<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(t1+n)==<span class="hljs-built_in">find</span>(t2)||<span class="hljs-built_in">find</span>(t1)==<span class="hljs-built_in">find</span>(t2+n)) &#123;++ans; <span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-built_in">merge</span>(t1, t2), <span class="hljs-built_in">merge</span>(t1+n, t2+n), <span class="hljs-built_in">merge</span>(t1+n+n, t2+n+n);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt==<span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(t1)==<span class="hljs-built_in">find</span>(t2)||<span class="hljs-built_in">find</span>(t1)==<span class="hljs-built_in">find</span>(t2+n)) &#123;++ans; <span class="hljs-keyword">continue</span>;&#125;<br><span class="hljs-built_in">merge</span>(t1, t2+n+n), <span class="hljs-built_in">merge</span>(t1+n, t2), <span class="hljs-built_in">merge</span>(t1+n+n, t2+n);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>如果$N$很大，或者关系状态很多，不允许开$K$倍空间，这种办法就无效了。</p><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>带权并查集，参照上方，有小变动。<br>令<code>d[x]</code>表示当前节点与父节点的关系。具体的，<code>d[x]=0</code>表示$x$与父节点是同种生物，<code>d[x]=1</code>表示$x$是父节点的食物，<code>d[x]=1</code>表示$x$是父节点的天敌。<br>状态只有三种，转移通过运算与取模实现。<br>路径压缩：<code>d[x]=(d[x]+d[t])%3</code>，其中$t$为$x$原父节点。<br>合并：<code>d[fx]=c+d[y]-d[x]</code>，其中$c$表示$x$与$y$关系。</p><hr><h3 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p><a href="https://www.luogu.com.cn/problem/P2294">洛谷P2294</a> [HNOI2005] 狡猾的商人</p><p>$T$组数据，每组给出序列长度$N$和$M$对数$l_i,\ r_i,\ s_i$，表示区间$[l_i,\ r_i]$的和为$S_i$，判断是否合法。</p><p>数据范围：$T\le100$，$N\le100$，$M\le1000$。</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>将区间和视作到父节点的距离<code>d[i]</code>，即$sum\ fa[i]\sim i-1$。<br>路径压缩：<code>d[x]+=d[t]</code>，其中$t$为$x$原父节点。<br>合并：<code>d[fx]=d[y]+z-d[x], fa[fx]=fy</code>。</p><p>注意这里需要<code>l--</code>。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 5010</span><br><span class="hljs-type">int</span> T, n, m, l, r, v, fr, f2;<br><span class="hljs-type">int</span> fa[N], d[N]; <span class="hljs-type">bool</span> flag;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (fa[x]!=x) &#123;<span class="hljs-type">int</span> t=fa[x]; fa[x]=<span class="hljs-built_in">find</span>(fa[x]), d[x]+=d[t];&#125;<br><span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;d.in&quot;, &quot;r&quot;, stdin);</span><br>T=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span> (T--) &#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;=n; ++i) fa[i]=i, d[i]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (m--) &#123;<br>l=<span class="hljs-built_in">read</span>()<span class="hljs-number">-1</span>, r=<span class="hljs-built_in">read</span>(), v=<span class="hljs-built_in">read</span>(), fr=<span class="hljs-built_in">find</span>(l), f2=<span class="hljs-built_in">find</span>(r);<br><span class="hljs-keyword">if</span> (fr==f2&amp;&amp;d[l]+v!=d[r]) flag=<span class="hljs-number">1</span>;<br>d[f2]=d[l]+v-d[r], fa[f2]=fr;<br>&#125;<br><span class="hljs-built_in">puts</span>(flag?<span class="hljs-string">&quot;false&quot;</span>:<span class="hljs-string">&quot;true&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=3047">HDU 3047</a> Zjnu Stadium<br><a href="https://blog.51cto.com/u_15127607/3619803">Source</a></p><p>$n$个人坐在体育馆里，给出$m$个他们之间的距离<code>A B X</code>，表示$B$的座位比$A$多$X$。求有多少条错误的关系。</p><p>数据范围$N\le5\times10^4$，$M\le1\times10^5$。</p><h4 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h4><p>到父节点的距离<code>d[i]</code>，维护同上。<br>路径压缩：<code>d[x]+=d[t]</code>，其中$t$为$x$原父节点。<br>合并：<code>d[fx]=d[y]+z-d[x], fa[fx]=fy</code>。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 50010</span><br><span class="hljs-type">int</span> n, m, a, fa1, b, fb, c, cnt;<br><span class="hljs-type">int</span> fa[N], d[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (fa[x]!=x) &#123;<span class="hljs-type">int</span> t=fa[x]; fa[x]=<span class="hljs-built_in">find</span>(fa[x]), d[x]+=d[t];&#125;<br><span class="hljs-keyword">return</span> fa[x];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;c.in&quot;, &quot;r&quot;, stdin);</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)!=EOF) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) fa[i]=i, d[i]=<span class="hljs-number">0</span>; cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (m--) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c), fa1=<span class="hljs-built_in">find</span>(a), fb=<span class="hljs-built_in">find</span>(b);<br><span class="hljs-keyword">if</span> (fa1==fb) &#123;<br><span class="hljs-keyword">if</span>(d[b]-d[a]!=c) &#123;++cnt; <span class="hljs-keyword">continue</span>;&#125;<br>&#125; <span class="hljs-keyword">else</span> fa[fb]=fa1, d[fb]=c+d[a]-d[b];<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>统计方案数等计数问题、查询矛盾等逻辑问题可能是用并查集做。<br>考察朴素并查集的概率比较少，大多都是加权并查集或扩展域并查集。</p><p>加权并查集可以维护到父节点的信息，会在路径压缩过程中处理。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CF191A 题解</title>
    <link href="/articles/Solution-of-CF191A/"/>
    <url>/articles/Solution-of-CF191A/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>见之前的文章<a href="../Dynamic-Programming/">动态规划</a>。这个得自己学。</p><h4 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h4><p>一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。详见<a href="https://oi-wiki.org/dp/memo/">OI-Wiki</a>。<br>本题解题思路与该思想有关。</p><hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本蒟蒻通过此题又一次完成了场切蓝题的壮举。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个王朝的规定如下：<br>1.王朝的名字为历代帝王姓名首字母拼接而成；<br>2.本代帝王姓名首字母的第一个字母必须与前代帝王姓名首字母的最后一个字母相同；<br>3.初代帝王姓名首字母的第一个字母必须与末代帝王姓名首字母的最后一个字母相同。</p><p>例如，帝王$ABC$、$CBA$可以构成王朝$ABCCBA$。<br>$ABC$、$ABA$不可以构成王朝，因为不能满足条件$2$。<br>$ABC$、$CBC$不可以构成王朝，因为不能满足条件$3$。</p><p>现在按顺序给出若干帝王，求可能构成的最长朝代的长度是多少。</p><p>数据范围：$1\le n\le5\times10^5$，$1\le|S|\le10$。</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>王朝名称可以按名字分成多部分，并且均满足条件$2$。所以一个大的王朝可以视作两个不完全合格的王朝合并而成。<br>例如，$ABC$、$CBC$、$CAB$、$BBA$构成的王朝$ABCCBCCABBBA$，可视作$ABCCBC$和$CABBBA$合并形成的。</p><p>这样，我们就可以将目前可能存在的王朝碎片化存储，再拼接检查是否合格即可。</p><hr><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>建立数组<code>d[i][j]</code>，表示当前几个帝王，能构成的首字母为$i$，末字母为$j$，王朝片段的最大长度。<br>对于每个新加入的名字，首字母$f$，末尾字母$b$，则有状态转移方程：<br>$$\begin{gather}<br>\text{对于任意的}0\le x\le 26\text{，若}\exists d[x][f]\text{，则}d[x][b]&#x3D;\max(d[j][b],\ d[j][f]+l)\text{；}\\<br>\text{另外，}d[f][b]&#x3D;max(d[f][b],\ l)\text{。}<br>\end{gather}$$<br>第一个的意思是，若存在王朝$A\rightarrow B$及新名字$B\rightarrow C$，则用最大值更新$A\rightarrow C$的答案。<br>第二个的意思是，用新名字$B\rightarrow C$更新王朝片段$B\rightarrow C$。<br>注意，这两个操作不能合并，否则会出现一些问题。</p><p>最后统计答案就是每一个<code>d[x][x]</code>取最大值即可，首位相同的王朝片段才可构成完整王朝。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 500010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 12</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K 30</span><br><span class="hljs-type">int</span> n, ans;<br><span class="hljs-type">char</span> s[M];<br><span class="hljs-type">int</span> f[N], b[N], l[N];<br><span class="hljs-type">int</span> d[K][K];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s), l[i]=<span class="hljs-built_in">strlen</span>(s);<br>f[i]=s[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;a&#x27;</span>, b[i]=s[l[i]<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">26</span>; ++j) &#123;<br><span class="hljs-keyword">if</span> (d[j][f[i]]) d[j][b[i]]=<span class="hljs-built_in">max</span>(d[j][b[i]], d[j][f[i]]+l[i]);<br>&#125;<br>d[f[i]][b[i]]=<span class="hljs-built_in">max</span>(d[f[i]][b[i]], l[i]);<br>ans=<span class="hljs-built_in">max</span>(ans, d[b[i]][b[i]]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题主要考察考生对DP的敏感程度。以$26$个字母设状态，以拼接形式列出状态转移方程。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CCPC山东省大学生程序设计竞赛 个人总结与解题思路整理</title>
    <link href="/articles/SDCPC-Personal-Summary-and-Solution-Approach-Organization/"/>
    <url>/articles/SDCPC-Personal-Summary-and-Solution-Approach-Organization/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="赛前几天"><a href="#赛前几天" class="headerlink" title="赛前几天"></a>赛前几天</h3><h4 id="Abut-Day-20"><a href="#Abut-Day-20" class="headerlink" title="Abut Day -20"></a>Abut Day -20</h4><p>报名，因为太菜主动单调队列了。</p><h4 id="Day-3"><a href="#Day-3" class="headerlink" title="Day -3"></a>Day -3</h4><p>被告知一位队员需要参加考试，ltr队有一个名额。<br>另外整个年纪的信竞都去了，周六下午没课上，只能跟着去。</p><h4 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h4><p>确定比赛场地，了解比赛规则，和往届选手浅谈了一下比赛策略。</p><h4 id="Day-1"><a href="#Day-1" class="headerlink" title="Day -1"></a>Day -1</h4><p>复习网络流，感觉会考到。翻开书，谁知满书上竟只写了两个字：“不会”。</p><h4 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h4><p>和两位大佬队友汇合，试机。<br>测试题最后一题在洛谷上过了，但是现场评测机过不了，不得其解。<br>那天很累，晚上六点半就睡了。</p><hr><h3 id="队伍成员"><a href="#队伍成员" class="headerlink" title="队伍成员"></a>队伍成员</h3><p>&gt; 具有丰富CCPC比赛经验的大佬，去年曾组队切掉5题：<br><strong>队长：高一 ltr</strong><br>- 妥妥的信竞大佬，实力最强的一个。<br><strong>队员：高一 wzx</strong><br>- 退竞半年但实力依然强悍，熟练掌握计算几何。</p><p>&gt; 第一次参赛的蒟蒻，只会看代码和造数据，三分之一时间都在打酱油：<br><strong>队员：高零 gtr</strong><br>- 妥妥的信竞蒟蒻，实力最弱的一个。</p><hr><h3 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h3><p>04:00 起床。<br>07:45 到达比赛场地，但记错时间。<br>07:55 换好衣服，跑去打印店打印材料。<br>08:30 坐在位子上等待比赛开始。</p><hr><h3 id="比赛过程中"><a href="#比赛过程中" class="headerlink" title="比赛过程中"></a>比赛过程中</h3><p>我从11:10开始吃的东西，还停不下来。wzx说得对，吃了东西之后脑子转速会降不少。<br>纸、笔、饮料和吃的都不缺，书也派上了一些用场，唯一的问题是我没带身份证（</p><hr><h3 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h3><h4 id="I-左移"><a href="#I-左移" class="headerlink" title="I. 左移"></a>I. 左移</h4><p>我还没看完题两位大佬就写好了，还没造完数据就A了。</p><h4 id="A-打印机"><a href="#A-打印机" class="headerlink" title="A. 打印机"></a>A. 打印机</h4><p>第一次WA了，发现界限开小了，$2\times10^{18}\rightarrow1\times10^{18}$，第二次过了。</p><h4 id="F-分割序列"><a href="#F-分割序列" class="headerlink" title="F. 分割序列"></a>F. 分割序列</h4><p>非常顺利地一遍过。</p><h4 id="C-多彩的线段-2"><a href="#C-多彩的线段-2" class="headerlink" title="C. 多彩的线段 2"></a>C. 多彩的线段 2</h4><p>先是按右端点排序，结果WA$\times2$，调试无果，暂时停下。<br>做完K之后用左端点排序+优先队列，过了。</p><h4 id="K-矩阵"><a href="#K-矩阵" class="headerlink" title="K. 矩阵"></a>K. 矩阵</h4><p>ltr和我各给出一个构造，使用了ltr的，成圈排，过了。</p><h4 id="J-多彩的生成树"><a href="#J-多彩的生成树" class="headerlink" title="J. 多彩的生成树"></a>J. 多彩的生成树</h4><p>我一开始读错题了，误以为同种颜色之间连接不需要代价（<br>想了一阵，一遍过了。</p><h4 id="D-王国英雄"><a href="#D-王国英雄" class="headerlink" title="D. 王国英雄"></a>D. 王国英雄</h4><p>最曲折的一道题。<br>一开始我误以为拿初始的钱倒卖就行了，但是看了一眼榜发现没这么简单，于是认真读题（<br>我们写出了暴力代码，测试各种极端条件都过了，于是自信地交了上去，结果TLE。<br>于是开始分析时间复杂度，确定为$O(\sqrt n)$，构造各种极端样例和随机样例，分析卡死循环的条件……百试无果。<br>最后wzx给出除法加速循环的优化，过了样例，但是WA。改了条件，过了样例，但是TLE。<br>然后继续分析时间复杂度，确定为$O(\sqrt n)$，构造各种极端样例和随机样例，分析卡死循环的条件……百试无果。</p><p>看着代码，绞尽脑汁思考着能卡住的样例，我的手上全是汗，眼里尽是绝望，吃饭的心都有了。<br>wzx一直对我们说“稳住，稳住……”，自己冷静地分析代码的漏洞。终于在剩余10分钟时，他发现了问题：<code>pp</code>这个变量是除法中的分母的一部分，在特定条件下会很小，导致除法无法加速循环，导致超时。<br>改正，提交。第8发，293分钟，AC。</p><h4 id="H-阻止城堡"><a href="#H-阻止城堡" class="headerlink" title="H. 阻止城堡"></a>H. 阻止城堡</h4><p>这道题ltr想出来了二分图最大匹配的正解，但是剩下7分钟没时间写了。</p><h4 id="M-回文多边形"><a href="#M-回文多边形" class="headerlink" title="M. 回文多边形"></a>M. 回文多边形</h4><p>wzx整理了一晚上的计算几何，但是他看了许久也不会做，有点可惜。</p><hr><h3 id="比赛后"><a href="#比赛后" class="headerlink" title="比赛后"></a>比赛后</h3><p>赞助商宣讲好无聊，但是有吃的喝的也听得津津有味。<br>滚榜好无聊，但是有了主持人和有趣的队名也看得津津有味。<br>最后队名牌子和气球都带了回来。</p><hr><h3 id="试题解题思路"><a href="#试题解题思路" class="headerlink" title="试题解题思路"></a>试题解题思路</h3><p>不想详细看的请前往<a href="https://www.luogu.com.cn/paste/vjs8f0c5">剪贴板</a>，这里是现场简单记录的。<br>以下的题解来自<a href="https://sua.ac/">SUA程序设计竞赛命题组</a><strong>现场讲解的PPT</strong>中，最简单的几道题没记。详细题解SUA在几天后会更新到<a href="https://sua.ac/wiki/">这里</a>。</p><h4 id="前面的题"><a href="#前面的题" class="headerlink" title="前面的题"></a>前面的题</h4><p>比较简单，所以没转录。</p><h4 id="A-打印机-1"><a href="#A-打印机-1" class="headerlink" title="A. 打印机"></a>A. 打印机</h4><p>二分答案$x$，计算每台打印机在$x$秒内能打印多少试题，看加起来是否大于等于$k$。<br>最差情况下，$k&#x3D;t_i&#x3D;w_i&#x3D;1\times10^9$，$l_i&#x3D;1$，所以二分上界是$2\times10^{18}$。<br>然而$x&#x3D;2\times10^{18}$时，如果打印机每$1$秒打印一份题，$n&#x3D;100$台打印机一共可以打印$2\times10^{20}$份，超出了<code>long long</code>的上界。所以二分过程需要判断和已经大于$k$时提前返回$true$。<br>复杂度$O(n\log x)$。</p><h4 id="F-分割序列-1"><a href="#F-分割序列-1" class="headerlink" title="F. 分割序列"></a>F. 分割序列</h4><p>设最后$m$段元素的总和为$p_m$，其中$p_k&#x3D;\sum a_i$，则目标式可以改写为$\sum^k_{i&#x3D;1}p_i$。<br>所以答案就是从$(n-1)$个后缀里，选最大的$(k-1)$个加起来，再加上序列的和。预处理后缀和并排序即可。复杂度$O(n\log n)$。</p><h4 id="C-多彩的线段-2-1"><a href="#C-多彩的线段-2-1" class="headerlink" title="C. 多彩的线段 2"></a>C. 多彩的线段 2</h4><p>（说实话我觉得讲得太复杂了）</p><p>首先考虑$k$最小是几，答案才能大于$0$。<br>这就是经典的interval partitioning问题：最少把区间分成几组，才能让组内区间不相交。<br>贪心解法是：所有区间按左端点从小到大排序，维护每一组的右端点$g_j$。若存在一组右端点小于当前区间的左端点$l_i$，则将当前区间分入那一组（如果多组满足要求，随便选一组都可以）；否则新开一组。</p><p>从这个思路出发，如果我们把$g_j&lt;l_i$的组都看成$g_j&#x3D;0$可以发现，无论把区间分到哪一组，排序后的$g$序列都是一样的。因为我们把所有区间按左端点排序了，所以$g_j&#x3D;0$将一直保持，直到有个区间分到了那一组里。所以答案就是每次$g_j&#x3D;0$的数量乘起来。<br>因为$k$很大，所以用一个堆只维护$g_j\neq0$的值即可。复杂度$O(n\log n)$。</p><p>如果从弦图的角度解释，本题其实就是弦图的色多项式$P_G(X)&#x3D;\prod^n_{i&#x3D;1}(x-d_{G_i}(v_i))$。详见《弦图与区间图》(陈丹琦) 定理2.5。</p><h4 id="J-多彩的生成树-1"><a href="#J-多彩的生成树-1" class="headerlink" title="J. 多彩的生成树"></a>J. 多彩的生成树</h4><p>对每种颜色需要维护：这个颜色的所有点是否在同一连通块内，以及颜色之间的并查集。<br>模仿Kruskal算法的过程，按边权从小到大考虑每对颜色$(u,\ v)$的连边，并分类讨论。</p><p>情况一：$u&#x3D;v$<br>若颜色$u$所有点都已在同一连通块内则跳过。<br>否则连$(a_u-1)$条边，标记这个颜色所有点都在同一连通块内。</p><p>情况二：$u\neq v$<br>若颜色$u$和$v$在同一连通块内则跳过。<br>否则若$u$和$v$所有点都不在同一连通块内，连$(a_u+a_v-1)$条边。<br>否则若$u$所有点都不在同一连通块内，连$(a_u-1)$条边。$v$同理。<br>否则连$1$条边即可。<br>连边结束后，标记$u$和$v$的所有点在同一连通块内，并连接颜色的并查集。</p><h4 id="D-王国英雄-1"><a href="#D-王国英雄-1" class="headerlink" title="D. 王国英雄"></a>D. 王国英雄</h4><p>每次交易额外花费$(b+d)$秒，所以在时间足够的前提下，每次交易一定尽可能多花钱买入商品，以减少交易的次数。</p><p>注意到如果$\lfloor\frac m p\rfloor$相同，那么每次交易的结果也是相同的。而每次交易后$m$在不断增加，因此可以通过除法$O(1)$地把$\lfloor\frac m p\rfloor$相同的交易合起来处理。设一共需要处理$k$种交易。<br>由于买卖一件物品至少需要花费$2$秒，$(1+2+\cdots+k)\times2\le t$得出$k\sim O(\sqrt t)$。所以复杂度$O(\sqrt t)$。</p><h4 id="H-阻止城堡-1"><a href="#H-阻止城堡-1" class="headerlink" title="H. 阻止城堡"></a>H. 阻止城堡</h4><p>放一个障碍物最多可以阻止一横一竖两对城堡的攻击，称这种放障碍物的位置为好位置。<br>把处于同一行，且能相互攻击的一对城堡，看成二分图左边的点；同样地，把处于同一列，且可以相互攻击到的一对城堡，看成二分图右边的点。这样所有的好位置就连接了一个二分图左边的点，和一个二分图右边的点。<br>为了最小化额外障碍的数量，我们要选尽可能多的好位置。求这张二分图的最大匹配即可。因为可能是完全二分图，所以直接用匈牙利算法，在$O(n^3)$的复杂度下求最大匹配。<br>添加完二分图对应的好位置之后，剩下的位置最多只能阻止一对城堡互相攻击。这种障碍物直接放在对应城堡的旁边即可。<br>如何维护方案？可以给每一行以及每一列都维护一个<code>set</code>，保存这一行哪些列，或这一列哪些行有城堡或障碍物。这样就能快速将障碍物插入到<code>set</code>里，以及检查某一行或列是否有两座城堡之间有没有障碍物。</p><h4 id="M-回文多边形-1"><a href="#M-回文多边形-1" class="headerlink" title="M. 回文多边形"></a>M. 回文多边形</h4><p>设$f(l,r)$表示从顶点$l$逆时针转到顶点$r$，能构成回文序列的最大凸包面积($a_l&#x3D;a_r$)。有转移方程$f(l,r)&#x3D;\max{f(l’,r’)+S_{\triangle ll’r’}+S_{\triangle lr’r}}$。其中$l’$和$r’$位于$l$和$r$之间，且$a_r&#x3D;a_{r’}$。<br>直接计算这个转移方程的复杂度是$O(n^4)$的。注意到对于每种权值，最优情况下，$f$和$r’$其中之一肯定市这个权值在$(l,r)$开区间内最靠近左&#x2F;右端点的顶点，否则额外选择最两边的顶点，面积能变得更大。<br>因此枚举$f$可以直接确定$r’$，枚举$r’$可以直接确定$f$。复杂度降至$O(n^3)$。</p><h4 id="后面的题"><a href="#后面的题" class="headerlink" title="后面的题"></a>后面的题</h4><p>太难了，所以不想整。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这次收获还挺大的，有了比赛和团队协作的经验，也不像之前那么慌了。<br>下一次争取参与到解题上来，别光造数据啥的。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>维护异或极值</title>
    <link href="/articles/Maintaining-XOR-Extrema/"/>
    <url>/articles/Maintaining-XOR-Extrema/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h4><p>见之前的文章<a href="../../2024/04/08/Trie/">Trie</a>。</p><h4 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h4><p>符号$\oplus$。顾名思义，它是或运算的变形，意为“或且不同”。<br>若前后两值相同则为$0$，反之则为$1$。法则如下：<br>$$<br>\begin{array}{|c|c|c|}<br>\hline\oplus&amp;0&amp;1\\<br>\hline0&amp;0&amp;1\\<br>\hline1&amp;1&amp;0\\<br>\hline\end{array}<br>$$<br>重要性质：$a\oplus b\oplus a&#x3D;b$，即异或两次相当于没异或。</p><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>解决最大异或对问题。</p><hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>利用字典树寻找最大异或。具体地，将数以二进制形式存储到字典树中，这个字典树就叫0-1Trie。<br>查找$n$对应的最大异或数，只需从根节点开始向下贪心查询，第$k$对应二进制从左往右数第$k$位(记为$y$)。对于第$k$层，找与$y$不同的边，转移到对应节点进入下一层，若不存在就跳想通的，直到找到与原数差异最大的数。</p><h4 id="贪心正确性证明"><a href="#贪心正确性证明" class="headerlink" title="贪心正确性证明"></a>贪心正确性证明</h4><p>在数的二进制形式下，数的大小由较高位决定，而贪心是由根节点向下的，所以会确保较高位最大，再贪较低位。</p><h4 id="有解性和不越界证明"><a href="#有解性和不越界证明" class="headerlink" title="有解性和不越界证明"></a>有解性和不越界证明</h4><p>由于建树时建了一个深度为$32$的树，查询也是到第$32$层，所以一定会到达一个终点。</p><h4 id="答案统计"><a href="#答案统计" class="headerlink" title="答案统计"></a>答案统计</h4><p>在每一次成功找到不同节点时将$res$的对应位设为$1$，根据异或运算法则，答案即为$res$。</p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (该位为<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (存在边u-&gt;v且权值为<span class="hljs-number">0</span>) &#123;<br>当前点转移到v，进入下一层。<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>当前点转移到子节点，进入下一层。<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (该位为<span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (存在边u-&gt;v且权值为<span class="hljs-number">1</span>) &#123;<br>当前点转移到v，进入下一层。<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>当前点转移到子节点，进入下一层。<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(ll u, ll rt)</span> </span>&#123; <span class="hljs-comment">// 以rt为根插入数u</span><br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">31</span>; ~i; --i) &#123;<br>ll y=(u&gt;&gt;i)&amp;<span class="hljs-number">1</span>; <span class="hljs-comment">// 当前位</span><br><span class="hljs-keyword">if</span> (!trie[rt][y]) trie[rt][y]=++cnt; <span class="hljs-comment">// 新开点</span><br>rt=trie[rt][y]; <span class="hljs-comment">// 转移</span><br>&#125;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">query</span><span class="hljs-params">(ll u, ll rt)</span> </span>&#123; <span class="hljs-comment">// 以rt为根查找数u的最大异或值</span><br>ll res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">31</span>; ~i; --i) &#123;<br>ll y=(u&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (trie[rt][y^<span class="hljs-number">1</span>]) res+=(<span class="hljs-number">1</span>&lt;&lt;i), rt=trie[rt][y^<span class="hljs-number">1</span>]; <span class="hljs-comment">// 找到，统计答案并转移</span><br><span class="hljs-keyword">else</span> rt=trie[rt][y]; <span class="hljs-comment">// 找不到，转移</span><br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1.注意数组开多大，01-Trie的空间一般要开$N\times32$。<br>2.数字存到树上时需要从高位向低位，从树根到叶子结点对应存储，不要搞反。</p><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P4551">洛谷P4551</a> 最长异或路径</p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>求树上任意两点间简单路径上所有节点的异或和的最大值。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>求根节点到每一个节点的异或值，根据性质$a\oplus b\oplus a&#x3D;b$，可得$a\xrightarrow\oplus b&#x3D;(a\xrightarrow\oplus\text{root})\oplus(\text{root}\xrightarrow\oplus b)$，因为$\text{LCA}\rightarrow\text{root}$这段路径走了两遍，相当于没走。<br>于是，我们只需要$O(n)$预处理每个节点到根节点的异或值，即可$O(1)$求出任意两点间的异或值。</p><p>问题转化为，已知各节点到根节点的异或值，求这些异或值的最大异或值，即最大异或对问题。使用0-1Trie解决。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><a href="https://www.luogu.com.cn/record/159924634">AC</a> 11.77MB 130ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>; <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(ch^<span class="hljs-number">48</span>), ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w e[i].val</span><br><span class="hljs-type">int</span> n, t1, t2, t3;<br><span class="hljs-type">int</span> head[N], tot;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<span class="hljs-type">int</span> to, nxt, val;&#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;e[++tot]=&#123;y, head[x], z&#125;, head[x]=tot;&#125;<br><span class="hljs-type">int</span> trie[N&lt;&lt;<span class="hljs-number">5</span>][<span class="hljs-number">2</span>], d[N], cnt, ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> pre)</span> </span>&#123;<br>d[u]=pre;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (v==fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(v, u, pre^w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> rt)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>; ~i; --i) &#123;<br><span class="hljs-type">int</span> y=(u&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (!trie[rt][y]) trie[rt][y]=++cnt;<br>rt=trie[rt][y];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> rt)</span> </span>&#123;<br><span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">31</span>; ~i; --i) &#123;<br><span class="hljs-type">int</span> y=(u&gt;&gt;i)&amp;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (trie[rt][y^<span class="hljs-number">1</span>]) res+=(<span class="hljs-number">1</span>&lt;&lt;i), rt=trie[rt][y^<span class="hljs-number">1</span>];<br><span class="hljs-keyword">else</span> rt=trie[rt][y];<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i) &#123;<br>t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>(), t3=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add_edge</span>(t1, t2, t3), <span class="hljs-built_in">add_edge</span>(t2, t1, t3);<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-built_in">add</span>(d[i], <span class="hljs-number">0</span>), ans=<span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">query</span>(d[i], <span class="hljs-number">0</span>));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最大异或极值问题需要转化为最大异或对问题，再将这些数按位转化为0-1Trie，树上贪心求解。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络最大流 - 增广路算法</title>
    <link href="/articles/Network-Flow-Algorithm/"/>
    <url>/articles/Network-Flow-Algorithm/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索(DFS)"></a>深度优先搜索(DFS)</h4><p>基于深度的搜索，一搜到底，有回溯。详见<a href="https://oi-wiki.org/search/dfs/">OI-Wiki</a>。</p><h4 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索(BFS)"></a>广度优先搜索(BFS)</h4><p>基于广度的搜索，逐层加深搜索。详见<a href="https://oi-wiki.org/search/bfs/">OI-Wiki</a>。</p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>这部分讲的是增广路算法，预流推进算法还没写。</p><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>在有向图中，给定源点$s$和汇点$t$，图上$s\rightarrow t$能流过的最大流量成为网络的最大流。<br>其中，$u\rightarrow v$的流量$f(u,\ v)$满足$0\le f(u,\ v)\le w(u,\ v)$，即流量必须小于等于边权。</p><p>最大流算法就是求$s\rightarrow t$最大流的过程。</p><hr><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>问题可以通过建模转化为最大流问题。<br>时间复杂度$O(n^2\times m)$，空间复杂度$O(n)$。</p><hr><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="反向边"><a href="#反向边" class="headerlink" title="反向边"></a>反向边</h4><p>记录已使用流量和剩余流量，完成退流操作。</p><p>以下面这张图为例：<br><img src="../../img/29-01.jpg" alt="29-01" style="zoom:100%;" /><br>在最大流下，我们在每条边上作$x&#x2F;y$形式的标记，表示这条边最大流量为$y$，当前流量为$x$：<br><img src="../../img/29-02.jpg" alt="29-02" style="zoom:100%;" /><br>建立反向边，流过去的加在反向边(红色)中，剩余流量在正向边(绿色)中：<br><img src="../../img/29-03.jpg" alt="29-03" style="zoom:100%;" /><br>这样建反向边，既能保留剩下的流量，便于寻找增广路，又能记录流过的方便退流。</p><p>查询反向边是有一个小技巧：从编号$0$开始建边，建完边有立刻建反向边，这样<code>编号^1</code>就是对应的反向边了。注意这样的话<code>head[]</code>数组需要全部设为$-1$，不能是$0$，同时反向边权值为$0$。</p><h4 id="增广路"><a href="#增广路" class="headerlink" title="增广路"></a>增广路</h4><p>一条路径，起点为$s$，终点为$t$，并且经过的各条边上的剩余容量均大于$0$。<br>查询到增广路，意味着$s\rightarrow t$的流还可以更大。</p><hr><h3 id="一般增广路算法"><a href="#一般增广路算法" class="headerlink" title="一般增广路算法"></a>一般增广路算法</h3><p>又称Ford–Fulkerson增广，是最基础最简单的最大流算法。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><p>每一次尝试找一条增广路，找到了就更新最大流。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>步骤：<br>1.DFS找一条增广路，记录路径的最大流$f$；<br>2.在回溯过程中维护剩余容量，将当前边减去$f$，同时反向边加上$f$。<br>3.重复以上步骤，直到不存在增广路。</p><p>由于每次都需要DFS查找增广路，并且一次只能处理一条增广路，效率很低。<br>时间复杂度$O(m\times k)$，其中$k$为增广路个数。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>例题 <a href="https://www.luogu.com.cn/problem/P3376">洛谷P3376</a> 网络最大流模板<br>84分，两个点会TLE。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 210</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 5010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w e[i].val</span><br><span class="hljs-type">int</span> n, m, s, t, t1, t2, t3;<br>ll max_flow;<br><span class="hljs-type">int</span> head[N], tot, vis[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<span class="hljs-type">int</span> to, nxt, val;&#125; e[M&lt;&lt;<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>e[tot]=&#123;y, head[x], z&#125;, head[x]=tot++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> minf)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u==t||minf==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> minf;<br>vis[u]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i!=<span class="hljs-number">-1</span>; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (w==<span class="hljs-number">0</span>||vis[v]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-type">int</span> f=<span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(minf, w));<br><span class="hljs-keyword">if</span> (f&lt;=<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>e[i].val-=f, e[i^<span class="hljs-number">1</span>].val+=f;<br><span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FF</span><span class="hljs-params">()</span> </span>&#123;<br>max_flow=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-type">int</span> f=<span class="hljs-built_in">dfs</span>(s, INF);<br><span class="hljs-keyword">if</span> (f==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>max_flow+=f;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) &#123;<br>t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>(), t3=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add_edge</span>(t1, t2, t3), <span class="hljs-built_in">add_edge</span>(t2, t1, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">FF</span>(), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, max_flow);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="最短增广路算法"><a href="#最短增广路算法" class="headerlink" title="最短增广路算法"></a>最短增广路算法</h3><p>又称Edmonds-Karp增广路算法。</p><h4 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h4><p>使用BFS替换FF算法中的DFS，优化效率。<br>注意到每次BFS都会优先选择距离最小的增广路处理，所以随着次数的递增，残存网络上$s\rightarrow t$的最短路径也在递增。<br>这个算法的迭代次数上限是$O(n\times m)$，详细证明可以参考相关书目，再此不多赘述。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><p>将DFS换成BFS即可，使用<code>pre</code>数组记录路径，集中处理剩余流量。<br>最坏情况下每次迭代需要进行$m$次修改，所以时间复杂度为$O(n\times m^2)$。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>例题 <a href="https://www.luogu.com.cn/problem/P3376">洛谷P3376</a> 网络最大流模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 210</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 5010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w e[i].val</span><br><span class="hljs-type">int</span> n, m, s, t, t1, t2, t3;<br>ll max_flow;<br><span class="hljs-type">int</span> head[N], tot, vis[N], pre[N], flow[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<span class="hljs-type">int</span> to, nxt, val;&#125; e[M&lt;&lt;<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>e[tot]=&#123;y, head[x], z&#125;, head[x]=tot++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(pre));<br>queue&lt;<span class="hljs-type">int</span>&gt; q; q.<span class="hljs-built_in">push</span>(s);<br>vis[s]=<span class="hljs-number">1</span>, flow[s]=INF;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i!=<span class="hljs-number">-1</span>; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (w==<span class="hljs-number">0</span>||vis[v]) <span class="hljs-keyword">continue</span>;<br>flow[v]=<span class="hljs-built_in">min</span>(flow[u], w);<br>vis[v]=<span class="hljs-number">1</span>, pre[v]=i, q.<span class="hljs-built_in">push</span>(v);<br><span class="hljs-keyword">if</span> (v==t) <span class="hljs-keyword">return</span> flow[v];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EK</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> f=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (f=<span class="hljs-built_in">bfs</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u=t, i; u!=s; u=e[i^<span class="hljs-number">1</span>].to) &#123;<br>i=pre[u], e[i].val-=f, e[i^<span class="hljs-number">1</span>].val+=f;<br>&#125;<br>max_flow+=f;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) &#123;<br>t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>(), t3=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add_edge</span>(t1, t2, t3), <span class="hljs-built_in">add_edge</span>(t2, t1, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">EK</span>(), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, max_flow);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="连续最短增广路算法"><a href="#连续最短增广路算法" class="headerlink" title="连续最短增广路算法"></a>连续最短增广路算法</h3><p>又称Dinic算法，是比较优秀也比较常用的最短路算法。</p><h4 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h4><p>注意到EK算法还是一次只能找出一条增广路进行迭代。</p><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><p>不断重复以下步骤，直到不存在增广路：<br>1.在残存网络中BFS求出节点层次，构造分层图；<br>2.在分层图上DFS寻找增广路，回溯更新容量。</p><p>有一个剪枝，就是对于当前节点，上一次搜索和这一次搜索都是遍历所有出边，但是有一些是空的，很浪费时间。<br><img src="../../img/29-04.jpg" alt="29-04" style="zoom:100%;" /><br>于是我们用<code>cur[]</code>替换<code>head[]</code>数组，这样上次从哪里结束的就可以被记录，不需要访问之前迭代空的边了。</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><p>例题 <a href="https://www.luogu.com.cn/problem/P3376">洛谷P3376</a> 网络最大流模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 210</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 5010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3f3f3f3f</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w e[i].val</span><br><span class="hljs-type">int</span> n, m, s, t;<br><span class="hljs-type">int</span> t1, t2, t3;<br>ll max_flow;<br><span class="hljs-type">int</span> head[N], cur[N], tot;<br><span class="hljs-type">int</span> d[N], vis[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br><span class="hljs-type">int</span> to, nxt, val;<br>&#125; e[M&lt;&lt;<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>e[tot]=&#123;y, head[x], z&#125;, head[x]=tot++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(d, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(d));<br>queue&lt;<span class="hljs-type">int</span>&gt; q; q.<span class="hljs-built_in">push</span>(s), d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i!=<span class="hljs-number">-1</span>; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (w==<span class="hljs-number">0</span>||d[v]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>d[v]=d[u]+<span class="hljs-number">1</span>, q.<span class="hljs-built_in">push</span>(v);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> d[t]!=<span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> minf)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (u==t||minf==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> minf;<br><span class="hljs-type">int</span> f, flow=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=cur[u]; i!=<span class="hljs-number">-1</span>; i=e[i].nxt) &#123;<br>cur[u]=i;<br><span class="hljs-keyword">if</span> (d[v]!=d[u]+<span class="hljs-number">1</span>||!(f=<span class="hljs-built_in">dfs</span>(v, <span class="hljs-built_in">min</span>(minf, w)))) <span class="hljs-keyword">continue</span>;<br>minf-=f, flow+=f;<br>e[i].val-=f, e[i^<span class="hljs-number">1</span>].val+=f;<br><span class="hljs-keyword">if</span> (minf==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> flow;<br>&#125;<br><span class="hljs-keyword">return</span> flow;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dinic</span><span class="hljs-params">()</span> </span>&#123;<br>max_flow=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">bfs</span>()) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) cur[i]=head[i];<br>max_flow+=<span class="hljs-built_in">dfs</span>(s, INF);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>(), m=<span class="hljs-built_in">read</span>(), s=<span class="hljs-built_in">read</span>(), t=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) &#123;<br>t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>(), t3=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add_edge</span>(t1, t2, t3), <span class="hljs-built_in">add_edge</span>(t2, t1, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-built_in">Dinic</span>(), <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, max_flow);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h3><p>1.拆点$\rightarrow$控制点流量。例如：<br><img src="../../img/29-05.jpg" alt="29-05" style="zoom:100%;" /><br>2.建立超级源点和超级汇点$\rightarrow$多个源点&#x2F;汇点。</p><hr><h3 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h3><p>贪心算法<br>Dinic中的DFS改成SPFA<br>优先选择一条增广路，费用最小</p><p>费用为距离，跑一遍SPFA，求起点到每一点的<br>总费用&#x3D;费用*流量，可以比较路径距离和</p><p>规定最短路是多少就规定了增广路怎么流<br>SPFA跳过流量为零的边</p><p>最小费用最大流：保证流是最大，满足最大流的前提下，找费用最小的一个增广路。<br>最大流是第一条件，然后是最小费用。</p><p>费用作为权值，求源点到终点的最短路，SPFA<br>d[t]表示源点到终点的费用最短路<br>总费用&#x3D;d[t]*flow，一个流量走完需要d[t]，一共flow。</p><hr><h3 id="P2045-方格取数加强版"><a href="#P2045-方格取数加强版" class="headerlink" title="P2045 方格取数加强版"></a>P2045 方格取数加强版</h3><p>最大费用最大流。</p><p>建立超级源点和超级汇点<br>源-&gt;左上，k。<br>右下-&gt;汇，k。<br>表示可以取k次。</p><p>拆点，对于每个点内的边：<br>可以取到：流量为1，费用为a。<br>不能取到：流量为INF，费用为0。<br>两个边都建。</p><p>取格子，取完了就为0。<br>边与边之间是流量INF，费用0。</p><p>可以求最长路，也可以对费用取反。</p><hr><h3 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h3><p>两个集合$A$、$B$，$n$个点。点$i$被分到集合$A$收益$a[i]$，分到集合$B$收益$b[i]$。<br>如果$u$、$v$两点不在一个集合，额外获得$c[i]$的收益。</p><p>例题 <a href="https://www.luogu.com.cn/problem/P2762">洛谷P2762</a> 太空飞行计划问题<br>有$n$个仪器，$m$个实验，每个实验需要选一些物品。<br>买仪器需要代价，完成实验可以获得报酬。</p><p>仪器与实验间有关系，实验在左，仪器在右。<br>每个实验都和对应仪器连边。<br>实验连到超级源点，边权为报酬。<br>仪器连接到超级汇点，边权为费用。</p><p>把点分为两个集合$S$、$T$，其中$s\in S$，$t\in T$。<br>$S\cap T&#x3D;\emptyset$，且$S\cup T&#x3D;U$。</p><p>割的容量</p><p>$$<br>c(S,\ T)&#x3D;\sum_{i\in S,\ j\in T}c(i,\ j)<br>$$</p><p>跨过两个集合的边的权值的和就是割的容量，对于所有割，割的容量的最小值就是最小割。</p><p>图的最大流量一定是最小割。</p><p>首先不能切中间的边，不是最优。<br>切两边的边就意味着去掉一个实验。</p><p>答案为所有实验的收益减去最小割，求最小割可以用最大流。</p><hr><h3 id="P2762-太空飞行计划问题"><a href="#P2762-太空飞行计划问题" class="headerlink" title="P2762 太空飞行计划问题"></a>P2762 太空飞行计划问题</h3><p>有向图<strong>最大权闭合子图</strong>问题。</p><p>一个点对应所有出边的点都要选，最大化权值和。</p><p>源点s和汇点t，连s或连t。<br>i要连s，就要割掉t。</p><p>最大价值是最大割，转化为最小割解决。</p><p>最大割&#x3D;$-miuncut+\sum_{a_i&gt;0}a[i]$。</p><p>总结：<br>如果这个点是正的，就拿源点连它。负的就连汇点。<br>统计所有大于0的边的和，减去最小割就是答案。</p><p>必须选的边，最小割就设成+inf，不能割。换回来就是-inf。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分图最大匹配问题、最小割问题等都可以转化为网络流问题解决。<br>熟练背过板子，可以帮助我们快速切题。<br>不要忘记初始化<code>head[]</code>为$-1$，反向边的$val$记得初始化为$0$。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>洛谷P1084 题解</title>
    <link href="/articles/Solution-of-P1084/"/>
    <url>/articles/Solution-of-P1084/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="倍增算法"><a href="#倍增算法" class="headerlink" title="倍增算法"></a>倍增算法</h4><p>本题用于倍增跳祖先，检查可行性。详见<a href="https://oi-wiki.org/basic/binary-lifting/">OI-Wiki</a>。</p><h4 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h4><p>满足单调性的答案求解，本题用于二分答案查找最少时间。详见<a href="https://oi-wiki.org/basic/binary/#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88">OI-Wiki</a>。</p><h4 id="树上DFS遍历"><a href="#树上DFS遍历" class="headerlink" title="树上DFS遍历"></a>树上DFS遍历</h4><p>自己学去。</p><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p>本题中用于匹配军队与子树。详见<a href="https://oi-wiki.org/basic/greedy/">OI-Wiki</a>。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>更详细的描述，请前往<a href="https://www.luogu.com.cn/problem/P1084">洛谷</a>查看。</p><p>树上根节点$1$爆发疫情，需要军队前往其它节点（不能是根节点）建立检查站，防止疫情扩散到叶子结点。<br>一支军队只能建立一个检查站，行军时间为边的权值。<br>军队原驻扎节点和树上距离已给出，求控制疫情所需的最小时间，若无法控制输出$-1$。</p><p>数据范围：$2\le m\le n\le5\times10^4$，$0\le w\le1\times10^9$</p><hr><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><h4 id="答案求解"><a href="#答案求解" class="headerlink" title="答案求解"></a>答案求解</h4><p>注意到答案是单调的，即可行的解都连续且在一侧。<br>考虑使用二分答案求解，寻找可行条件下的最小时间。<br>问题转化为二分的<code>check()</code>函数，即对于给定的时长，确定疫情是否能被控制。</p><h4 id="军队移动"><a href="#军队移动" class="headerlink" title="军队移动"></a>军队移动</h4><p>显然，需要控制根节点的疫情，军队应尽可能朝向根节点移动，以最小化检查点数量。</p><p>军队向根节点移动一定是百益而无一害的，因为这是一棵树。<br>军队本来可以隔离的根节点，依旧在军队下方，建立检查点后可以受到隔离。<br>上移过程中，还可能覆盖其它叶子结点，增加隔离范围。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><p>由于时间已给定，可以先让军队向根节点移动，而不前往根节点。</p><p>此时军队有三种：<br>1.距离根节点仅剩一条边，并且剩余时间可以前往根节点。<br>2.距离根节点仅剩一条边，但是剩余时间不能前往根节点。<br>3.连根节点的边都没碰到，还在路上的。<br>对于第一种情况的军队，前往根节点并记录来时的子树。对于后两种情况的军队，在原地建立检查站并打上标记。</p><p>接着对每一棵子树，DFS从根节点自上而下遍历到叶子节点。如果路径上没有驻扎，标记该子树。</p><p>为这些子树分配军队，策略如下：<br>1.优先选择自己子树来的且剩余时间较短的。这些军队实质上相当于上述第二种的军队，临近根节点后原地建立检查站。<br>2.优先选择剩余时间较短的匹配所需时间较长的，以节省军队使用，保证正确性。<br>对于上述两策略，不难发现应先对子树和军队排序，<strong>子树按所需时间降序</strong>，<strong>军队按剩余时间升序</strong>。</p><p>双指针从前向后遍历子树和军队，满足下列条件之一即可匹配：<br>1.军队剩余时间可以到达子树。<br>2.军队从该子树过来的。<br>若匹配成功，换下一棵子树和下一支军队。若匹配失败，则换下一支军队。<br>如果按照上述策略匹配，还有子树没有分配到军队，则证明给定的时长下问题无解，反之则有解。</p><h4 id="答案输出"><a href="#答案输出" class="headerlink" title="答案输出"></a>答案输出</h4><p>分析得，时间大于$5\times10^5$即可认为无解。所以二分左端点$0$，右端点$5\times10^5$。<br>若可行，更新答案为中间端点，右端点左移。若不可行，左端点右移。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><a href="https://www.luogu.com.cn/record/158473671">AC</a> 15.36MB 203ms</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 50010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w e[i].val</span><br><span class="hljs-type">int</span> n, m, la, lb, t1, t2, t3;<br><span class="hljs-type">int</span> head[N], tot;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<span class="hljs-type">int</span> to, nxt, val;&#125; e[N&lt;&lt;<span class="hljs-number">1</span>]; <span class="hljs-comment">// 树边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;e[++tot]=&#123;y, head[x], z&#125;, head[x]=tot;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;ll rst; <span class="hljs-type">int</span> id; <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(node x) &#123;<span class="hljs-keyword">return</span> rst&gt;x.rst;&#125;&#125; a[N], b[N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">18</span>], d[N], vis1[N], vis2[N], rst[N]; <span class="hljs-comment">// ↑军队和子树，记录所在点和时间↑</span><br>ll dis[N][<span class="hljs-number">18</span>], rstmin[N], l, r, mid, ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, ll ra)</span> </span>&#123; <span class="hljs-comment">// 倍增</span><br>f[u][<span class="hljs-number">0</span>]=fa, dis[u][<span class="hljs-number">0</span>]=ra;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">17</span>; ++i) &#123;<br>f[u][i]=f[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 2^k祖先</span><br>dis[u][i]=dis[u][i<span class="hljs-number">-1</span>]+dis[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 到2^k祖先的距离</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (v==fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs1</span>(v, u, w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123; <span class="hljs-comment">// 检查叶子结点是否被隔离</span><br><span class="hljs-type">bool</span> res=<span class="hljs-number">1</span>, flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (vis1[u]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 恰好为检查站</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (v==fa) <span class="hljs-keyword">continue</span>; flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs2</span>(v, u)) <span class="hljs-keyword">continue</span>; res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (u==<span class="hljs-number">1</span>) b[++lb]=&#123;w, v&#125;; <span class="hljs-comment">// 没有隔离的子树，记录编号和所需时间</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> flag&amp;&amp;res; <span class="hljs-comment">// 目前是否可行</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">chk</span><span class="hljs-params">(ll lim)</span> </span>&#123;<br><span class="hljs-type">int</span> cur=<span class="hljs-number">1</span>, u; ll num; la=<span class="hljs-number">0</span>, lb=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(vis1, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis1));<br><span class="hljs-built_in">memset</span>(vis2, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis2));<br><span class="hljs-built_in">memset</span>(rst, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(rst));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) &#123;<br>u=d[i], num=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">17</span>; ~j; --j) <span class="hljs-keyword">if</span> (f[u][j]&gt;<span class="hljs-number">1</span>&amp;&amp;num+dis[u][j]&lt;=lim) num+=dis[u][j], u=f[u][j];<br><span class="hljs-keyword">if</span> (f[u][<span class="hljs-number">0</span>]==<span class="hljs-number">1</span>&amp;&amp;num+dis[u][<span class="hljs-number">0</span>]&lt;=lim) &#123; <span class="hljs-comment">// ←有能力去根节点的军队← ↑不断跳祖先到根节点旁边↑</span><br>a[++la]=&#123;lim-num-dis[u][<span class="hljs-number">0</span>], i&#125;;<br><span class="hljs-keyword">if</span> (!rst[u]||a[la].rst&lt;rstmin[u]) rstmin[u]=a[la].rst, rst[u]=i; <span class="hljs-comment">// 记录最小时间军队</span><br>&#125; <span class="hljs-keyword">else</span> vis1[u]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 建立检查站</span><br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+la+<span class="hljs-number">1</span>), <span class="hljs-built_in">sort</span>(b+<span class="hljs-number">1</span>, b+lb+<span class="hljs-number">1</span>), vis2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 贪心前排序</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=lb; ++i) &#123;<br><span class="hljs-keyword">if</span> (!vis2[rst[b[i].id]]) &#123;vis2[rst[b[i].id]]=<span class="hljs-number">1</span>; <span class="hljs-keyword">continue</span>;&#125; <span class="hljs-comment">// 自己子树来的最小剩余时间军队</span><br><span class="hljs-keyword">while</span> (cur&lt;=la&amp;&amp;(vis2[a[cur].id]||a[cur].rst&lt;b[i].rst)) ++cur;<br><span class="hljs-keyword">if</span> (cur&gt;la) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; vis2[a[cur].id]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 建立检查站</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// freopen(&quot;a.in&quot;, &quot;r&quot;, stdin);</span><br>n=<span class="hljs-built_in">read</span>(), r=(N&lt;&lt;<span class="hljs-number">1</span>)+(N&lt;&lt;<span class="hljs-number">3</span>), ans=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i) &#123;<br>t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>(), t3=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add_edge</span>(t1, t2, t3), <span class="hljs-built_in">add_edge</span>(t2, t1, t3);<br>&#125;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), m=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) d[i]=<span class="hljs-built_in">read</span>(); <span class="hljs-comment">// 军队节点</span><br><span class="hljs-keyword">while</span> (l&lt;=r) mid=l+r&gt;&gt;<span class="hljs-number">1</span>, (<span class="hljs-built_in">chk</span>(mid))?r=mid<span class="hljs-number">-1</span>,ans=mid:l=mid+<span class="hljs-number">1</span>; <span class="hljs-comment">// 二分求解</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans); <span class="hljs-comment">// 这里没有改答案就表示始终不可行，输出-1</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>二分找答案，贪心判断可行性，倍增优化。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>后缀数组</title>
    <link href="/articles/Suffix-Array/"/>
    <url>/articles/Suffix-Array/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>你需要知道<a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E4%B8%B2/1017763">字符串</a>是什么东西。</p><h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>将待排序元素拆分成$k$个关键字，对关键字排序后即可完成对元素的排序。<br>详见<a href="https://oi-wiki.org/basic/radix-sort/">OI-Wiki</a></p><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>后缀排序是指一个字符串的所有后缀按照字典序排序的结果。<br>这个过程涉及到两个数组，$sa$和$rk$，其中$sa[i]$表示字符串的所有后缀按照字典序升序排序后的编号，$rk[i]$表示第$i$个后缀的字典序排名。其中，$sa$称为后缀数组。<br>显然，$sa[rk[i]]&#x3D;rk[sa[i]]&#x3D;i$，因为第$i$个后缀的排名对应的后缀和第$i$个排名的后缀对应的排名一样，都等于原数组编号。</p><p>后缀数组有很多用处，可以解决查找形如$AA$的子串、最小化字典序等问题。</p><hr><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>倍增法时间复杂度$O(n\log n)$，空间复杂度$O(n)$。</p><hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>以串 <code>aabaaaab</code>为例：  </p><table><thead><tr><th align="center">$i$</th><th align="right">后缀</th></tr></thead><tbody><tr><td align="center">$1$</td><td align="right"><code>aabaaaab</code></td></tr><tr><td align="center">$2$</td><td align="right"><code>abaaaab</code></td></tr><tr><td align="center">$3$</td><td align="right"><code>baaaab</code></td></tr><tr><td align="center">$4$</td><td align="right"><code>aaaab</code></td></tr><tr><td align="center">$5$</td><td align="right"><code>aaab</code></td></tr><tr><td align="center">$6$</td><td align="right"><code>aab</code></td></tr><tr><td align="center">$7$</td><td align="right"><code>ab</code></td></tr><tr><td align="center">$8$</td><td align="right"><code>b</code></td></tr></tbody></table><p>后缀排序后：  </p><table><thead><tr><th align="center">$i$</th><th>后缀</th><th align="center">$rk[i]$</th></tr></thead><tbody><tr><td align="center">$4$</td><td><code>aaaab</code></td><td align="center">$1$</td></tr><tr><td align="center">$5$</td><td><code>aaab</code></td><td align="center">$2$</td></tr><tr><td align="center">$6$</td><td><code>aab</code></td><td align="center">$3$</td></tr><tr><td align="center">$1$</td><td><code>aabaaaab</code></td><td align="center">$4$</td></tr><tr><td align="center">$7$</td><td><code>ab</code></td><td align="center">$5$</td></tr><tr><td align="center">$2$</td><td><code>abaaab</code></td><td align="center">$6$</td></tr><tr><td align="center">$8$</td><td><code>b</code></td><td align="center">$7$</td></tr><tr><td align="center">$3$</td><td><code>baaaaab</code></td><td align="center">$8$</td></tr></tbody></table><p>对后缀完成字典序排序，统计后缀的排名。</p><hr><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="O-n-2-log-n-算法"><a href="#O-n-2-log-n-算法" class="headerlink" title="$O(n^2\log n)$算法"></a>$O(n^2\log n)$算法</h4><p>很容易想到，对所有后缀进行 <code>sort()</code>排序。<br>但这样所需时空复杂度巨大，无法支持大数据量。</p><h4 id="O-n-log-2n-算法"><a href="#O-n-log-2n-算法" class="headerlink" title="$O(n\log^2n)$算法"></a>$O(n\log^2n)$算法</h4><p>思路是对每个长度为$2^k$的子串排序，求出$rk$值，这样当$2^k&gt;n$时，每个子串就相当于所有后缀。<br>每一次排序都利用上一次排序的$rk$值，那么长度为$2^k$的字符串就可以用两个长度为$e^{k-1}$的字符串的排名作为关键字表示，利用 <code>sort()</code>进行排序。<br>这个的正确性容易证明，因为在将两个长度为$2^{k-1}$的字符串拼接时，比较字典序会先看前面的串，后看后面的串。按第一、第二关键字排序恰好符合。</p><p>以 <code>aabaaaab</code>为例，倍增过程如下：<br><img src="../../img/27-01.jpg" alt="27-01" style="zoom:75%;" /><br>这样需要倍增$\log n$次，加上排序$O(n\log n)$。</p><h4 id="O-n-log-n-算法"><a href="#O-n-log-n-算法" class="headerlink" title="$O(n\log n)$算法"></a>$O(n\log n)$算法</h4><p>还是倍增的思路，注意到排序有两个关键字，均为排名，值域$1\sim n$，可以使用基数排序。<br>倍增$O(\log n)$，排序$O(n)$，总时间复杂度$O(n\log n)$。</p><h4 id="基于-O-n-log-n-算法的常数优化"><a href="#基于-O-n-log-n-算法的常数优化" class="headerlink" title="基于$O(n\log n)$算法的常数优化"></a>基于$O(n\log n)$算法的常数优化</h4><p>把$rk[id[i]]$存下来，并尝试减少不连续的内存访问，减少内存调度时间。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>例题 <a href="https://www.luogu.com.cn/problem/P3809">洛谷P3809</a> 后缀排序模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000010</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> rk[N], y[N], c[N], sa[N];<br><span class="hljs-type">char</span> s[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s+<span class="hljs-number">1</span>), n=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>), m=<span class="hljs-number">127</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) rk[i]=s[i], ++c[rk[i]];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=m; ++i) c[i]+=c[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n; i&gt;=<span class="hljs-number">1</span>; i--) sa[c[rk[i]]--]=i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>, d=<span class="hljs-number">0</span>; k&lt;=n&amp;&amp;d!=n; k&lt;&lt;=<span class="hljs-number">1</span>, m=d, d=<span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">memset</span>(c, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(c));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n-k+<span class="hljs-number">1</span>; i&lt;=n; ++i) y[++d]=i;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-keyword">if</span> (sa[i]&gt;k) y[++d]=sa[i]-k;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) ++c[rk[i]];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=m; ++i) c[i]+=c[i<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n; i&gt;=<span class="hljs-number">1</span>; --i) sa[c[rk[y[i]]]--]=y[i], y[i]=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">swap</span>(rk, y), d=<span class="hljs-number">1</span>, rk[sa[<span class="hljs-number">1</span>]]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">if</span> (y[sa[i]]!=y[sa[i<span class="hljs-number">-1</span>]]||y[sa[i]+k]!=y[sa[i<span class="hljs-number">-1</span>]+k]) ++d;<br>rk[sa[i]]=d;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, sa[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="最长公共前缀"><a href="#最长公共前缀" class="headerlink" title="最长公共前缀"></a>最长公共前缀</h3><p>定义$height[i]$为相邻两排名后缀的最长公共前缀，即$height[i]&#x3D;LCP(suffix(sa[i]),\ suffix)$。则对于任意满足$rk[j]&lt;rk[k]$的两后缀$j,\ k$，均有</p><p>$$LCP(suffix(j),\ suffix(k))&#x3D;\min^{rk[k]}_{i&#x3D;rk[j]}{height[i]}$$</p><p>这个很好证，因为后缀排序是按照字典序的，所以前缀具有传递性。两后缀的最长公共前缀就是中间相邻的最长公共前缀的最小值。<br>由此，只要求出$height$数组就能求任意前缀的$LCP$。</p><h4 id="O-n-2-算法"><a href="#O-n-2-算法" class="headerlink" title="$O(n^2)$算法"></a>$O(n^2)$算法</h4><p>求$height$数组可以从$1$到$n$比较相邻排名的后缀，单次比较$O(n)$，总时间复杂度$O(n^2)$。</p><h4 id="O-n-算法"><a href="#O-n-算法" class="headerlink" title="$O(n)$算法"></a>$O(n)$算法</h4><p>$height$数组满足性质$height[rk[i]]\ge height[rk[i-1]]-1$，具体证明过程<del>我也没理解</del>。<br>借助这个性质，匹配相邻排名$LCP$时就可以直接借助上一个的$height$从中间开始，不需要从头比较。比较次数常数级别，会快很多，时间复杂度近似$O(n)$。</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> rk[N], sa[N], height[N]; <span class="hljs-comment">// rk和sa已求得</span><br><span class="hljs-type">char</span> s[N]; <span class="hljs-comment">// 初始字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">calheight</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, k=<span class="hljs-number">0</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">if</span> (!rk[i]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (k) --k;<br><span class="hljs-keyword">while</span> (s[i+k]==s[sa[rk[i]<span class="hljs-number">-1</span>]+k]) ++k;<br>height[rk[i]]=k;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>建议你看一下<a href="https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html">这篇论文</a>，讲得比较详细，也有很标准的代码。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AC自动机</title>
    <link href="/articles/Aho-Corasick-Automaton/"/>
    <url>/articles/Aho-Corasick-Automaton/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="DFA"><a href="#DFA" class="headerlink" title="DFA"></a>DFA</h4><p>请看上一篇文章<a href="../Deterministic-Finite-Automaton/">有限状态自动机</a>，或前往<a href="https://oi-wiki.org/string/automaton/">OI-Wiki</a>。</p><h4 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h4><p>请看上上篇文章<a href="../Trie/">Trie</a>，或前往<a href="https://oi-wiki.org/string/trie/">OI-Wiki</a>。</p><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>一个在字符串中查找子串的算法，只能有单一模式串。<br>可以尝试理解<a href="https://www.luogu.com.cn/paste/95m0ojqm">破碎的笔记</a>，或前往<a href="https://oi-wiki.org/string/kmp/">OI-Wiki</a>。</p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>OI-Wiki上的AC自动机讲解得十分全面，还有动图，建议去看一下。</p><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>AC自动机，全称Aho-Corasick Automaton，可用于统计和排序大量的字符串，解决多模式串匹配问题。<br>在文本串$S$中查找模式串$T_1,\ T_2,\ \cdots,\ T_n$各自出现的个数。<br>构造时间复杂度$O(\sum|T_i|)$，匹配时间复杂度最快$O(|S|+N)$，空间复杂度$O(K\times\sum|T_i|)$。其中$N$表示AC自动机节点数，$K$表示字符种类数。</p><hr><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>对空间要求宽，有多模式串和单一文本串，要求线性时间复杂度。</p><hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>通过不断跳转$fail$指针，在字典树上完成对多个模式串的匹配。<br>借助$fail$，AC自动机可以不遗漏任何一个模式串；并且有最小的时间复杂度，不重复读取。<br>跑到标记节点记录编号，最终得到模式串的访问情况。</p><hr><h3 id="最朴素的算法实现"><a href="#最朴素的算法实现" class="headerlink" title="最朴素的算法实现"></a>最朴素的算法实现</h3><p>算法分为构造Trie、构造失配指针和模式匹配三步。</p><h4 id="构造Trie"><a href="#构造Trie" class="headerlink" title="构造Trie"></a>构造Trie</h4><p>这个不必多说，正常的Trie树构造。<br>从根节点向下找，没有就构造新节点。</p><h4 id="构造失配指针"><a href="#构造失配指针" class="headerlink" title="构造失配指针"></a>构造失配指针</h4><p>失配指针是在失配的时候用于跳转的指针，存储当前状态的最长后缀。这样在一个模式串失配时，自动机能立刻跳转到下一个可能匹配上的模式串。</p><h5 id="最长后缀"><a href="#最长后缀" class="headerlink" title="最长后缀"></a>最长后缀</h5><p>举个OI-Wiki上的例子，对于模式串<code>i</code>，<code>he</code>，<code>his</code>，<code>she</code>，<code>hers</code>的$fail$指针构造：<br><img src="https://oi-wiki.org/string/images/ac-automaton4.png" alt="26-01" style="zoom:75%;" /><br>以节点$6$为例：<br><img src="https://oi-wiki.org/string/images/ac-automaton1.png" alt="26-02" style="zoom:75%;" /><br>假设文本串为<code>hishe</code>，在自动机上跑到节点$6$后，下一个字符是<code>h</code>，但字典树上没有连接节点，此时发生失配。<br><code>his</code>有两个非空后缀，按长度排序分别为<code>is</code>和<code>s</code>。从根节点开始，字典树上没有字符串<code>is</code>，但有<code>s</code>，所以自动机沿<code>fail[6]</code>跳转到节点$7$，这里有<code>his</code>的最长后缀<code>s</code>。<br>读入下一个字符<code>h</code>，节点$7$有<code>h</code>的边，继续运行。</p><p>与KMP中的$next$指针类似，$fail$指针也是一个不断跳的过程。<br>跳最长后缀是因为可能匹配上，如果匹配不上还可以再跳最长后缀，避免模式串的遗漏。<br>如果字典树上没有后缀，<code>fail[i]</code>指向根节点$0$，代表这个字符没有再能匹配得上的。</p><h5 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h5><p>对于字典树上的节点$u$构建<code>fail[u]</code>，父节点$p$，边$p\xrightarrow{c}u$，即<code>trie[fail[p]][c]</code>。假设小于$u$的深度的边都已求得。<br>失配指针的构建分为以下几种情况：<br>1.若<code>trie[fail[p]][c]</code>存在，则令<code>fail[u]=trie[fail[p]][c]</code>。表示当字典树有$fail_p\xrightarrow{c}fail_u$结构时，$u$的最长后缀就是父节点$p$的最长后缀加上字符$c$。<br>2.若<code>trie[fail[p]][c]</code>不存在，则按照“1”的方法继续判断<code>trie[fail[fail[p]]]</code>的存在性。<br>3.如果跳到根节点都没有，说明$trie$上的字符串$u$没有树上后缀，失配就得重新开始匹配，<code>fail[u]=根节点</code>。<br>特别地，<code>fail[p]</code>指向根节点与存在<code>trie[fail[p]][c]</code>不矛盾，表示$p$没有最长后缀，而$u$的最长后缀是最后一个字符。</p><p>实际情况中，小于当前节点深度的节点的$fail$并未全部求得，此时需要BFS依次将子节点加入队列求$fail$指针。<br>另外建字典图，避免跳$fail$，直接指向失配节点。<br>这地方我也讲不明白，请前往<a href="https://oi-wiki.org/string/ac-automaton/#%E5%AD%97%E5%85%B8%E6%A0%91%E4%B8%8E%E5%AD%97%E5%85%B8%E5%9B%BE">OI-Wiki</a>自行学习。</p><h4 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h4><p>从文本串最开头、$trie$根节点开始，按照$trie$的边走，走不通就按照$fail$指针跳转。<br>走到被标记的$trie$节点时，<code>++vis</code>，代表一个模式串成功匹配完毕，跳转$fail$继续匹配。<br>这里借助<code>query()</code>函数实现。</p><hr><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>注意到建图时每次都要跳$fail$指针，所以可以统计入读，查询是给<code>ans</code>打标计再使用拓扑排序求出答案。<br>结合代码理解一下。</p><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>例题 <a href="https://www.luogu.com.cn/problem/P5357">洛谷P5357</a> AC自动机模板二次加强版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getstr</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> &amp;len)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> pt=<span class="hljs-number">1</span>; s[pt]; ++pt) s[pt]=<span class="hljs-number">0</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>(); len=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;a&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;z&#x27;</span>) ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;a&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;z&#x27;</span>) s[++len]=ch, ch=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 8000010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> c s[i]-<span class="hljs-string">&#x27;a&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v trie[u].son[i]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Fail trie[u].fail</span><br><span class="hljs-type">int</span> m, len, cnt;<br><span class="hljs-type">int</span> vis[N], rev[N], indeg[N];<br><span class="hljs-type">char</span> s[N];<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">trie_node</span> &#123;<br><span class="hljs-type">int</span> son[<span class="hljs-number">30</span>], fail, exist, ans;<br>&#125; trie[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; ++i) &#123;<br><span class="hljs-keyword">if</span> (!trie[u].son[c]) trie[u].son[c]=++cnt;<br>u=trie[u].son[c];<br>&#125;<br><span class="hljs-keyword">if</span> (!trie[u].exist) trie[u].exist=num;<br>rev[num]=trie[u].exist;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getfail</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">26</span>; ++i) trie[<span class="hljs-number">0</span>].son[i]=<span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>), trie[<span class="hljs-number">1</span>].fail=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">26</span>; ++i) &#123;<br><span class="hljs-keyword">if</span> (!v) &#123;v=trie[Fail].son[i]; <span class="hljs-keyword">continue</span>;&#125;<br>trie[v].fail=trie[Fail].son[i];<br>++indeg[trie[Fail].son[i]];<br>q.<span class="hljs-built_in">push</span>(v);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">topo</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=cnt; ++i) &#123;<br><span class="hljs-keyword">if</span> (!indeg[i]) q.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>vis[trie[u].exist]=trie[u].ans;<br>trie[Fail].ans+=trie[u].ans;<br><span class="hljs-keyword">if</span> (!(--indeg[Fail])) q.<span class="hljs-built_in">push</span>(Fail);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> u=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; ++i) &#123;<br>u=trie[u].son[c], ++trie[u].ans;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>m=<span class="hljs-built_in">read</span>(), cnt=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) <span class="hljs-built_in">getstr</span>(s<span class="hljs-number">-1</span>, len), <span class="hljs-built_in">insert</span>(i);<br><span class="hljs-built_in">getfail</span>(), <span class="hljs-built_in">getstr</span>(s<span class="hljs-number">-1</span>, len), <span class="hljs-built_in">query</span>(), <span class="hljs-built_in">topo</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, vis[rev[i]]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>有限状态自动机</title>
    <link href="/articles/Deterministic-Finite-Automaton/"/>
    <url>/articles/Deterministic-Finite-Automaton/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h4><p>一个设想中的机器，由图灵于1936年提出。<br>详见<a href="https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E6%9C%BA">百度百科</a>。</p><h4 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h4><p>自己学去。</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>自动机是一个对信号序列进行判定的数学模型，也就是给一个状态能自己转移到下一个状态并进行运算的机器。</p><hr><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>$Q$：状态集，表示自动机里的每个状态，即图中的点。<br>$\Sigma$：字符集。<br>$F$：可接受状态集，即结束状态的结点。<br>$q_0$：初始状态。<br>$\delta$：转移函数，$Q\times\Sigma&#x3D;Q’$</p><p>自动机从初始状态按转移函数转化，跑一定次数到答案状态，在可接受状态集内的即为答案。</p><hr><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面是一个判断二进制数奇偶的自动机，其中$Q&#x3D;\lbrace0,\ 1\rbrace$，$\Sigma&#x3D;\lbrace0,\ 1\rbrace$，$F&#x3D;\lbrace0,\ 1\rbrace$，$q_0&#x3D;0$，$\delta&#x3D;\lbrace(0,0,0),\ (0,1,1),\ (1,0,0),\ (1,0,1)\rbrace$。<br><img src="../../img/25-01.jpg" alt="25-01" style="zoom:75%;" /><br>在这个自动机中，读入一个二进制数，按照自动机进行操作，可以通过最终状态判断奇偶。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Trie</title>
    <link href="/articles/Trie/"/>
    <url>/articles/Trie/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h4><p>一种字符串算法，详见<a href="https://oi-wiki.org/string/ac-automaton/">OI-Wiki</a>。</p><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>字典树，又称前缀树，常用于一组字符串中查找指定的字符串。<br>常解决字符串前缀问题，查询一个字符串是否是另一个字符串的前缀。</p><p>字符串由结点在树中的位置决定，一个结点的所有子孙拥有相同的前缀，即该结点对应的字符串。<br>特别地，根节点表示空字符串。</p><p>时间复杂度，$O(N_{sum})$建树，$O(1)$查询；空间复杂度$O(N_{max}\times K)$。<br>其中$N_{sum}$表示字符串总长度，$N_{max}$表示最长字符串长度，$K$表示字符种类数量。</p><hr><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>对空间要求宽，字符种类较少。</p><hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>一棵树，从根节点到每一个被标记节点的路径上的所有点都代表一个字符串。</p><p>举个例子，这四个字符串<code>ab</code> <code>abcd</code> <code>acc</code> <code>tmc</code>在Trie树上可以表示为：<br><img src="../../img/24-01.jpg" alt="24-01" style="zoom:75%;" />  </p><hr><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>插入一个新的字符串，分为三部分：<br>1.顺着树往下找存在的；<br>2.直到不存在，新开点，新建边；<br>3.加到字符串末尾，打标记。</p><p>两个数组，<code>trie[][]</code>和<code>exist[]</code>。<br><code>t=trie[i][j]</code>表示字典树上的边$i\rightarrow t$，权值为$j$，即第$i$个结点连接$k$字符的下一个结点为$t$。<br><code>exist[i]</code>表示以<code>i</code>结点为末尾的字符串个数，统计存在性、不计数时可用<code>bool</code>类型。 </p><p>结合代码理解一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010 <span class="hljs-comment">// 最长字符串长度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K 30 <span class="hljs-comment">// 字符种类</span></span><br><span class="hljs-type">int</span> trie[N][K], exist[N], tot;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span> </span>&#123; <span class="hljs-comment">// 往trie中添加s字符串</span><br><span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(s+<span class="hljs-number">1</span>), p=<span class="hljs-number">0</span>; <span class="hljs-comment">// s的下标从1开始</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=len; ++i) &#123;<br><span class="hljs-keyword">if</span> (!trie[p][s[i]]) trie[p][s[i]]=++tot; <span class="hljs-comment">// 新开一点</span><br>p=trie[p][s[i]];<br>&#125;<br>++exist[p];<br>&#125;<br><br></code></pre></td></tr></table></figure><p>判断一个字符串是否为另一个字符串的前缀，只需要判断每一个被标记的结点是否为叶子结点即可。<br>如果这个字符串是另一个字符串的前缀，则末尾节点不为叶子结点，后面还有边。<br>考虑新开一个数组存储叶子结点信息，<code>notleaf[i]=0</code>表示是叶子结点。<br>前缀问题结合下面例题理解一下。</p><hr><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>题目传送门：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=25&page=show_problem&problem=2347">UVA</a> <a href="https://onlinejudge.org/external/113/p11362.pdf">PDF</a> <a href="https://www.luogu.com.cn/problem/UVA11362">洛谷</a><br>多组测试，对于每组数据，给$n$个字符串，判断其中是否存在一个字符串为另一个字符串前缀的情况。有则输出”NO”，无则输出”YES”。</p><h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> K 15</span><br><span class="hljs-type">int</span> T, n, len, tot;<br><span class="hljs-type">int</span> trie[N][K], exist[N];<br><span class="hljs-type">char</span> s[N], ch;<br><span class="hljs-type">bool</span> notleaf[N], flag;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=len; ++i) &#123;<br><span class="hljs-keyword">if</span> (!trie[p][s[i]]) notleaf[p]=<span class="hljs-number">1</span>, trie[p][s[i]]=++tot;<br>p=trie[p][s[i]];<br>&#125;<br>++exist[p];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>T=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span> (T--) &#123;<br><span class="hljs-built_in">memset</span>(trie, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(trie));<br><span class="hljs-built_in">memset</span>(exist, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(exist));<br><span class="hljs-built_in">memset</span>(notleaf, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(notleaf));<br>tot=<span class="hljs-number">0</span>, flag=<span class="hljs-number">0</span>, n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br>ch=<span class="hljs-built_in">getchar</span>(), len=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (ch!=<span class="hljs-string">&#x27;\n&#x27;</span>) s[++len]=ch-<span class="hljs-string">&#x27;0&#x27;</span>, ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-built_in">insert</span>();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=tot; ++i) &#123;<br><span class="hljs-keyword">if</span> (exist[i]&amp;&amp;notleaf[i]) &#123;flag=<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;&#125;<br>&#125;<br><span class="hljs-built_in">puts</span>((flag)?<span class="hljs-string">&quot;NO&quot;</span>:<span class="hljs-string">&quot;YES&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>老庄定律</title>
    <link href="/articles/Mr-Zhuang-s-Laws-of-Mathematics/"/>
    <url>/articles/Mr-Zhuang-s-Laws-of-Mathematics/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>数学庄老师为了确保学生记牢知识点，做题规范书写，创造了老庄定律。</p><hr><h3 id="老庄三大基本定律"><a href="#老庄三大基本定律" class="headerlink" title="老庄三大基本定律"></a>老庄三大基本定律</h3><p>一、做不对就是不会；<br>二、答案不在脑子里就是不会；<br>三、别人提醒你就是不会。</p><hr><h3 id="老庄定律的重要推论"><a href="#老庄定律的重要推论" class="headerlink" title="老庄定律的重要推论"></a>老庄定律的重要推论</h3><p>一、选择题，不管会不会，蒙对了就是会；<br>二、填空题，写错答案的，就是不会；<br>三、解答题，过程少了，得不到全分的，就是不会。</p>]]></content>
    
    
    <categories>
      
      <category>趣闻</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>洛谷P4178 题解</title>
    <link href="/articles/Solution-of-P4178/"/>
    <url>/articles/Solution-of-P4178/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>无环联通图，有唯一一个前驱。<br>详见<a href="https://oi-wiki.org/graph/tree-basic/">OI-Wiki</a>。</p><h4 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h4><p>一个树上暴力优化算法，时间复杂度$O(n\log n)$。<br>详见<a href="https://oi-wiki.org/graph/tree-divide/#%E7%82%B9%E5%88%86%E6%B2%BB">OI-Wiki</a>，或前往<a href="/2024/03/24/Divide-and-Conquer-on-Trees/">另一篇文章</a>。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>更详细的描述，请前往<a href="https://www.luogu.com.cn/problem/P4178">洛谷</a>查看。</p><p>给定一棵$n$个节点的树，每条边有边权$w$，求出树上两点距离小于等于$k$的点对数量。<br>样例如图所示：<br><img src="../../img/22-01.jpg" alt="22-01" style="zoom:75%;" /></p><p>数据范围：$1\le n\le4\times10^4$，$0\le w\le1\times10^3$，$0\le k\le1\times10^4$。</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h4><p>对于每两个点都求一遍距离，预处理后统一比较。<br>时间复杂度和空间复杂度都是$O(n^2)$，然后爆了。</p><h4 id="点分治优化"><a href="#点分治优化" class="headerlink" title="点分治优化"></a>点分治优化</h4><p>我们知道，点分治解将树上路径统计相关问题，时间复杂度在$O(n\log n)$以内。</p><p>操作步骤：<br>一、找到当前子树的重心；<br>二、预处理深度和大小信息；<br><img src="../../img/22-02.jpg" alt="22-02" style="zoom:75%;" /><br>三、匹配深度，判断是否大于$k$，若大于则统计进答案；<br><img src="../../img/22-03.jpg" alt="22-03" style="zoom:75%;" /><br><img src="../../img/22-04.jpg" alt="22-04" style="zoom:75%;" /><br>四、删去同一子树内的答案；<br>因为匹配时答案包含同一子树内的路径，但同一子树内的不是简单路径，不合题意，需减去。<br><img src="../../img/22-05.jpg" alt="22-05" style="zoom:75%;" /><br>五、将树拆分，查找新的重心递归求解。<br><img src="../../img/22-06.jpg" alt="22-06" style="zoom:75%;" /></p><h4 id="双指针优化"><a href="#双指针优化" class="headerlink" title="双指针优化"></a>双指针优化</h4><p>注意到匹路径时需要遍历树内所有节点，时间复杂度$O(n^2)$。<br>可以使用双指针优化，先对深度排序，再删去不合适的，最终取加和即为答案。<br>对照代码自己理解一下。  </p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>; ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>); ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 40010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> w e[i].val</span><br><span class="hljs-type">int</span> n, k, t1, t2, t3, ans;<br><span class="hljs-type">int</span> head[N], tot;<br><span class="hljs-type">int</span> siz[N], Fa[N], son[N], rt[N], cnt, h[N];<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br><span class="hljs-type">int</span> to, nxt, val;<br>&#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> z)</span> </span>&#123;<br>e[++tot].nxt=head[x], e[tot].to=y, e[tot].val=z, head[x]=tot;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getroot</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>siz[u]=<span class="hljs-number">1</span>, Fa[u]=fa, son[u]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (v==fa||vis[v]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">getroot</span>(v, u);<br>siz[u]+=siz[v];<br><span class="hljs-keyword">if</span> (siz[son[u]]&lt;siz[v]) son[u]=v;<br>&#125;<br><span class="hljs-keyword">if</span> (son[u]==<span class="hljs-number">0</span>) &#123;rt[u]=u; <span class="hljs-keyword">return</span>;&#125;<br>rt[u]=rt[son[u]];<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">max</span>(siz[son[rt[u]]], siz[u]-siz[rt[u]])&gt;siz[u]&gt;&gt;<span class="hljs-number">1</span>) rt[u]=Fa[rt[u]];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> de)</span> </span>&#123;<br>h[++cnt]=h[<span class="hljs-number">0</span>]+de;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (v==fa||vis[v]) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs1</span>(v, u, de+w);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> wi)</span> </span>&#123;<br>cnt=<span class="hljs-number">0</span>, h[<span class="hljs-number">0</span>]=wi;<br><span class="hljs-built_in">dfs1</span>(u, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">sort</span>(h+<span class="hljs-number">1</span>, h+cnt+<span class="hljs-number">1</span>);<br><span class="hljs-type">int</span> l=<span class="hljs-number">1</span>, r=cnt, res=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (r&gt;=l) &#123;<br><span class="hljs-keyword">if</span> (h[r]+h[l]&lt;=k) res+=(r-l), ++l;<br><span class="hljs-keyword">else</span> --r;<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br><span class="hljs-built_in">getroot</span>(u, <span class="hljs-number">0</span>);<br>u=rt[u], vis[u]=<span class="hljs-number">1</span>;<br>ans+=<span class="hljs-built_in">calc</span>(u, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (vis[v]) <span class="hljs-keyword">continue</span>;<br>ans-=<span class="hljs-built_in">calc</span>(v, w);<br><span class="hljs-built_in">dfs2</span>(v);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;n; ++i) &#123;<br>t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>(), t3=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add_edge</span>(t1, t2, t3), <span class="hljs-built_in">add_edge</span>(t2, t1, t3); <br>&#125;<br>k=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>斜率优化</title>
    <link href="/articles/Slope-Optimization/"/>
    <url>/articles/Slope-Optimization/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>一个支持维护区间信息的数据结构。<br>详见<a href="https://oi-wiki.org/ds/seg/">OI-Wiki</a>。</p><hr><h3 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h3><p>斜率优化是一种常用于<strong>动态规划</strong>问题的优化技巧，特别是在处理形如$dp[i] &#x3D; \min&#x2F;\max{a[j]\times b[i] + c[j] + d[i]}$的状态转移方程时，通过<strong>维护一个凸包或凹包</strong>来快速找到最优的$j$。斜率优化算法通过减少不必要的计算，能够显著提高动态规划的效率。</p><hr><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>1.动态规划状态转移方程能转化为$a[j] * b[i] + c[j] + d[i]$形式，且需要维护$d[i]$最值。<br>2.外层$i$循环，内层$j$循环。<br>3.$x[j]$要求严格单调递增。<br>4.决策点位置在上凸壳或下凸壳上。</p><hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>首先，我们将转移方程去掉$\min$和$\max$运算符，只保留内部式子。<br>转化为$y[j]&#x3D;k[i]\times x[j]+b[i]$形式，将每一个$j$所表示的数画在图像上，如图所示。<br><img src="../../img/21-01.jpg" alt="21-01" style="zoom:50%;" /><br>由于$i$循环在外层，所以$k[i]$确定，需要求最大或最小的$b[i]$。</p><p>当需要取的$b[i]$为最大值时，<br><img src="../../img/21-02.jpg" alt="21-02" style="zoom:50%;" /><br><img src="../../img/21-03.jpg" alt="21-03" style="zoom:50%;" /><br>不难发现，不论如何改变斜率，决策点永远是在上面两个点上。<br><img src="../../img/21-04.jpg" alt="21-04" style="zoom:50%;" /><br>最小值也是一样，不论如何改变斜率，决策点永远是在下面两个点上。<br><img src="../../img/21-05.jpg" alt="21-05" style="zoom:50%;" /><br>多举几个例子看一下，可以发现，最大决策点永远在上凸包上，最小决策点永远在下凸包上。<br><img src="../../img/21-06.jpg" alt="21-06" style="zoom:50%;" /><br>所以，对于这类问题，只需要根据操作运算符存储上凸包和下凸包上的点即可。可以使用单调队列维护，保证斜率递增&#x2F;递减。<br>以维护下凸包(即最小值)为例，插入一个点后，如果连接上上个点的斜率比上一个点斜率小，就删去上一个点。<br><img src="../../img/21-07.jpg" alt="21-07" style="zoom:50%;" />  </p><hr><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>以<a href="https://www.luogu.com.cn/problem/P3195">P3195 玩具装箱</a>为例，题目要求维护$f[i]$最小值。<br>前缀和$s$，$L$提前减一，化式子：<br>$f[i]&#x3D;s[i]^2−2s[i]L+dp[j]+(S[j]+L)^2−2s[i]s[j]$<br>按斜率优化思路，$x[j]&#x3D;s[j],\ y[j]&#x3D;(f[j]+(s[j]+L)^2$。<br>接着单调队列维护即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 50010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x(a) s[a]</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y(a) (f[a]+(s[a]+L)*(s[a]+L))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> k(a) (s[a]&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> up(a,b) (y(b)-y(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> down(a,b) (x(b)-x(a))</span><br>ll n, L;<br>ll c[N], s[N], f[N];<br>ll l, r, q[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br>L=<span class="hljs-built_in">read</span>()+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) c[i]=<span class="hljs-built_in">read</span>(), s[i]=s[i<span class="hljs-number">-1</span>]+c[i]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">while</span> (l&lt;r&amp;&amp;<span class="hljs-built_in">up</span>(q[l],q[l+<span class="hljs-number">1</span>])&lt;=<span class="hljs-built_in">down</span>(q[l],q[l+<span class="hljs-number">1</span>])*<span class="hljs-built_in">k</span>(i)) ++l;<br>f[i]=f[q[l]]+(s[i]-s[q[l]]-L)*(s[i]-s[q[l]]-L);<br><span class="hljs-keyword">while</span> (l&lt;r&amp;&amp;<span class="hljs-built_in">up</span>(q[r<span class="hljs-number">-1</span>],q[r])*<span class="hljs-built_in">down</span>(q[r],i)&gt;=<span class="hljs-built_in">up</span>(q[r],i)*<span class="hljs-built_in">down</span>(q[r<span class="hljs-number">-1</span>],q[r])) --r;<br>q[++r]=i;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, f[n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意，此处的<code>up</code>和<code>down</code>函数起到判断斜率的作用。  </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>点分治</title>
    <link href="/articles/Divide-and-Conquer-on-Trees/"/>
    <url>/articles/Divide-and-Conquer-on-Trees/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>无环联通图，有唯一一个前驱。<br>详见<a href="https://oi-wiki.org/graph/tree-basic/">OI-Wiki</a>。</p><h4 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h4><p>一个节点，使得删去它后所形成的最大子树最小。<br>详见<a href="https://oi-wiki.org/graph/tree-centroid/">OI-Wiki</a>。</p><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><p>一个支持维护区间信息的数据结构。<br>详见<a href="https://oi-wiki.org/ds/seg/">OI-Wiki</a>。</p><hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本文讲述得较为详细。如果只是想快速了解算法内容，请前往<a href="https://oi-wiki.org/graph/tree-divide/#%E7%82%B9%E5%88%86%E6%B2%BB">OI-Wiki</a>。<br>本篇文章就无根树进行说明。</p><hr><h3 id="算法适用条件"><a href="#算法适用条件" class="headerlink" title="算法适用条件"></a>算法适用条件</h3><p>解决带权树上路径统计相关问题。<br>时间复杂度$O(n\log n)$，空间复杂度$O(n)$。</p><hr><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>以这样一棵树为例：<br><img src="../../img/20-01.jpg" alt="20-01" style="zoom:50%;" /><br>先随便指定一个根节点。<br>显然，对于每条树上的路径，我们可以分为两种。一种时经过根节点的，另一种是不经过根节点的。</p><p>对于每条经过根节点的路径$u\rightarrow v$，我们将其拆为两段，分别为$u\rightarrow root$和$root\rightarrow v$，计算后再合并，即可得到答案。<br>由此，可以处理根节点到每个节点的路径信息，再计算经过根节点的路径信息。</p><p>不经过根节点的路径一定全部在子树中。完成上述操作后，可将根节点删除，对每个子树内的问题进行求解。这样不经过根节点的路径一定会在后续操作中转化为经过子树根节点的路径，再通过上述过程可计算答案。</p><p>所有子树求解完后向上递归合并答案，结合经过根节点路径的答案和所有子树内路径的答案，即可得到所有路径的答案。</p><p>考虑最坏情况，树是一条链，根节点每次都选到链的一端，时间复杂度$O(n^2)$。</p><hr><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>不难发现，算法的时间瓶颈在于子树大小。子树越大，所能继续分的次数越多，树的总计算次数也越多。所以，被分开的每个子树应尽可能小。<br>每次都取当前树的重心作为根节点，这样把树分开后所形成的最大子树会最小，从而减少总递归层数。</p><p>算法分为三步：<br>1.找到当前树的根节点，计算根节点到各节点的答案，处理经过根节点的路径个数。<br><img src="../../img/20-02.jpg" alt="20-02" style="zoom:50%;" /><br>2.统计完，将根节点删除，对子树进行求解。<br><img src="../../img/20-03.jpg" alt="20-03" style="zoom:50%;" /></p><p>这样总的递归层数不会超过$\log n$，时间复杂度$O(n\log n)$。</p><hr><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>几点注意事项：<br>1.递归时需要删除根节点，用<code>vis</code>数组存储；<br>2.数组删除时需要用队列存储后精准删除，使用<code>memset</code>或<code>for</code>循环会爆掉。</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>ans+=<span class="hljs-built_in">solve</span>(u, <span class="hljs-number">0</span>); <span class="hljs-comment">// 经过根节点的答案</span><br>vis[u]=<span class="hljs-number">1</span>; <span class="hljs-comment">// 删除根节点</span><br><span class="hljs-keyword">for</span> (v:u.son) &#123;<br><span class="hljs-keyword">if</span> (v==fa||vis[v]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 父亲和被删除的节点都不访问</span><br>ans-=<span class="hljs-built_in">solve</span>(v, w); <span class="hljs-comment">// 删除重复计算的边</span><br><span class="hljs-built_in">find_root</span>(v, u); <span class="hljs-comment">// 找重心</span><br><span class="hljs-built_in">dfs2</span>(root, <span class="hljs-number">0</span>); <span class="hljs-comment">// 分治</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>代码结构：<br>1.求重心 <code>dfs1</code><br>2.求路径信息 <code>dfs2</code><br>3.求解答案</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>eps详解</title>
    <link href="/articles/Detailed-Explanation-of-EPS/"/>
    <url>/articles/Detailed-Explanation-of-EPS/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>不会用$eps$请不要担心，这是高阶算法内容。<br>就算没有判或判错了很大可能只影响算法复杂度，最多多跑一层，无需担心。<br>但是某些特定情况下需要特别关注$eps$，不过这是极少数情况。</p><p>这篇文章很长，如果只是想了解一下$eps$，不追求理解原理，请前往<a href="../Detailed-Explanation-of-EPS/#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决方案</a>一节，或在<a href="https://www.luogu.com.cn/paste/ox2b3zgd">洛谷剪贴板</a>中查看。</p><hr><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Taoran第一次见到$eps$是在李超树模板里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> eps 1e-8</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LS (p&lt;&lt;1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RS ((p&lt;&lt;1)+1)</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">line</span> &#123;<br><span class="hljs-type">double</span> k, b;<br><span class="hljs-type">int</span> id;<br><span class="hljs-built_in">line</span>() &#123;&#125;<br><span class="hljs-built_in">line</span>(<span class="hljs-type">double</span> x0, <span class="hljs-type">double</span> y0, <span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> y1, <span class="hljs-type">int</span> _id) &#123;<br>id=_id;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(x1-x0)&lt;eps) k=<span class="hljs-number">0</span>, b=<span class="hljs-built_in">max</span>(y0, y1);<br><span class="hljs-keyword">else</span> k=(y1-y0)/(x1-x0), b=y0-k*x0;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">val</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-keyword">return</span> k*x+b;&#125;<br>&#125; t[N&lt;&lt;<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, line y)</span> </span>&#123;<br><span class="hljs-type">int</span> mid=(pl+pr)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (l&lt;=pl&amp;&amp;pr&lt;=r) &#123;<br><span class="hljs-keyword">if</span> (t[p].id==<span class="hljs-number">0</span>) &#123;t[p]=y; <span class="hljs-keyword">return</span>;&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(t[p].<span class="hljs-built_in">val</span>(mid)-y.<span class="hljs-built_in">val</span>(mid))&lt;eps) &#123;<br><span class="hljs-keyword">if</span> (t[p].id&gt;y.id) <span class="hljs-built_in">swap</span>(t[p], y);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[p].<span class="hljs-built_in">val</span>(mid)&lt;y.<span class="hljs-built_in">val</span>(mid)) <span class="hljs-built_in">swap</span>(t[p], y);<br><span class="hljs-keyword">if</span> (t[p].<span class="hljs-built_in">val</span>(pl)&lt;y.<span class="hljs-built_in">val</span>(pl)+eps) <span class="hljs-built_in">insert</span>(LS, pl, mid, l, r, y);<br><span class="hljs-keyword">if</span> (t[p].<span class="hljs-built_in">val</span>(pr)&lt;y.<span class="hljs-built_in">val</span>(pr)+eps) <span class="hljs-built_in">insert</span>(RS, mid+<span class="hljs-number">1</span>, pr, l, r, y);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (l&lt;=mid) <span class="hljs-built_in">insert</span>(LS, pl, mid, l, r, y);<br><span class="hljs-keyword">if</span> (r&gt;=mid+<span class="hljs-number">1</span>) <span class="hljs-built_in">insert</span>(RS, mid+<span class="hljs-number">1</span>, pr, l, r, y);<br>&#125;<br><br><span class="hljs-function">line <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (pl==pr) <span class="hljs-keyword">return</span> t[p];<br><span class="hljs-type">int</span> mid=(pl+pr)&gt;&gt;<span class="hljs-number">1</span>;<br>line res;<br><span class="hljs-keyword">if</span> (x&lt;=mid) res=<span class="hljs-built_in">ask</span>(LS, pl, mid, x);<br><span class="hljs-keyword">else</span> res=<span class="hljs-built_in">ask</span>(RS, mid+<span class="hljs-number">1</span>, pr, x);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(res.<span class="hljs-built_in">val</span>(x)-t[p].<span class="hljs-built_in">val</span>(x))&lt;eps) &#123;<br><span class="hljs-keyword">if</span> (res.id&lt;t[p].id) <span class="hljs-keyword">return</span> res;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> t[p];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">val</span>(x)&gt;t[p].<span class="hljs-built_in">val</span>(x)) <span class="hljs-keyword">return</span> res;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> t[p];<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>$eps$出现在<code>line</code>、<code>insert</code>和<code>ask</code>这三个函数的<code>double</code>关系判断中。</p><hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="C-中的浮点类型"><a href="#C-中的浮点类型" class="headerlink" title="C++中的浮点类型"></a>C++中的浮点类型</h4><p>详见<a href="https://oi-wiki.org/lang/var/#%E6%B5%AE%E7%82%B9%E7%B1%BB%E5%9E%8B">OI-Wiki</a>。</p><h4 id="小数部分的进制转换"><a href="#小数部分的进制转换" class="headerlink" title="小数部分的进制转换"></a>小数部分的进制转换</h4><p>自己学去。</p><hr><h3 id="double类型的内存"><a href="#double类型的内存" class="headerlink" title="double类型的内存"></a>double类型的内存</h3><p>我们可以使用下面这段程序查看<code>double</code>类型的内存。<br>输入一个小数，输出它精确到小数点后40位的存储，及所存储的64bit数据。<br>这里借助<code>union</code>结合体将<code>double</code>类型的内存共享给空间大小相等的<code>long long</code>类型，再使用位运算逐位输出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">tmp</span> &#123;<br><span class="hljs-type">double</span> d;<br>ll l;<br>&#125; t;<br><br>ll ans[<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t.d);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.40lf\n&quot;</span>, t.d);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">64</span>; ++i) ans[<span class="hljs-number">65</span>-i]=t.l&amp;<span class="hljs-number">1</span>, t.l&gt;&gt;=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">64</span>; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans[i]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>本篇文章中，将以$11.25$与$11.3$为例解释。</p><hr><h3 id="C-中的小数存储"><a href="#C-中的小数存储" class="headerlink" title="C++中的小数存储"></a>C++中的小数存储</h3><p>在C++中，不论是<code>float</code>、<code>double</code>还是<code>long double</code>，它们都是以科学计数法的形式存储小数的。<br>举个例子，$11.25$用科学计数法可以表示成$1.125\times10^{-1}$，用二进制可以表示成$(1011.01)_2$，而在计算机中它被表示成$(1.01101)_2\times2^3$。</p><hr><h3 id="理想状态"><a href="#理想状态" class="headerlink" title="理想状态"></a>理想状态</h3><p>$11.25$精确到小数点后$40$位的输出：$11.2500000000000000000000000000000000000000$<br>$010000000010\ 0110100000000000000000000000000000000000000000000000$<br>前$16$位为$2$的次幂，后$48$位为小数部分。<br>注意，为节省空间，小数部分被省去了第一个$1$，只存储$.01101$。</p><p>显然，$11.25$根本难不倒<code>double</code>，输出小数点后40位依然正确。这是因为$0.25$恰好能被有限位二进制小数表示。但如果换一个呢？</p><hr><h3 id="爆精度"><a href="#爆精度" class="headerlink" title="爆精度"></a>爆精度</h3><p>$11.3$精确到小数点后$40$位的输出：$11.3000000000000007105427357601001858711243$<br>$0100000000100110\ 100110011001100110011001100110011001100110011010$</p><p>出问题了，$11.3$的小数部分$0.3$并不能被二进制小数表示尽，出现循环，而计算机存储的数据量是有限的，从而导致精度下降。<br>小数在C++中，有时并不能被精确表示。</p><hr><h3 id="大小判断缺陷"><a href="#大小判断缺陷" class="headerlink" title="大小判断缺陷"></a>大小判断缺陷</h3><p>我们做一个实验。<br>两数$a$、$b$初始值均为$11.3$，其中$b$加上一个数后再减去，判断两数是否相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">tmp</span> &#123;<br><span class="hljs-type">double</span> d;<br>ll l;<br>&#125; a, b;<br><br>ll ans[<span class="hljs-number">100</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>a.d=b.d=<span class="hljs-number">11.3</span>;<br>b.d+=<span class="hljs-number">21.0426</span>;<br>b.d-=<span class="hljs-number">21.0426</span>;<br><span class="hljs-built_in">puts</span>((a.d==b.d)?<span class="hljs-string">&quot;True&quot;</span>:<span class="hljs-string">&quot;False&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.40lf\n&quot;</span>, a.d);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">64</span>; ++i) ans[<span class="hljs-number">65</span>-i]=a.l&amp;<span class="hljs-number">1</span>, a.l&gt;&gt;=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">64</span>; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.40lf\n&quot;</span>, b.d);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">64</span>; ++i) ans[<span class="hljs-number">65</span>-i]=b.l&amp;<span class="hljs-number">1</span>, b.l&gt;&gt;=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">64</span>; ++i) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, ans[i]); <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">False</span><br><span class="hljs-attribute">11</span>.<span class="hljs-number">3000000000000007105427357601001858711243</span><br><span class="hljs-attribute">0100000000100110100110011001100110011001100110011001100110011010</span><br><span class="hljs-attribute">11</span>.<span class="hljs-number">3000000000000042632564145606011152267456</span><br><span class="hljs-attribute">0100000000100110100110011001100110011001100110011001100110011100</span><br></code></pre></td></tr></table></figure><p>结果令人吃惊，变化后两数不相等。<br>仔细看数据就会发现，内存的<strong>最后三位</strong>发生了变化。$010\rightarrow100$，正是这小小的变化改变了C++对于小数的判断。</p><p>这意味着，C++没有相等容忍区间，任何一点小的变动都会影响到大小判断。</p><hr><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>既然C++本身没有容忍区间，我们可以给它加上一个。</p><p>设一个常数$eps&#x3D;1\times10^{-8}$，通常认为：<br>$a&#x3D;b\Rightarrow a-b\in [-eps,\ eps]$<br>$a&gt;b\Rightarrow a-b&gt; eps$<br>$a\ge b\Rightarrow a-b\ge-eps$</p><p>带着图简单理解一下：<br><img src="../../img/19-01.jpg" alt="19-01" style="zoom:100%;" />  </p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于C++浮点数储存原理的缺陷，浮点数的精度不能保证，在关系判断中精度差会导致判断错误。<br>一般来说，浮点类型的大小关系判断需要使用$eps$给定宽容区间，否则算法会出现错误，导致更高的时间复杂度甚至错误答案。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>洛谷P3478 题解</title>
    <link href="/articles/Solution-of-P3478/"/>
    <url>/articles/Solution-of-P3478/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="换根DP"><a href="#换根DP" class="headerlink" title="换根DP"></a>换根DP</h4><p>请前往<a href="../Dynamic-Programming-with-Root-Replacement">另一篇文章</a>。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>更详细的描述，请前往<a href="https://www.luogu.com.cn/problem/P3478">洛谷</a>查看。</p><p>给定一个 $n$ 个点的树，请求出一个结点，使得以这个结点为根时，所有结点的深度之和最大。<br>一个结点的深度之定义为该节点到根的简单路径上边的数量。</p><p>数据范围：$1\le n\le1\times10^6$，$1\le u,\ v\le n$。</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>换根DP板子题，维护深度信息。<br>先随便找一个根节点，跑一边DFS，计算到所有节点的深度。<br>接着再来一个DFS换根，每次从母节点换到子节点时，当前子树内所有节点的深度减一，母节点及其他子树的所有节点深度加一。</p><hr><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v e[i].to</span><br>ll n, t1, t2, ans=<span class="hljs-number">1</span>;<br>ll head[N], tot;<br>ll dep[N], siz[N], dp[N]; <span class="hljs-comment">//dep[root] = 1</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>ll to, nxt;<br>&#125; e[N&lt;&lt;<span class="hljs-number">1</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(ll x, ll y)</span> </span>&#123;<br>e[++tot].nxt=head[x];<br>head[x]=tot;<br>e[tot].to=y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(ll u, ll fa)</span> </span>&#123;<br>siz[u]=<span class="hljs-number">1</span>, dep[u]=dep[fa]+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (ll i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (v==fa) <span class="hljs-keyword">continue</span>;<br>dep[v]=dep[u]+<span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs1</span>(v, u);<br>siz[u]+=siz[v];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(ll u, ll fa)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (ll i=head[u]; i; i=e[i].nxt) &#123;<br><span class="hljs-keyword">if</span> (v==fa) <span class="hljs-keyword">continue</span>;<br>dp[v]=dp[u]+n-siz[v]-siz[v];<br><span class="hljs-built_in">dfs2</span>(v, u);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;n; ++i) &#123;<br>t1=<span class="hljs-built_in">read</span>(), t2=<span class="hljs-built_in">read</span>();<br><span class="hljs-built_in">add_edge</span>(t1, t2), <span class="hljs-built_in">add_edge</span>(t2, t1);<br>&#125;<br><span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) dp[<span class="hljs-number">1</span>]+=dep[i];<br><span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">2</span>; i&lt;=n; ++i) <span class="hljs-keyword">if</span> (dp[i]&gt;dp[ans]) ans=i;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>换根DP</title>
    <link href="/articles/Dynamic-Programming-with-Root-Replacement/"/>
    <url>/articles/Dynamic-Programming-with-Root-Replacement/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>无环联通图，有唯一一个前驱。<br>涉及换根DP问题的一般是无根树。<br>详见<a href="https://oi-wiki.org/graph/tree-basic/">OI-Wiki</a>。</p><hr><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>树形DP中的换根DP问题又被称为二次扫描，通常不会指定根结点，并且根结点的变化会对例如子结点深度和、点权和等一些值产生影响。<br>通常需要两次DFS，第一次DFS预处理诸如深度，点权和之类的信息，第二次DFS开始运行换根动态规划。</p><hr><h3 id="题目特征"><a href="#题目特征" class="headerlink" title="题目特征"></a>题目特征</h3><p>一般基于树上的问题或能转化成树上问题的，离线的且解法确定的，且需对每一个点作为根节点求解，时空复杂度在$1\times10^7$以内的可以考虑使用换根DP求解。<br>同时，允许一个节点的状态从相邻节点转移。</p><hr><h3 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h3><p>以这样一棵树为例。<br><img src="../../img/17-01.jpg" alt="17-01" style="zoom:100%;" /><br>首先，任选一个节点作为根节点，使用DFS遍历整棵树并处理出下一步换根所需要的相关数据，同时对根节点求解。这里以常见的深度和子树大小为例。<br><img src="../../img/17-02.jpg" alt="17-02" style="zoom:100%;" /><br>接下来，从根节点开始顺序遍历，用父节点更新子节点的答案。<br><img src="../../img/17-03.jpg" alt="17-03" style="zoom:100%;" /><br>一般地，从父节点转移到字结点后，答案的更改可在子树内和子树外分别讨论。通常子树内一套、子树外一套，如图所示。例如计算$dep$和，子树内全部减$1$，而子树外全部加$1$。<br><img src="../../img/17-04.jpg" alt="17-04" style="zoom:100%;" /><br>换根DP的一般思路：<br>首先跑一遍DFS，由叶子结点向上，更新状态转移所需信息。再跑一边DFS，由根节点向下，计算每个节点作为根节点的答案。</p><hr><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// u -&gt; current node</span><br><span class="hljs-comment">// v -&gt; child node</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(u, fa)</span> </span>&#123;<br><span class="hljs-comment">// Initialize the required information.</span><br><span class="hljs-keyword">for</span> (connected_nodes) &#123;<br><span class="hljs-keyword">if</span> (v==fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs1</span>(v, u);<br><span class="hljs-comment">// Update the required information.</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(u, fa)</span> </span>&#123;<br><span class="hljs-comment">// Initialize the answer.</span><br><span class="hljs-keyword">for</span> (connected_nodes) &#123;<br><span class="hljs-keyword">if</span> (v==fa) <span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">// Update the answer.</span><br><span class="hljs-built_in">dfs1</span>(v, u);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0-1背包问题</title>
    <link href="/articles/0-1-Backpack/"/>
    <url>/articles/0-1-Backpack/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><p>你需要知道DP是<a href="/2024/03/05/Dynamic-Programming/">什么东西</a>，同时你需要背过包。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>李华有一个背包，他想往背包里放一些东西，使得价值最大。李华的背包有容量限制，所以他并不能装下所有的东西，也就说有一些东西需要被舍弃掉。<br><img src="../../img/16-01.jpg" alt="16-01" style="zoom:75%;" /><br>有$n$件物品和一个容量为$m$的背包，第$i$件物品的重量为$w_i$，价值为$v_i$。求选若干物品放入背包，背包内物品价值总和最大值。满足$w_i&gt;0$。</p><hr><h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>不难想到，可以暴力枚举每一件物品是否放置。对于每一种合法的物品选取方案的价值总和求最大值。时间复杂度$O(2^n)$。<br>在一秒内，这种算法最多只能过$n\le26$的数据，然后挂了。</p><p>容易想到，可以删去那些价值为$0$或重量超过背包容量的物体。但优化效果不显著，该挂的分还是得挂。</p><hr><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>对于每一个物品，只有取和不取两种状态。同时，在物品取之后只有剩余容量和已取价值受到影响。所以可以考虑使用DP求解。</p><h4 id="状态设置"><a href="#状态设置" class="headerlink" title="状态设置"></a>状态设置</h4><p>设$f[i][j]$表示前$i$种物品放入背包容量为$j$的背包中得到的最大价值。</p><h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>容量为$0$的背包啥也放不下，不能获得任何价值，所以$f[i][0]&#x3D;0$。<br>啥也不放的背包不能获得任何价值，所以$f[0][j]&#x3D;0$。</p><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>对于第$i$件物品，剩余空间为$j$时：</p><p>1.如果物品能放得下，即$j\ge v[i]$时，物品放不放都可以。<br>如果不放这个物品，剩余容量和价值相较上一个物品都没有变化，所以$f[i][j]&#x3D;f[i-1][j]$。<br>如果放这个物品，相较上一个物品，剩余容量将会减少$w[i]$，价值将会增加$v[i]$，所以$f[i][j]&#x3D;f[i-1][j-w[i]]+v[i]$。<br>为最大化物品总价值，上述两个取最大值更新$f[i][j]$。</p><p>2.如果物品不能放得下，即$g&lt;v[i]$时，物品就一定不能被放下。<br>此时状态只能从上一个物品转移，即$f[i][j]&#x3D;f[i-1][j]$。</p><p>所以$f[i][j]&#x3D;<br>\begin{cases}<br>f[i-1][j],&amp;j&lt;v[i]\\<br>max{f[i-1][j],\ f[i-1][j-w[i]]+v[i]},&amp;j\ge v[i]<br>\end{cases}$</p><h4 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h4><p>显然，最终答案是所有物品被判断且所有容量被用完时的最大价值，即$f[n][m]$。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// w[N], v[N], f[N][M];</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; ++j) &#123;<br>f[i][j]=f[i<span class="hljs-number">-1</span>][j];<br><span class="hljs-keyword">if</span> (j&gt;=w[i]) f[i][j]=<span class="hljs-built_in">max</span>(f[i][j], f[i<span class="hljs-number">-1</span>][j-w[i]]+v[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n][m]);<br></code></pre></td></tr></table></figure><hr><h3 id="滚动数组优化"><a href="#滚动数组优化" class="headerlink" title="滚动数组优化"></a>滚动数组优化</h3><p>将状态转移中的$f$数组画出来，如图所示。<br><img src="../../img/16-02.jpg" alt="16-02" style="zoom:75%;" /><br>可以发现，对于任意一个物品，其状态都是上一行转移过来的，且在正上方或上一行的左方。<br>于是我们可以删去一维，只保留一维数组，存储上一个物体的状态，如图所示。<br><img src="../../img/16-03.jpg" alt="16-03" style="zoom:75%;" /><br>注意，此时循环必须从右侧开始，因为状态转移依赖左边的数据，复写掉就找不回来了。</p><p>此时$f[j]&#x3D;<br>\begin{cases}<br>f[j],&amp;j&lt;v[i]\\<br>max{f[j],\ f[j-w[i]]+v[i]},&amp;j\ge v[i]<br>\end{cases}$</p><hr><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// w[N], v[N], f[M];</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=m; j&gt;=<span class="hljs-number">1</span>; --j) &#123;<br><span class="hljs-keyword">if</span> (j&gt;=w[i]) f[j]=<span class="hljs-built_in">max</span>(f[j], f[j-w[i]]+v[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[m]);<br></code></pre></td></tr></table></figure><hr><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><p>板子题 [NOIP2005 普及组] 采药<br><a href="https://www.luogu.com.cn/problem/P1048">题目传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 110</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 1010</span><br><span class="hljs-type">int</span> n, m, w[N], v[N], f[M];<br><span class="hljs-type">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>m=<span class="hljs-built_in">read</span>(), n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) w[i]=<span class="hljs-built_in">read</span>(), v[i]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=m; j&gt;=<span class="hljs-number">1</span>; --j) &#123;<br><span class="hljs-keyword">if</span> (j&gt;=w[i]) f[j]=<span class="hljs-built_in">max</span>(f[j], f[j-w[i]]+v[i]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[m]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AT_dp_l 题解</title>
    <link href="/articles/Solution-of-AT-dp-l/"/>
    <url>/articles/Solution-of-AT-dp-l/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><p>双端队列是指一个可以在队首或队尾插入或删除元素的队列。相当于是栈与队列功能的结合。</p><h4 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h4><p>详见<a href="https://oi-wiki.org/dp/interval/">OI-Wiki</a>。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个双端队列，双方轮流取数，每一次能且只能从队头或队尾取数，取完数后将这个数从队列中弹出。双方都希望自己取的所有数之和尽量大，且双方都以最优策略行动，假设先手取的所有数之和为 $X$，后手取的所有数之和为 $Y$，求 $X-Y$。</p><p>数据范围：$1\le N\le3000$，$1\le a_i\le1\times10^9$</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h4><p>该问题满足最优性原则和无后效性原则，同时数据范围允许使用动态规划，所以考虑区间DP求解。</p><h4 id="状态设置"><a href="#状态设置" class="headerlink" title="状态设置"></a>状态设置</h4><p>由题意得，剩下的数都是连续的。<br>设$f[i][j]$表示剩下从$i$到$j$这些数时，先手与后手分数的差。注意此时的先手是开始时的先手，不是当前先手。</p><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>一个长区间的状态可以由其内部更短区间的状态转移得到。具体地，一个区间$[i,\ j]$的状态可以由区间$[i+1,\ j]$和$[i,\ j-1]$转移得到，转移时只需要判断$a[i]$与$a[j]$即可。</p><p>原序列长度为$n$，没有取到的数位于区间$[i,\ j]$内，所以已经取过的数总共$(n+i-j-1)$个</p><p>如果已经取走的数的有偶数个，那新的数将被先手取到。状态设置的是先手与后手的分数差，所以当先手取到新数时，这个差值会变大。<br>如果这个数从队头取，原先没有被选的区间$[i,\ j]$变为$[i+1,\ j]$，同时答案加上$a[i]$。<br>如果这个数从队尾取，原先没有被选的区间$[i,\ j]$变为$[i,\ j-1]$，同时答案加上$a[j]$。<br>就先手而言，自己得到更大的数的和是最佳决策，即最优解为分数差较大的一个。由于先手按照最优策略决策，这两个答案将取最大值作为新状态。</p><p>如果已经取走的数的有奇数个，那新的数将被后手取到。状态设置的是先手与后手的分数差，所以当后手取到新数时，这个差值会变小。<br>如果这个数从队头取，原先没有被选的区间$[i,\ j]$变为$[i+1,\ j]$，同时答案减去$a[i]$。<br>如果这个数从队尾取，原先没有被选的区间$[i,\ j]$变为$[i,\ j-1]$，同时答案减去$a[j]$。<br>就后手而言，自己得到更大的数的和是最佳决策，即最优解为分数差较小的一个。由于后手按照最优策略决策，这两个答案将取最小值作为新状态。</p><p>综上，容易得到总的状态转移方程：<br>$$<br>f[i][j]&#x3D;<br>\begin{cases}<br>max(f[i+1][j]+a[i],\ f[i][j-1]+a[j]),\ n+i-j-1\equiv0\pmod2\\<br>min(f[i+1][j]-a[i],\ f[i][j-1]-a[j]),\ n+i-j-1\equiv1\pmod2<br>\end{cases}<br>$$</p><h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><p>由于最开始一个数都没有取时，双方分数都为$0$，分数差为$0$，所以初始值全部为$0$。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>枚举区间起点和区间长度，长度从$1$到$n$依次枚举，计算对应答案。从全部取完向前倒推，直到开始的时候，即可得出答案。最终答案为$f[1][n]$。</p><hr><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 3010</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> e h+i</span><br><br>ll n, d[N], f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">1</span>; i&lt;=n; ++i) d[i]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (ll i=<span class="hljs-number">0</span>; i&lt;n; ++i) &#123;<br><span class="hljs-keyword">for</span> (ll h=<span class="hljs-number">1</span>; h&lt;=n-i; ++h) &#123;<br><span class="hljs-keyword">if</span> ((n-i)&amp;<span class="hljs-number">1</span>) f[h][e]=<span class="hljs-built_in">max</span>(f[h+<span class="hljs-number">1</span>][e]+d[h], f[h][e<span class="hljs-number">-1</span>]+d[e]);<br><span class="hljs-keyword">else</span> f[h][e]=<span class="hljs-built_in">min</span>(f[h+<span class="hljs-number">1</span>][e]-d[h], f[h][e<span class="hljs-number">-1</span>]-d[e]);<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, f[<span class="hljs-number">1</span>][n]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="对于这道题"><a href="#对于这道题" class="headerlink" title="对于这道题"></a>对于这道题</h4><p>需要注意倒序计算，并且先手和后手采取的策略不一样，状态转移方程也有所不同。</p><h4 id="对于区间DP"><a href="#对于区间DP" class="headerlink" title="对于区间DP"></a>对于区间DP</h4><p>1.根据端点设状态，一般二维。<br>2.状态由区间合并得到。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AT_dp_j 题解</title>
    <link href="/articles/Solution-of-AT-dp-j/"/>
    <url>/articles/Solution-of-AT-dp-j/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="知识前置"><a href="#知识前置" class="headerlink" title="知识前置"></a>知识前置</h3><h4 id="离散型数学期望"><a href="#离散型数学期望" class="headerlink" title="离散型数学期望"></a>离散型数学期望</h4><p>离散型随机变量$X$的概率分布为$p_i&#x3D;P{X&#x3D;x_i}$。<br>$$<br>EX&#x3D;\sum^\infty_{i&#x3D;1}x_ip_i<br>$$<br>简单来说，就是 $\text{期望}&#x3D;\text{概率}\times\text{结果}$。</p><h4 id="期望DP"><a href="#期望DP" class="headerlink" title="期望DP"></a>期望DP</h4><p>详见<a href="https://oi-wiki.org/dp/probability/#dp-%E6%B1%82%E6%9C%9F%E6%9C%9B">OI-Wiki</a>。</p><hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有$N$哥盘子，编号为$1,\ 2,\ 3,\ \dots,\ N$。第$i$个盘子中放有$a_i$个$Sushi$。</p><p>接下来每次执行以下操作，直至吃完所有的寿司。若没有$Sushi$则不吃。</p><p>若将所有$Sushi$吃完，请问此时操作次数的数学期望是多少？</p><p>数据范围：$1\le N\le300$，$1\le a_i\le3$，答案精确到$1\times10^{-9}$。</p><hr><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h4><p>设$f[a_1][a_2]\cdots[a_n]$表示第$i$盘还剩$a_i$个$Sushi$的期望，显然可以得到：<br>$$<br>f[a_1][a_2]\cdots[a_n]&#x3D;1+\sum^n_{i&#x3D;1}\frac{f[a_1][a_2]\cdots[max(a_i-1, 0)]\dots[a_n]}{n}<br>$$<br>这种做法在时间上和空间上都会爆掉。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>注意到对于每一个状态，哪一个盘子剩的$Sushi$其实并不重要，需要注意的是每种盘子的个数。所以根据盘子内$Sushi$剩余数量设状态。<br>另外，盘子的总个数为$n$，所以空盘子数量&#x3D;n-剩余盘子，只需设三维即可。由此设$f[i][j][k]$为剩下$i$盘一个，$j$盘两个和$q$盘三个的期望。</p><h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><p>当剩一个$Sushi$的盘子被选中吃掉时，这类盘子就少了一个，此时${i,\ j,\ k}\rightarrow{i-1,\ j,\ k}$。<br>当剩两个$Sushi$的盘子被选中吃掉时，这类盘子就少了一个，同时剩一个$Sushi$的盘子多了一个，此时${i,\ j,\ k}\rightarrow{i+1,\ j-1,\ k}$。<br>当剩三个$Sushi$的盘子被选中吃掉时，这类盘子就少了一个，同时剩两个$Sushi$的盘子多了一个，此时${i,\ j,\ k}\rightarrow{i,\ j-1,\ k+1}$。<br>由此可以得到状态转移方程：<br>$$<br>f[i][j][k]&#x3D;\frac{n}{i+j+k}+\frac{i\times f[i-1][j][k]}{i+j+k}+\frac{j\times f[i+1][j-1][k]}{i+j+k}+\frac{k\times f[i][j+1][k-1]}{i+j+k}<br>$$</p><h4 id="初始状态"><a href="#初始状态" class="headerlink" title="初始状态"></a>初始状态</h4><p>开始所有期望都为$0$，$f[0][0][0]&#x3D;0$。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>从吃完到一个没吃，倒推。$i$，$j$，$k$自$0$到$n$递增，时间复杂度$O(n^3)$。</p><hr><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>], *p1, *p2;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;20,stdin),p1==p2)?0:*p1++)</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 305</span><br><span class="hljs-type">int</span> n, d[N];<br><span class="hljs-type">double</span> f[N][N][N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) ++d[<span class="hljs-built_in">read</span>()];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>; c&lt;=n; ++c) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>; b&lt;=n; ++b) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>; a&lt;=n; ++a) &#123;<br><span class="hljs-keyword">if</span> (a==<span class="hljs-number">0</span>&amp;&amp;b==<span class="hljs-number">0</span>&amp;&amp;c==<span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>f[a][b][c]=<span class="hljs-built_in">double</span>(n)/<span class="hljs-built_in">double</span>(a+b+c);<br><span class="hljs-keyword">if</span> (a!=<span class="hljs-number">0</span>) f[a][b][c]+=f[a<span class="hljs-number">-1</span>][b][c]*a/(a+b+c);<br><span class="hljs-keyword">if</span> (b!=<span class="hljs-number">0</span>) f[a][b][c]+=f[a+<span class="hljs-number">1</span>][b<span class="hljs-number">-1</span>][c]*b/(a+b+c);<br><span class="hljs-keyword">if</span> (c!=<span class="hljs-number">0</span>) f[a][b][c]+=f[a][b+<span class="hljs-number">1</span>][c<span class="hljs-number">-1</span>]*c/(a+b+c);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.10lf\n&quot;</span>, f[d[<span class="hljs-number">1</span>]][d[<span class="hljs-number">2</span>]][d[<span class="hljs-number">3</span>]]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="对于这道题"><a href="#对于这道题" class="headerlink" title="对于这道题"></a>对于这道题</h4><p>1.找到$a_i\le3$的突破口，根据剩余$Sushi$数量设置状态。<br>2.通过$Sushi$总数量为$n$简化状态，从四维减小到三维。<br>3.倒推求解。</p><h4 id="对于期望DP"><a href="#对于期望DP" class="headerlink" title="对于期望DP"></a>对于期望DP</h4><p>1.倒推求解。<br>2.状态转移方程需要化简。<br>3.根据数据范围倒推状态设计。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/articles/Dynamic-Programming/"/>
    <url>/articles/Dynamic-Programming/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、算法原理"><a href="#一、算法原理" class="headerlink" title="一、算法原理"></a>一、算法原理</h3><p>将大问题拆分成子问题，对每个子问题只求一次，汇总得到整个问题的最优解。</p><h4 id="1-最优化原理"><a href="#1-最优化原理" class="headerlink" title="1. 最优化原理"></a>1. 最优化原理</h4><p>子问题的局部最优将导致整个问题的全局最优。后面的决策必须在前面的状态的基础上构成最优策略。</p><h4 id="2-无后效性原则"><a href="#2-无后效性原则" class="headerlink" title="2. 无后效性原则"></a>2. 无后效性原则</h4><p>某阶段的状态一旦确定，此后过程不受此前状态的影响。下一个状态只与当前状态有关。</p><hr><h3 id="二、基本构成"><a href="#二、基本构成" class="headerlink" title="二、基本构成"></a>二、基本构成</h3><h4 id="1-阶段"><a href="#1-阶段" class="headerlink" title="1. 阶段"></a>1. 阶段</h4><p>阶段根据时间和空间划分，能够将问题转化为多阶段决策过程。</p><h4 id="2-状态"><a href="#2-状态" class="headerlink" title="2. 状态"></a>2. 状态</h4><p>某一阶段的出发位置称为状态，一个阶段包含多个状态。</p><h4 id="3-决策"><a href="#3-决策" class="headerlink" title="3. 决策"></a>3. 决策</h4><p>在一定范围内，将一个状态转移到下一个阶段的对应状态。所有决策构成的整体称为策略。</p><h4 id="4-状态转移方程"><a href="#4-状态转移方程" class="headerlink" title="4. 状态转移方程"></a>4. 状态转移方程</h4><p>描述由第$i$阶到第$i+1$阶状态的演变规律的方程。</p><hr><h3 id="三、常见分类"><a href="#三、常见分类" class="headerlink" title="三、常见分类"></a>三、常见分类</h3><p>线性、区间、树形、数位等等。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图论笔记 24-02-18</title>
    <link href="/articles/Note-24-02-18/"/>
    <url>/articles/Note-24-02-18/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>删除树上一点，所形成的最大子树最小的那个点是树的重心。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(u,fa)&#123; <span class="hljs-comment">//若删除u，求最大子树大小</span><br>siz[u]=<span class="hljs-number">1</span>;<br>mx=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> v:son &#123;<br><span class="hljs-built_in">dfs</span>(v);<br>diz[u]+=siz[v];<br>siz[v]=<span class="hljs-built_in">max</span>(mx,siz[v]);<br>&#125;<br>mx=<span class="hljs-built_in">max</span>(mx,n-siz[u]);<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n)$。</p><hr><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1.树的重心如果不唯一，则至多有两个，且这两个重心相邻。<br>2.以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。<br>3.树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。<br>4.把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。<br>5.在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>() &#123;<br><span class="hljs-keyword">for</span> v:son &#123;<br>    求siz和mx;<br>&#125;<br>ans[u]=u;<br><span class="hljs-keyword">for</span> v:son &#123;<br>    重心向上跳<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">max</span>(mx[p], siz[u]-siz[p])&lt;=<span class="hljs-number">0.5</span>*siz[u]) &#123;<br>ans[u]=p;<br>&#125;<br><span class="hljs-keyword">else</span> p=fa[p];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CF685B <a href="https://www.luogu.com.cn/problem/solution/CF685B">题解</a></p><hr><h3 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h3><p>找到树的一个重心，则问题的解可以分为路径经过重心的解和路径不经过中心的解两部分。<br>1.路径经过重心的解：设重心为树根，用数据结构记录重心到每个节点的路径信息。从中取出根的不同子树中的路径信息组合起来即为路径经过重心的解。<br>2.路径不经过重心的解：将重心和其关联的边删除，将分割出来的每棵树递归处理即可求出路<br>径不经过重心的解。</p><hr><h3 id="树上长度为k的路径"><a href="#树上长度为k的路径" class="headerlink" title="树上长度为k的路径"></a>树上长度为k的路径</h3><p>Luogu P3806 P4149</p><p>设置两个桶<code>s1</code>，<code>s2</code>，下标为长度，存储有无。<br><code>s1</code>：之前子树到$u$点距离；<br><code>s2</code>：当前子树到$u$点距离。<br>处理完每一棵子树，从<code>s2</code>中向<code>s1</code>匹配，寻找距离和为$k$的路径。<br>然后将<code>s2</code>信息转移到<code>s1</code>中。<br>若几个子树都没找到，<code>vis[u]=1</code>，对接下来的根节点继续操作。</p><p>$f_i$存有无长度为$i$的路径，数值$0$或$1$。<br>$g_i$存长度为$i$的路径的最小边数。<br>$a_i$存子树中的路径长度，用于精准清空。<br>$vis_u$表示$u$是否作为重心被删除了。<br>$dis_v$表示从$u$到$v$的距离。<br>$q_i$结构体，存路径距离<code>dis</code>和边数<code>cnt</code>。</p><p>新的子树中，把每一个点到$u$的距离都算一遍，长度+边数。<br>遍历每一条边，凑到$k$后，更新答案<code>ans=min(ans, q[j].cnt+g[k-q[j].dis])</code>。<br>每一次更新完，信息放到桶里，继续下一个子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dfs</span>(u) &#123;<br><span class="hljs-keyword">for</span> v:son &#123;<br><span class="hljs-built_in">dfs</span>(dis[v]);<br><span class="hljs-keyword">for</span> v:路径 &#123;<br>ans=...<br>&#125;<br><span class="hljs-keyword">for</span> v:路径 &#123;<br>更新桶<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>; j&lt;路径个数; ++j) &#123;<br>f[a[j]]=<span class="hljs-number">0</span>, g[a[j]]=<span class="hljs-number">0</span>; <span class="hljs-comment">//精准清空，</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>求重心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//全局</span><br>weight <span class="hljs-comment">//重心作用大小</span><br>root <span class="hljs-comment">//重心位置</span><br><span class="hljs-built_in">dfsrt</span>() &#123;<br><span class="hljs-comment">//n-siz[u]换成weight-siz[u]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Luogu P3806 <a href="https://www.luogu.com.cn/problem/solution/P3806">题解</a><br>Luogu P4149 <a href="https://www.luogu.com.cn/problem/solution/P4149">题解</a></p><hr><h3 id="Luogu-P5306"><a href="#Luogu-P5306" class="headerlink" title="Luogu P5306"></a>Luogu P5306</h3><p>$w_i$：点前缀和，能提供的油量。<br>$d_i$：边前缀和，需要的油量。<br>$x$：到顶上后的剩余油量。<br>对于路径上的两个点$i,\ j$：<br>上行阶段满足$w_i-w_j\ge d_i-d_j$，变换得到$w_i-d_i\ge w_j-d_j$，记录沿途$max$值，记录存储于$s_1$。<br>下行阶段$x+w_{fa_j}\ge d_j$，变换得到$x+w_{fa_j}-d_j\ge0$，记录沿途$min$值，记录存储于$s_2$。<br>由于不知道会剩余多少，将所有$min$值求出扔到$s_2$后与$s_1$匹配，双指针。<br>Luogu P5306 <a href="https://www.luogu.com.cn/problem/solution/P3806">题解</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>随机化笔记 24-02-04</title>
    <link href="/articles/Note-24-02-04/"/>
    <url>/articles/Note-24-02-04/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>非正解思路<br>并且C*F不接受申诉和重测</p><hr><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>该拿到的分都拿到了，会出现“罚坐”现象。<br>随机化——多拿一点分<br>有的不是正解，只能拿一般分</p><hr><h3 id="瞎子爬山"><a href="#瞎子爬山" class="headerlink" title="瞎子爬山"></a>瞎子爬山</h3><p>单峰山，局部择优，深搜改进。<br>如果新方案更好就转移到新方案。</p><p>每一步爬多长？一开始步子大一点，越往后步子更小。<br>步长减小可以按比例减小，随机化更平缓一些。<br>当步长足够小的时候，可以结束算法。</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">climb</span><span class="hljs-params">()</span> </span>&#123;<br>node <span class="hljs-keyword">new</span>=<span class="hljs-built_in">rand</span>();<br><span class="hljs-type">int</span> flag=<span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> step=初始值, delta=<span class="hljs-number">0.985</span> <span class="hljs-comment">//delta belong to [0.985,0.999]</span><br><span class="hljs-keyword">while</span> (flag) &#123;<br>node best=<span class="hljs-keyword">new</span>;<br><span class="hljs-keyword">for</span> (每一个方向, f) &#123;<br>node nxt=<span class="hljs-built_in">walk</span>(now, f, step);<br>best=<span class="hljs-built_in">max</span>(best, nxt);<br>&#125;<br><span class="hljs-keyword">if</span> (best!=now) now=best, flag=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> flag=<span class="hljs-number">0</span>;<br>step*=delta;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, now);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="反例"><a href="#反例" class="headerlink" title="反例"></a>反例</h3><p>瞎子爬山爬到最优解就不会往前走了。多峰就不会找到最优解。</p><p>改进：<br>1.多个瞎子一起爬，或一个瞎子爬多次。<br>2.加一点随机性或突变。</p><hr><h3 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h3><p>灵感来源：中世纪铁匠打铁。<br>烧铁、很好延展性和韧性。<br>打铁，每一次形变很大，敲出大体形状。<br>低温，形变很小，适合制作更精细形状。</p><p>设置温度（步长），温度逐渐往下降，设置突变概率，找到最优解。到后期温度越低就很少遇到最劣解了。</p><p>如何选择合适突变概率$p$？<br>1.新状态与原状态差不太多，则应该有相对较大的概率跳过去。<br>2.越是退火的早期，越可能接受差的突变，越是退火的后期，越不能接受更差的改变。</p><p>温度$T$，新老状态差值为$\Delta E$，发生转移（修改最优解）概率为：<br>$$<br>P(\Delta E)&#x3D;<br>\begin{cases}<br>1,\ \text{新状态更优}\\<br>e^\frac{-\Delta E}{T},\ \text{新状态更劣}<br>\end{cases}<br>$$<br>$\Delta E$越大，越容易突变；$T$越大，越不容易突变。</p><p>初始温度$T_0$，降温系数$d&lt;1$，终止温度$T_k&gt;0$。<br>首先温度$T&#x3D;T_0$，每一次$T&#x3D;d\cdot T$，当$T&lt;T_k$时结束。</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simulate_anneal</span><span class="hljs-params">()</span> </span>&#123;<br>node now=<span class="hljs-built_in">rand</span>();<br><span class="hljs-type">double</span> T=<span class="hljs-number">1e5</span>, d=<span class="hljs-number">0.985</span>;<br><span class="hljs-keyword">while</span> (T&gt;<span class="hljs-number">1e-3</span>) &#123;<br>node nxt=<span class="hljs-built_in">Go</span>(now, 随机方向走一个距离);<br><span class="hljs-type">double</span> delta=<span class="hljs-built_in">del</span>(nxt, now);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">exp</span>(-delta/t)&gt;<span class="hljs-built_in">random</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)) now=nxt;<br>T*=d;<br>&#125;<br><span class="hljs-keyword">for</span> (若干次) ans=<span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">Go</span>(now, 随机方向走一个距离));<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="实战：最小圆覆盖"><a href="#实战：最小圆覆盖" class="headerlink" title="实战：最小圆覆盖"></a>实战：最小圆覆盖</h3><p>二维平面随机撒点，找半径最小的圆，使得所有$n$个点在圆内。问圆心坐标和半径。</p><p>思路：<br>找到圆心就可以$O(n)$算出来。<br>对圆心进行模拟退火，对每一个圆心找到最小半径。</p><p>每一次$x$和$y$随机走，计算最小半径（最大距离），乘上突变概率。</p><hr><h3 id="遗传算法（简化版）"><a href="#遗传算法（简化版）" class="headerlink" title="遗传算法（简化版）"></a>遗传算法（简化版）</h3><p>多个瞎子扔到山脉中，多个瞎子一起爬。</p><p>一群猪扔到岛上，如果猪没死完，会怎样？（生物角度）</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> 猪群() &#123;<br><span class="hljs-keyword">for</span> (每一个周期) &#123;<br><span class="hljs-number">1.</span>身体不好，无法适应环境的猪大概率挂掉。<br><span class="hljs-number">2.</span>活下来的猪们生出了一群小猪。<br><span class="hljs-number">2.1</span>.一部分小猪继承了父母的特点，<br>在这个基础上产生了微小变异。<br><span class="hljs-number">2.2</span>.一部分小猪继承了父母的特点，<br>在这个基础上产生了大量变异。<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>100代以后，肯定比第一批更适应岛上的环境的。</p><p>遗传算法：<br>1.一个样本容纳量，每一个个体自然繁衍多少后代、后代突变概率和方式。<br>2.适当调整模拟轮数及样本容纳量的关系，以取得较好效果。（经验）<br>小猪定型后，可以代数减少，样本更多。<br>没突变完，就需要减少样本量，增加代数。</p><p>伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> 遗传算法() &#123;<br><span class="hljs-type">int</span> limit=<span class="hljs-number">1000</span>, tot=limit; <span class="hljs-comment">//样本总量&amp;繁衍后的总样本</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=limit; ++i) a[i]=<span class="hljs-built_in">rand</span>(); <span class="hljs-comment">//随机生成样本</span><br><span class="hljs-keyword">for</span> (每一个周期) &#123;<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>, a+tot+<span class="hljs-number">1</span>, cmp);<br>tot=limit; <span class="hljs-comment">//保留优秀的</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=limit; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">10</span>; ++j) a[++tot]=<span class="hljs-built_in">born1</span>(a[i]); <span class="hljs-comment">//遗传</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=<span class="hljs-number">3</span>; ++j) a[++tot]=<span class="hljs-built_in">born2</span>(a[i]); <span class="hljs-comment">//变异</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=tot; ++i) ans=<span class="hljs-built_in">max</span>(ans, a[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p>问题：<br>某一个随机样本特别好，几轮后就会发现所有样本都是它的孩子。<br>一个高原&#x2F;一个山峰，山峰更高，生在高原上的小猪全部活下来，生在山脚下的小猪全死了。<br>解决方法：<br>给小猪编一个姓氏，每一个样本限制每个姓氏的个数，保证多样性。</p><hr><h3 id="什么情况"><a href="#什么情况" class="headerlink" title="什么情况"></a>什么情况</h3><p>什么情况适合基于概率的演化算法？<br>1.先找正解，罚坐的时候才可以用。<br>2.需要决策的状态空间较小，或者看起来最优解比较密集。<br>例如，最小圆覆盖只有$x$和$y$两个维度，或者看起来最优解分布比较密集。<br>3.没有绑定<code>subtask</code>或多组数据才行，可能会被卡每组最后一个数据。</p><hr><h3 id="实战：方差-NOIP2021-T3"><a href="#实战：方差-NOIP2021-T3" class="headerlink" title="实战：方差 NOIP2021 T3"></a>实战：方差 NOIP2021 T3</h3><p><a href="https://www.luogu.com.cn/problem/P7962">原题传送门</a><br>给定一个长度为$n$的非严格递增正整数序列。<br>你每次可以选择一个位置$1&lt;i&lt;n$，使得$a_i&#x3D;a_{i+1}+a_{i-1}-a_i$。<br>问：这个序列的方差最少是多少。</p><h4 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h4><p>完全随机，每次小概率大次数完成大概率。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 10005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7fffffff</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s, ss;<br><span class="hljs-type">int</span> b[N], a[N];<br>ll best=INF;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">simulation</span><span class="hljs-params">()</span> </span>&#123;<br>s=<span class="hljs-number">0</span>, ss=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) b[i]=a[i], s+=b[i], ss+=b[i]*b[i];<br>ll now=n*ss-s*s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> turn=<span class="hljs-number">1</span>; turn&lt;=<span class="hljs-number">30000</span>; ++turn) &#123;<br><span class="hljs-type">int</span> id=<span class="hljs-built_in">rand</span>()%(n<span class="hljs-number">-2</span>)+<span class="hljs-number">2</span>;<br>ll nxt=b[id<span class="hljs-number">-1</span>]+b[id+<span class="hljs-number">1</span>]-b[id];<br><span class="hljs-keyword">if</span> (nxt==b[id]) <span class="hljs-keyword">continue</span>;<br>ll t=s-b[id]+nxt, tt=ss-b[id]*b[id]+nxt*nxt;<br><span class="hljs-keyword">if</span> (now&gt;=n*tt-t*t || turn&lt;=<span class="hljs-number">2000</span>) &#123;<br>b[id]=nxt, s=t, ss=tt, now=n*tt-t*t, best=<span class="hljs-built_in">min</span>(best, now);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>n=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) a[i]=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">while</span> ((<span class="hljs-type">double</span>)<span class="hljs-built_in">clock</span>()/CLOCKS_PER_SEC&lt;<span class="hljs-number">0.99</span>) &#123; <span class="hljs-comment">//极限卡时</span><br><span class="hljs-built_in">simulation</span>();<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, best);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Luogu 72pts<br><a href="https://www.luogu.com.cn/record/146101887">评测记录</a></p><h4 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h4><p>当取得最优解后，查分数组一定先变小再变大，发现：<br>1.每次操作相当于交换了查分数组；<br>2.答案最小时，差分数组总会是单独的。<br>状态空间显著变小，只可能往左放或往右放。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> T=<span class="hljs-number">1000</span>; T&gt;<span class="hljs-number">1e-8</span>; T*=<span class="hljs-number">0.996</span>) &#123;<br><span class="hljs-type">int</span> p=<span class="hljs-built_in">rad</span>(<span class="hljs-number">2</span>,n<span class="hljs-number">-1</span>);<br>vis[p]^=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> t=<span class="hljs-built_in">calc</span>();<br>ans=<span class="hljs-built_in">min</span>(ans, t);<br><span class="hljs-keyword">if</span> ((<span class="hljs-built_in">exp</span>(<span class="hljs-number">1.0</span>*<span class="hljs-built_in">fabs</span>(ans-t)/T)&gt;=<span class="hljs-built_in">rad2</span>(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))) vis[p]^=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> now=t;<br>&#125;<br></code></pre></td></tr></table></figure><p>纯随机化可以拿到满分。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图论笔记 24-01-31</title>
    <link href="/articles/Note-24-01-31/"/>
    <url>/articles/Note-24-01-31/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h3><p>时间复杂度$O(m\times n)$。<br>两点之间最短路最多包含所有点。如果一个点出现两次，就走了环，非负环不划算，负环没有最短路。<br>包含$k$条边的最短路可以由最多包含$k-1$条边的最短路加一条边来获得,这个操作是“松弛”。<br>如果某一个点的最短路被更新了，这个点就有能力更新它所连接的点。<br>当所有边不满足$d_u+w&lt;d_v$时，最短路不会再改变了。每条边进行$n-1$遍“松弛”操作。<br>检查，如果有一条边还能松弛，则有负环。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) d[i]=INF;<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n<span class="hljs-number">-1</span>; ++i) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=m; ++j) &#123;<br>u=e[j].u, v=e[j].v, w=e[j].w;<br><span class="hljs-keyword">if</span> (d[i]&lt;INF) d[v]=<span class="hljs-built_in">min</span>(d[v], d[u]+w); <span class="hljs-comment">//松弛</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=m; ++i)<br><span class="hljs-keyword">if</span> (d[e[i].u]+w&lt;d[e[i].v]) ; <span class="hljs-comment">//存在负环</span><br></code></pre></td></tr></table></figure><hr><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>全称Shortest Path Faster Algorithm，于1994年被西安交通大学段凡丁发明。<br>$n\le10^5$，可以有负权，可以判断负环。<br>时间复杂度$O(k\times m)$，$k$一般小于$2$。</p><p>如果一个点没有被改变，再判断能否“松弛”，是没有意义的。只有它被更新了才检查，用这个优化。</p><p>建立一个队列，初始点s，将它所更新的点压入队列，不更新的不管它。做完了弹出，取出下一个点继续更新。当这个队列空了，就意味着没有可以更新的点了，结束。<br>一个点可能多次进入队列，只要被更新就进入队列。每个顶点进入队列不会超过$n$次，如果超过$n$次就意味着存在负环。</p><p>手写队列长度为$10\times n$，也可以用长度为$n+1$的循环队列，也可以用<code>STL::queue</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//队列</span><br><span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt)); <span class="hljs-comment">//进入队列次数</span><br><span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq)); <span class="hljs-comment">//标记是否在队列里面</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) d[i]=INF; <span class="hljs-comment">//最短路</span><br>d[s]=<span class="hljs-number">0</span>; <span class="hljs-comment">//起点距离为0</span><br>cnt[s]=<span class="hljs-number">1</span>; <span class="hljs-comment">//进入队列次数</span><br>q.<span class="hljs-built_in">push</span>(s); <span class="hljs-comment">//进入队列</span><br>inq[s]=<span class="hljs-number">1</span>; <span class="hljs-comment">//打标记</span><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取出点</span><br>q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//弹出</span><br>inq[u]=<span class="hljs-number">0</span>; <span class="hljs-comment">//取消标记</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=g[u]; i&gt;<span class="hljs-number">0</span>; i=e[i].next) &#123; <span class="hljs-comment">//遍历所连接的点</span><br><span class="hljs-type">int</span> v=e[i].v, w=e[i].w; <span class="hljs-comment">//改名，减少出错</span><br><span class="hljs-keyword">if</span> (d[u]+w&lt;d[v]) &#123; <span class="hljs-comment">//可以松弛</span><br>d[v]=d[u]+w; <span class="hljs-comment">//更新</span><br><span class="hljs-keyword">if</span> (!inq[v]) &#123; <span class="hljs-comment">//如果不在队列里面</span><br>q.<span class="hljs-built_in">push</span>(v); <span class="hljs-comment">//进入队列</span><br>inq[v]=<span class="hljs-number">1</span>; <span class="hljs-comment">//在队列里，打标记</span><br>cnt[v]++; <span class="hljs-comment">//进入队列次数+1</span><br><span class="hljs-keyword">if</span> (cnt[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//存在负环</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//没有负环</span><br>&#125;<br></code></pre></td></tr></table></figure><p>SLF优化：<br>Small Label Fiest策略<br>如果一个点被更新地很短，前面的就会被浪费。<br>如果点$v$被更新，队首为$t$，且$d_v$&lt;$d_t$，就把$v$放在队首。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; q;  <span class="hljs-comment">//队列</span><br><span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(s)); <span class="hljs-comment">//进入队列次数</span><br><span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq)); <span class="hljs-comment">//标记是否在队列里面</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i) d[i]=INF;  <span class="hljs-comment">//最短路</span><br>d[s]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//起点距离为0</span><br>cnt[s]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//进入队列次数</span><br>q.<span class="hljs-built_in">push_front</span>(s);  <span class="hljs-comment">//进入队列</span><br>inq[s]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//打标记</span><br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> u=q.<span class="hljs-built_in">front</span>();  <span class="hljs-comment">//取出点</span><br>q.<span class="hljs-built_in">pop_front</span>();  <span class="hljs-comment">//弹出</span><br>inq[u]=<span class="hljs-number">0</span>;  <span class="hljs-comment">//取消标记</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=g[u]; i&gt;<span class="hljs-number">0</span>; i=e[i].next) &#123;  <span class="hljs-comment">//遍历所连接的点</span><br><span class="hljs-type">int</span> v=e[i].v, w=e[i].w;  <span class="hljs-comment">//改名，减少出错</span><br><span class="hljs-keyword">if</span> (d[u]+w&lt;d[v]) &#123;  <span class="hljs-comment">//可以松弛</span><br>d[v]=d[u]+w;  <span class="hljs-comment">//更新</span><br><span class="hljs-keyword">if</span> (!inq[v]) &#123;  <span class="hljs-comment">//如果不在队列里面</span><br><span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>()&amp;&amp;d[v]&lt;=d[q.<span class="hljs-built_in">front</span>()]) q.<span class="hljs-built_in">push_front</span>(v);  <span class="hljs-comment">//如果比队首小，放前面</span><br><span class="hljs-keyword">else</span> q.<span class="hljs-built_in">push_back</span>(v);  <span class="hljs-comment">//如果挺大，放后面</span><br>inq[v]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//在队列里，打标记</span><br>cnt[v]++;  <span class="hljs-comment">//进入队列次数+1</span><br><span class="hljs-keyword">if</span> (cnt[v]&gt;n) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">//存在负环</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//没有负环</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于这个网站</title>
    <link href="/articles/About-This-Website/"/>
    <url>/articles/About-This-Website/</url>
    
    <content type="html"><![CDATA[<hr><p>Q: 这个网站是谁建的？<br>A: <a href="../About-Me">我</a>建的。</p><p>Q: 为什么文章很简单？<br>A: 我是蒟蒻。</p><p>Q: 为什么图片加载很慢？<br>A: 懒得配static，先将就着看吧。</p><p>Q: 为什么滑动时会抖动？<br>A: 标签栏做了毛玻璃特效。</p><p>Q: 为什么没有备案？<br>A: 因为注册者还没有满16岁。</p>]]></content>
    
    
    <categories>
      
      <category>介绍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图论笔记 24-01-30</title>
    <link href="/articles/Note-24-01-30/"/>
    <url>/articles/Note-24-01-30/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="应试"><a href="#应试" class="headerlink" title="应试"></a>应试</h3><p>考试中，图论数据量都是$10^5$量级的，所以用邻接表。<br>数组的定义记住估算一下空间，对数组大小有概念。<br>二维int数组最大开到$5000\times5000$<br>万不得已不要定义在主函数内。<br>规范变量命名。  </p><hr><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p><code>STL::memset</code><br>头文件<code>cstring</code><br>使用方法<code>memset(地址, 数值, 长度)</code><br>将<code>地址</code>的每一个字节填充<code>数值</code><br>最大值填充<code>0x3F</code>即可</p><hr><h3 id="多少条边"><a href="#多少条边" class="headerlink" title="多少条边"></a>多少条边</h3><p>有向图：<br>$C^2_n&#x3D;\frac{A^2_n}{A^2_2}&#x3D;\frac{n\times(n-1)}{2}$<br>无向图：<br>$A^2_n&#x3D;n\times(n-1)$</p><hr><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>空间复杂度$O(n^2)$，全部遍历时间复杂度$O(n^2)$</p><hr><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>稀疏图用，常考常用。<br>每一个点接的点在对应点后练成一个链，vector或数组模拟。<br>遍历全图时间复杂度$O(m)$</p><hr><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>集合的传递性：<br>$若A&gt;B，B&gt;C，则A&gt;C。$</p><p>最短路径 ：<br>$d[i][j]&#x3D;min(d[i][j],d[i][k]+d[k][j])$</p><p>最大边最小（最小生成树）：<br>$d[i][j]&#x3D;min(d[i][j],max(d[i][j],d[k][j]))$</p><hr><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆就是一棵完全二叉树，$n$个节点。</p><p>以小根堆为例，从上到下，从左到右编号，$a_i\le a_{2i}$，$a_i\le a_{2i+1}$，这个父亲节点小于左儿子，也小于右儿子。这一棵完全二叉树称为小根堆，最小值是$a_1$，查询时间复杂度$O(1)$。</p><p>每一次修改、插入或删除，变化以后还是满足小根堆。</p><p><strong>上浮操作</strong><br>先放在后面，不符合把儿子和父亲换一下，一层层检查交换，$a_i$与$a_{\frac{i}{2}}$比较。插入时间复杂度$O(\log n)$。修改同理。</p><p><strong>下沉操作</strong><br>删除就是把最后一个移到删除的数上，与下面的比较，不符合就交换。时间复杂度$O(\log n)$。</p><hr><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p><code>STL::priority_queue</code></p><p>在一个长度为$n$的序列中，可以完成两个操作：<br>1.询问最大值最小值<br>2.插入一个数</p><p>m次操作，时间复杂度$O(m\log n)$</p><hr><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>单源最短路算法：只有一个源点作为起点。<br>暴力$O(n^2)$<br>堆优化$O(m\log m)$<br>不能有负边存在</p><p>源点$s$<br>最短路$d_i$<br>标记数组$v_i$<br>初始条件$d_1&#x3D;0$，其余为$\infin$。</p><p>贪心思想<br>因为没有负边，所以已求点最短路不会再变化。<br>两个集合，已求点（白点）和未求点（蓝点）。</p><p>第一步：蓝点中找一个与白点距离最近的。<br>第二步：将这个点变为白点，用这个点更新蓝点距离。<br>$d_x+a_{x,y}$更新$d_y$，$x$为白点，$y$为蓝点。<br>第三步：重复，直到全部变成白点。</p><p>暴力代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i<span class="hljs-number">-1</span>; i&lt;=n; ++i) d[i]=INF;<br>d[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>（<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=n; ++i） &#123;<br><span class="hljs-type">int</span> x=<span class="hljs-number">-1</span>, mn=INF; <span class="hljs-comment">// x不设置初始值可能会RE</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j) &#123;<br><span class="hljs-keyword">if</span> (!vis[j] &amp;&amp; d[j]&lt;mn) mn=d[x=j];<br>&#125;<br><span class="hljs-keyword">if</span> (x==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 这一步可选，意味着图是断开的</span><br>vis[x]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>; j&lt;=n; ++j) &#123;<br><span class="hljs-keyword">if</span> (!vis[j]) d[j]=<span class="hljs-built_in">min</span>(d[j], d[x]+a[x][j]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种写法，一开始就把起点变成白点，并预处理好起点所连接的边，下一次$1$就不用找了。代码较为麻烦。</p><p>$d_i$也可以维护最大边和最短边。<br>最大边最小：$d_i&#x3D;min(d_i,\ max(d_j,\ a_{j,i}))$<br>最小边最大：$d_i&#x3D;max(d_i,\ min(d_j,\ a_{j,i}))$</p><p><a href="https://oi-wiki.org/graph/shortest-path/#%E5%AE%9E%E7%8E%B0_2">源码</a></p><hr><h3 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h3><p>它死了</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>元素周期表</title>
    <link href="/articles/Periodic-Table/"/>
    <url>/articles/Periodic-Table/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="原版"><a href="#原版" class="headerlink" title="原版"></a>原版</h3><p>摘自人教版化学必修一</p><img src="../../img/07-01.jpg" alt="07-01" style="zoom:50%;" /><hr><h3 id="注音"><a href="#注音" class="headerlink" title="注音"></a>注音</h3><table><thead><tr><th align="center">周期</th><th align="center">IA</th><th align="center">IIA</th><th align="center">IIIB</th><th align="center">IVB</th><th align="center">VB</th><th align="center">VIB</th><th align="center">VIIB</th><th align="center">VIII</th><th></th><th></th><th align="center">IB</th><th align="center">IIB</th><th align="center">IIIA</th><th align="center">IVA</th><th align="center">VA</th><th align="center">VIA</th><th align="center">VIIA</th><th align="center">0</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1 H<br />氢<br />qīng</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">2 He<br />氦<br />hài</td></tr><tr><td align="center">2</td><td align="center">3 Li<br />锂<br />lǐ</td><td align="center">4 Be<br />铍 pí</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center">5 B<br />硼<br />péng</td><td align="center">6 C<br />碳<br />tàn</td><td align="center">7 N<br />氮<br />dàn</td><td align="center">8 O<br />氧<br />yǎng</td><td align="center">9 F<br />氟<br />fú</td><td align="center">10 Ne<br />氖<br />nǎi</td></tr><tr><td align="center">3</td><td align="center">11 Na<br />钠<br />nà</td><td align="center">12 Mg<br />镁<br />m</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td></td><td align="center"></td><td align="center"></td><td align="center">13 Al<br />铝<br />lǚ</td><td align="center">14 Si<br />硅<br />guī</td><td align="center">15 P<br />磷<br />lín</td><td align="center">16 S<br />硫<br />liú</td><td align="center">17 Cl<br />氯<br />lǜ</td><td align="center">18 Ar<br />氩<br />yà</td></tr><tr><td align="center">4</td><td align="center">19 K<br />钾<br />jiǎ</td><td align="center">20 Ca<br />钙<br />gài</td><td align="center">21 Sc<br />钪<br />kàng</td><td align="center">22 Ti<br />钛<br />tài</td><td align="center">23 V<br />钒<br />fán</td><td align="center">24 Cr<br />铬<br />gè</td><td align="center">25 Mn<br />锰<br />měng</td><td align="center">26 Fe<br />铁<br />tiě</td><td>27 Co<br />钴<br />gǔ</td><td>28 Ni<br />镍<br />niè</td><td align="center">29 Cu<br />铜<br />tóng</td><td align="center">30 Zn<br />锌<br />xīn</td><td align="center">31 Ga<br />镓<br />jiā</td><td align="center">32 Ge<br />锗<br />zhě</td><td align="center">33 As<br />砷<br />shēn</td><td align="center">34 Se<br />硒<br />xī</td><td align="center">35 Br<br />溴<br />xiù</td><td align="center">36 Kr<br />氪<br />kè</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>化学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>加油卡 - 2023上海中考数学</title>
    <link href="/articles/Fuel-Card-SHMCEE-2023/"/>
    <url>/articles/Fuel-Card-SHMCEE-2023/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>“中国石化”推出促销活动，一张加油卡的面值是1000元，打九折出售。使用这张加油卡加油，每一升油，油的单价降低0.30元。假设这张加油卡的面值能够一次性全部用完。<br>(1) 他实际花了多少钱购买会员卡？<br>(2) 减价后每升油的单价为y元&#x2F;升，原价为x元&#x2F;升，求y关于x的函数解析式。（不用写出定义域）<br>(3) 油的原价是7.30元&#x2F;升，求优惠后油的单价比原价便宜多少元？</p><hr><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>(1) 900元<br>(2) y&#x3D;0.9x-0.27<br>(3) 1元</p><hr><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>(1) 由$1000\times\frac{9}{10}&#x3D;900$，易得他花了900元。</p><p>(2) 方法一：<br>由原价为$x$元&#x2F;升，可得在加油时实际油价为$(x-0.3)$元&#x2F;升。<br>由于加油卡面值为$1000$元，买完卡后可以以降价后的价钱加价值为$1000$元的油，所以一共可以加$\frac{1000}{x-0.3}$升油。<br>因为总共花了$900$元就买下了$1000$元的加油卡，根据每一升油的价格为总价除以体积，得出油价为$\frac{900}{\frac{1000}{x-0.3}}$元&#x2F;升，化简得$(0.9x-0.27)$元&#x2F;升。<br>故答案为$y&#x3D;0.9x-0.27$。</p><p>方法二：<br>既然$1000$元当成$900$元卖了，就理解为每升汽油的油价都打了九折。乘上先前的降价，即为$0.9\times(x-0.3)$元&#x2F;升，化简得$(0.9x-0.27)$元&#x2F;升。<br>故答案为$y&#x3D;0.9x-0.27$。</p><p>(3) 将$x&#x3D;7.3$代入原式，得$y&#x3D;6.3$，价格差为$7.3-6.3&#x3D;1$元。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h4><p>这道题重在理解题意。<br>第一小问是送分题，直接算折扣后的即可；第三小问代入作差即可。<br>难度在第二小问，需要辨析是$y&#x3D;0.9(x-0.3)$而不是$y&#x3D;0.9x-0.3$。可以通过“九折”的作用范围来理解，可以结合复合函数$u&#x3D;x-0.3$，$y&#x3D;0.9u$来理解，也可以通过上述严格证明来验证。</p><h4 id="争议与反思"><a href="#争议与反思" class="headerlink" title="争议与反思"></a>争议与反思</h4><p>好多人抱怨题目都看不懂，也有许多人质疑出题人的语言水平。<br>放在现在来看，这道题没有很严重的问题。当然这是站在全面分析的基础上，考场里自然没有时间做出详尽的证明过程，所以很多人确实理解不了“九折”到底打在哪里。<br>题目读不懂的原因也可能是生活经验不足。例如商店买东西打折时，没有认真计算过哪个划算，缺乏生活中解决实际数学问题的经验。</p><h4 id="出题方向"><a href="#出题方向" class="headerlink" title="出题方向"></a>出题方向</h4><p>这道题充分体现了上海中考的考试方向：实践应用、生活理解和思维贯通，同时也考验了考生的数学阅读理解能力。<br>这也是全国各省市的新中考考试方向。考生要应注意提升阅读速度和理解能力。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>数学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>等效电阻 例题</title>
    <link href="/articles/An-Example-of-Equivalent-Resistance/"/>
    <url>/articles/An-Example-of-Equivalent-Resistance/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是一道物理题，是初高衔接课材料里的题；老师却不讲，因为它严重超纲。<br>拍照搜题搜不到，于是我决定自己做。找寻答案的过程一波三折，很有参考价值。我把这道题的完整结题过程记录了下来，方便大家学习。<br>在此特别感谢<a href="https://wild-donkey.github.io/">硕硕</a>和学校物理老师们给予的帮助！</p><hr><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如图所示，所有电阻的阻值都等于$R$，求A、B间的等效电阻。<br><img src="../../img/05-01.jpg" alt="05-01" style="zoom:50%;" /><br>注意：中间没有连接，注意观察圆点。</p><hr><h3 id="思路过程"><a href="#思路过程" class="headerlink" title="思路过程"></a>思路过程</h3><p>特别说明：以下三个思路都是<strong>错的</strong>，请移步<strong>正解</strong>找寻答案，这里只是简单说明思路过程。<br>变量命名不标准，没有按照题目要求，请见谅。</p><h4 id="错误解法1-Dijkstra"><a href="#错误解法1-Dijkstra" class="headerlink" title="错误解法1 - Dijkstra"></a>错误解法1 - Dijkstra</h4><p>思路来自<a href="https://codeforces.com/profile/__Algo_3F__">__Algo_3F__</a>。<br><img src="../../img/05-02.jpg" alt="05-02" style="zoom:25%;" /><br>显然，这个答案小于$R$，因为有电流通过上面的电路中。</p><h4 id="错误解法2-节点法"><a href="#错误解法2-节点法" class="headerlink" title="错误解法2 - 节点法"></a>错误解法2 - 节点法</h4><p>首先，我先用节点法尝试了一下。<br>标记电势，考虑到已经有了A、B，使用小写字母代替，电势由高到低分别标记为$a\rightarrow b\rightarrow c\rightarrow d$。<br><img src="../../img/05-03.jpg" alt="05-03" style="zoom:50%;" /><br>不难发现，此时电路变为了三段并联。其中，$a\rightarrow d$先并联了一个单独的电阻，然后$a\rightarrow b$中有两个电阻，$b\rightarrow c$中有三个电阻，$c\rightarrow d$中有两个电阻。<br>那答案就迎刃而解了，ab段电阻$\frac{1}{2}R$，bc段电阻$\frac{1}{3}R$，cd段电阻$\frac{1}{2}R$，ad两个支路分别为$\frac{4}{3}R$和$R$，并起来一共$\frac{4}{7}R$。<br>显然，这道题不是这么简单的。注意看，在刚才的过程中，我们将所有连接b、c两个电势的都视作了并联，但事实上在中间交叉的电阻中，中间交点并不与其他等电势的地方相接。倒回去，如果按照这个思路，电路图应该如下图所示，其中颜色与上图对应。<br><img src="../../img/05-04.jpg" alt="05-04" style="zoom:50%;" /><br>我们无法证明这种方法的正确性，因为这种方法多连了两根导线，把电阻扯到一边去了，相当于分摊了电流。因此这个答案不一定是正确的。经过后续计算得知，这种方法是错误的。</p><h4 id="错误解法3-对称性"><a href="#错误解法3-对称性" class="headerlink" title="错误解法3 - 对称性"></a>错误解法3 - 对称性</h4><p>接下来尝试化简电路，化简结果如下，其中最中间奇怪方式连接的电阻是原图中最上面的与AB平行的电阻。<br><img src="../../img/05-05.jpg" alt="05-05" style="zoom:75%;" /><br>然后就没有然后了，接下来问的硕硕才知道解法。<br>显然，最上面的电阻是并联进去的，所以先不考虑，先把下面复杂的单独拆出来。根据对称性，上下两个支路电流相等，所以设总电流为$I$，则每条支路的电流都为$\frac{I}{2}$，如图所示。<br><img src="../../img/05-06.jpg" alt="05-06" style="zoom:75%;" /><br>因为每个电阻是相等的，设每个电阻为$r$，总电阻为$R$。设总电压为$U$，根据对称性设左上和右下电阻为$r$，则左下右上电阻为$2r$，因为电流相等，电阻为二倍，所以电压为二倍。<br>这样列出等量关系式$U&#x3D;3u$，$r&#x3D;\frac{u}{\frac{I}{2}}&#x3D;\frac{2u}{I}$，$R&#x3D;\frac{U}{I}&#x3D;\frac{3u}{I}&#x3D;\frac{3}{2}\times\frac{2u}{I}&#x3D;\frac{3}{2}r$<br>所以这段电路的总电阻是单个电阻的$\frac{3}{2}$倍，和之前单拎的电阻并联起来就是$\frac{1}{\frac{2}{3r}+\frac{1}{r}}&#x3D;\frac{3}{5}r$<br>就这么结束了，我和硕硕都觉得这是个完美的解法。然而我们忽略了一个关键点：没考虑中间电阻，即没考虑标蓝的电流。这个电流的加入会导致左上、右下电流增加，导致电压不为二倍。<br><img src="../../img/05-07.jpg" alt="05-07" style="zoom:25%;" /></p><h4 id="错误解法4-等电流"><a href="#错误解法4-等电流" class="headerlink" title="错误解法4 - 等电流"></a>错误解法4 - 等电流</h4><p>按照分电流的思路继续往前走，我们发现在这个复杂电路中共有三条电流，如图是这三条电流分别途径的电路。<br><img src="../../img/05-08.jpg" alt="05-08" style="zoom:50%;" /><br><img src="../../img/05-09.jpg" alt="05-09" style="zoom:50%;" /><br><img src="../../img/05-10.jpg" alt="05-10" style="zoom:50%;" /><br>不难看出，这三条电路的电阻相等，电压相等都等于电源电压，所以电流也相等，相当于三个等流并联，得到这部分电阻为$R$，再并上单个的电阻，总电阻为$\frac{1}{2}R$。<br>很简单，很直接，但这个思路是错的。硕硕说欧姆定律的应用条件是闭合电路，但这个电路不闭合，所以不能推出等流这一结论。</p><hr><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>正解由硕硕提供，我整理的过程稍微有些不规范。<br>思路：列方程求出中间电流，进而求出总电流和总电压的关系。</p><p>首先考虑下面复杂电路的电阻，将直接连接$AB$的电阻分开，剩下电路化简如下。<br><img src="../../img/05-11.jpg" alt="05-11" style="zoom:75%;" /><br>设这部分电路总电压为$U$，通过$R_1$的电流为$I$，通过$R_0$的电流为$i$，$R_1$两端电压为$u$。<br>由对称性可得，$I_{R_2}&#x3D;I$，$U_{R_2}&#x3D;u$。<br>因为$R_0$与$R_5$、$R_6$一起分走$R_1$电流，所以$I_{R_5}&#x3D;I_{R_6}&#x3D;I_{R_1}-I_{R_0}&#x3D;I-i$。$I_{R_3}$、$I_{R_4}$由对称性也可得。故该段电路总电流$I_{sum}&#x3D;I_{R_1}+I_{R_3}&#x3D;2I-i$<br>因为$R_1$、$R_5$和$R_6$构成串联，所以$U_{R_5}+U_{R_6}&#x3D;U-U_{R_1}&#x3D;U-u$。因为$R_5&#x3D;R_6$，根据正比分压可得$U_5&#x3D;U_6&#x3D;\frac{U-u}{2}$。$U_{R_3}$、$U_{R_4}$由对称性也可得。<br>因为$R_1$、$R_0$和$R_2$构成串联，所以$U_{R_0}&#x3D;U-U_{R_1}-U_{R_2}&#x3D;U-2u$。</p><p>由此，所有电阻的电流电压均已得，故可求电阻：<br>$U_{R_0}&#x3D;U-2u,\ I_{R_0}&#x3D;i,\ R_0&#x3D;\frac{U-2u}{i}$<br>$U_{R_1}&#x3D;u,\ I_{R_1}&#x3D;I,\ R_1&#x3D;\frac{u}{I}$<br>$U_{R_2}&#x3D;u,\ I_{R_2}&#x3D;I,\ R_2&#x3D;\frac{u}{I}$<br>$U_{R_3}&#x3D;\frac{U-u}{2},\ I_{R_3}&#x3D;I-i,\ R_3&#x3D;\frac{U-u}{2I-2i}$<br>$U_{R_4}&#x3D;\frac{U-u}{2},\ I_{R_4}&#x3D;I-i,\ R_4&#x3D;\frac{U-u}{2I-2i}$<br>$U_{R_5}&#x3D;\frac{U-u}{2},\ I_{R_5}&#x3D;I-i,\ R_5&#x3D;\frac{U-u}{2I-2i}$<br>$U_{R_6}&#x3D;\frac{U-u}{2},\ I_{R_6}&#x3D;I-i,\ R_6&#x3D;\frac{U-u}{2I-2i}$<br>$U_{sum}&#x3D;U,\ I_{sum}&#x3D;2I-i,\ R_{sum}&#x3D;\frac{U}{2I-i}$</p><p>因为每个电阻都相等，得$R_0&#x3D;R_1&#x3D;R_3$，即$\frac{U-2u}{i}&#x3D;\frac{u}{I}&#x3D;\frac{U-u}{2I-2i}$，解得$i&#x3D;\frac{1}{3}I$。将其代入，得$\frac{U-2u}{i}&#x3D;\frac{u}{3i}&#x3D;\frac{U-u}{4i}$，解得$U&#x3D;\frac{7}{3}u$<br>$R_{sum}&#x3D;\frac{U}{2I-i}&#x3D;\frac{\frac{7}{3}u}{\frac{5}{3}I}&#x3D;\frac{7}{5}\times\frac{u}{I}&#x3D;\frac{7}{5}R_2&#x3D;\frac{7}{5}R$<br>故这段电路的总电阻为$\frac{7}{5}R$，再与原先阻值为$R$的电阻并联，得到$\frac{1}{\frac{5}{7R}+\frac{1}{R}}&#x3D;\frac{7}{12}R$<br>故答案为$\frac{7}{12}R$</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>硕硕的一句话足以概括<br><img src="../../img/05-12.jpg" alt="05-12" style="zoom:25%;" /></p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>结束了，题做出来了。<br>硕硕说，这个题目很有意思，让他想起了中学物理的知识。<br>我觉得这个题目挺难的，但有意思的地方在解题思路上。一次一次的错误，一次一次的改正。如果这个题给我在考试里做，我可能直接就放弃了，也不会这么曲折地做出来。当然最终找到答案也是十分开心的。</p><p>最后硕硕提出用模拟软件校验一下，相差不大，所以这个答案应该是对的。<br>如果你认为这个答案不对，欢迎指出，万一这个答案也是错误的呢？也许这个思路也会成错误解法之一。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>物理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>你被骗了</title>
    <link href="/articles/You-Have-Been-Cheated/"/>
    <url>/articles/You-Have-Been-Cheated/</url>
    
    <content type="html"><![CDATA[<hr><p><a href="https://www.luogu.com.cn/paste/8cg3cbrq">你确实被骗了</a></p>]]></content>
    
    
    <categories>
      
      <category>趣闻</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>海水制盐</title>
    <link href="/articles/Salt-Production-from-Seawater/"/>
    <url>/articles/Salt-Production-from-Seawater/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="一、晾晒粗盐"><a href="#一、晾晒粗盐" class="headerlink" title="一、晾晒粗盐"></a>一、晾晒粗盐</h3><h4 id="1-蒸发池"><a href="#1-蒸发池" class="headerlink" title="1. 蒸发池"></a>1. 蒸发池</h4><p>海水在蒸发池中借助光能和风能蒸发出大量水分，这个过程要持续几天。<br>在这个过程中，$NaCl$或恰为或接近饱和状态。</p><h4 id="2-结晶池"><a href="#2-结晶池" class="headerlink" title="2. 结晶池"></a>2. 结晶池</h4><p>浓海水进入这里，继续晾晒蒸发，待底部出现大量$NaCl$结晶后停止。<br>在这个过程中，浓海水被分为粗盐和母液。<br>粗盐中的主要成分是$NaCl$，混有少量$Na_2SO_4$、$CaCl_2$和$MgCl_2$等杂质。<br>母液又称盐卤、苦卤，是$NaCl$的饱和溶液，也是化学工业的重要原料。</p><hr><h3 id="二、粗盐精制"><a href="#二、粗盐精制" class="headerlink" title="二、粗盐精制"></a>二、粗盐精制</h3><p>粗盐溶液中含有$H_2O$、泥沙、$Na^+$、$Cl^-$、$SO_4^{2-}$、$Ca^{2+}$、$Mg^{2+}$及其他杂质。<br>在精制中，主要考虑去除泥沙、钙镁离子和硫酸根。</p><h4 id="第一步：去除泥沙等难溶性杂质"><a href="#第一步：去除泥沙等难溶性杂质" class="headerlink" title="第一步：去除泥沙等难溶性杂质"></a>第一步：去除泥沙等难溶性杂质</h4><p>过滤即可，实验室操作中注意玻璃棒引流。</p><h4 id="第二步：去除-Mg-2-离子"><a href="#第二步：去除-Mg-2-离子" class="headerlink" title="第二步：去除$Mg^{2+}$离子"></a>第二步：去除$Mg^{2+}$离子</h4><p>向溶液中加入$NaOH$<br>要求：过量<br>化学方程式：$MgCl_2+2NaOH\xlongequal{\hspace{1cm}}Mg(OH)_2\downarrow+2NaCl$<br>离子方程式：$Mg^{2+}+2OH^-\xlongequal{\hspace{1cm}}Mg(OH)_2\downarrow$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$、$Na_2SO_4$、$CaCl_2$、$NaOH$<br>剩余离子：$Na^+$、$Cl^-$、$SO_4^{2+}$、$Ca^{2+}$、$OH^-$<br>剩余沉淀：$Mg(OH)_2$<br>注：不建议换成$Ca(OH)_2$，首先是溶解度小，其次是引进了更多的$Ca^{2+}$，导致第四步需要加入更多的$Na_2CO_3$</p><h4 id="第三步：去除-SO-4-2-离子"><a href="#第三步：去除-SO-4-2-离子" class="headerlink" title="第三步：去除$SO_4^{2-}$离子"></a>第三步：去除$SO_4^{2-}$离子</h4><p>向溶液中加入$BaCl_2$<br>要求：过量<br>化学方程式：$Na_2SO_4+BaCl_2\xlongequal{\hspace{1cm}}BaSO_4\downarrow+2NaCl$<br>离子方程式：$SO_4^{2-}+Ba^{2+}\xlongequal{\hspace{1cm}}BaSO_4\downarrow$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$、$CaCl_2$、$NaOH$、$BaCl_2$<br>剩余离子：$Na^+$、$Cl^-$、$Ca^{2+}$、$OH^-$、$Ba^{2+}$<br>剩余沉淀：$Mg(OH)_2$、$BaSO_4$</p><h4 id="第四步：去除-Ca-2-和-Ba-2-离子"><a href="#第四步：去除-Ca-2-和-Ba-2-离子" class="headerlink" title="第四步：去除$Ca^{2+}$和$Ba^{2+}$离子"></a>第四步：去除$Ca^{2+}$和$Ba^{2+}$离子</h4><p>向溶液中加入$Na_2CO_3$<br>要求：过量<br>化学方程式：$CaCl_2+Na_2CO_3\xlongequal{\hspace{1.5cm}}CaCO_3\downarrow+2NaCl$<br>                       $BaCl_2+Na_3CO_3\xlongequal{\hspace{1.5cm}}BaCO_3\downarrow+2NaCl$<br>离子方程式：$Ca^{2+}+CO_3^{2-}\xlongequal{\hspace{1.5cm}}CaCO_3\downarrow$<br>                       $Ba^{2+}+CO_3^{2-}\xlongequal{\hspace{1.5cm}}BaCO_3\downarrow$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$、$NaOH$、$Na_2CO_3$<br>剩余离子：$Na^+$、$Cl^-$、$OH^-$、$CO_3^{2+}$<br>剩余沉淀：$Mg(OH)_2$、$BaSO_4$、$CaCO_3$、$BaCO_3$</p><h4 id="第五步：去除沉淀"><a href="#第五步：去除沉淀" class="headerlink" title="第五步：去除沉淀"></a>第五步：去除沉淀</h4><p>过滤即可，实验室操作中注意玻璃棒引流<br>剩余溶质：$NaCl$、$NaOH$、$Na_2CO_3$<br>剩余离子：$Na^+$、$Cl^-$、$OH^-$、$CO_3^{2+}$<br>注：如果这一步不进行，$CaCO_3$和$BaCO_3$沉淀将与第六步加入的$HCl$反应，重新生成$CaCl_2$和$BaCl_2$</p><h4 id="第六步：去除-OH-和-CO-3-2-离子"><a href="#第六步：去除-OH-和-CO-3-2-离子" class="headerlink" title="第六步：去除$OH^-$和$CO_3^{2+}$离子"></a>第六步：去除$OH^-$和$CO_3^{2+}$离子</h4><p>向溶液中加入$HCl$<br>要求：适量加入，直到恰好不再产生气体为止，也可用PH试纸反复测定直到7时停止<br>化学方程式：$NaOH+HCl\xlongequal{\hspace{1.5cm}}NaCl+H_2O$<br>                       $Na_2CO_3+2HCl\xlongequal{\hspace{1.5cm}}2NaCl+CO_2\uparrow+H_2O$<br>离子方程式：$OH^-+H^+\xlongequal{\hspace{1.5cm}}H_2O$<br>                       $CO_3^{2-}+2H^+\xlongequal{\hspace{1.5cm}}Ca^{2+}+CO_2\uparrow+H_2O$<br>反应类型：复分解反应<br>剩余溶质：$NaCl$<br>剩余离子：$Na^+$、$Cl^-$<br>注：过量$HCl$不会产生影响，会在第七步蒸发掉，生成$HCl$气体</p><h4 id="第七步：蒸发结晶"><a href="#第七步：蒸发结晶" class="headerlink" title="第七步：蒸发结晶"></a>第七步：蒸发结晶</h4><p>晾晒即可，实验室用蒸发皿和酒精灯时注意玻璃棒搅拌，有大量固体时停止加热</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>物理变化：晒制粗盐、过滤难溶性杂质、蒸发结晶等。<br>化学变化：去除钙镁离子及硫酸根时用加入物质的方法生成沉淀。<br>重要考点：复分解反应，实质是离子结合生成沉淀、气体和水的过程。<br>注：$NaOH$的加入顺序可调整，只要在$HCl$前就可以，但其他顺序不可调整。</p><p>化学老师说过，化学的作用就是：“想要的东西创造出来，不想要的东西给消灭掉。”粗盐精制正是这句话的完美体现。</p><p>什么？你想下载这篇文章？<a href="https://wenku.baidu.com/view/0f446d9e17791711cc7931b765ce05087632758f.html">打钱</a>！</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>化学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>山大辅仁学校2021级6班趣闻</title>
    <link href="/articles/Anecdotes-from-Class-6/"/>
    <url>/articles/Anecdotes-from-Class-6/</url>
    
    <content type="html"><![CDATA[<hr><h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>本篇文章由<a href="/2023/12/02/About-Me">gtr</a>汇总整理，记录了九上学习中的趣闻。如有问题请<a href="/about">联系我</a>删除。<br>山大辅仁2021级6班共37人，班主任Ma Sun，副班主任Ch Guo。<br>许多科目都换了老师QWQ，这里先只说九上的事。</p><hr><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>老师：<br>$\begin{array}{|c|c|}<br>\hline\text{教授科目}&amp;\text{文中代名}\\<br>\hline\text{语文}&amp;\text{Ch Guo}\\<br>\hline\text{数学}&amp;\text{Ma Sun}\\<br>\hline\text{英语}&amp;\text{En Zhang}\\<br>\hline\text{物理}&amp;\text{Ph Yang}\\<br>\hline\text{化学}&amp;\text{Ch Yang}\\<br>\hline\text{信息}&amp;\text{IT Ji}\\<br>\hline\text{体育}&amp;\text{Ph Zhang}\\<br>\hline\text{历史}&amp;\text{Hi Wang}\\<br>\hline\end{array}$</p><p>学生：<br>文中为姓名首字母。</p><hr><h4 id="23-09-04-扫雷失败"><a href="#23-09-04-扫雷失败" class="headerlink" title="23&#x2F;09&#x2F;04 扫雷失败"></a>23&#x2F;09&#x2F;04 扫雷失败</h4><p>gtr: 我们偷偷把麦斯拿回家做吧。<br>qsy: 把麦斯炸了。</p><blockquote><p>麦斯扫雷，学校发的数学题，九上不让带回家也不让提前做。</p></blockquote><hr><h4 id="23-09-05-奖罚易主"><a href="#23-09-05-奖罚易主" class="headerlink" title="23&#x2F;09&#x2F;05 奖罚易主"></a>23&#x2F;09&#x2F;05 奖罚易主</h4><p>En Zhang: 最近lcl，zyzx的作业做得不错，提出表扬。<br>En Zhang: lyc，gtr过来一下。</p><blockquote><p>这二位默写没写课文原词，被警告。</p></blockquote><hr><h4 id="23-09-07-证在心里"><a href="#23-09-07-证在心里" class="headerlink" title="23&#x2F;09&#x2F;07 证在心里"></a>23&#x2F;09&#x2F;07 证在心里</h4><p>Ma Sun: 都记下来了吗？你写了吗？<br>zyzx: 写了。<br>Ma Sun: 写哪了？<br>zyzx: 这里。<br>Ma Sun: 证明过程呢？在哪？<br>zyzx: 证在心里了。</p><hr><h4 id="23-09-13-下酒题"><a href="#23-09-13-下酒题" class="headerlink" title="23&#x2F;09&#x2F;13 下酒题"></a>23&#x2F;09&#x2F;13 下酒题</h4><p>Ma Sun: ljq干啥呢，怎么还做题呢？<br>ljq: 看看。<br>Ma Sun: 人家吃下酒菜，你是下酒题吧，吃饭。</p><hr><h4 id="23-09-18-地理75足矣"><a href="#23-09-18-地理75足矣" class="headerlink" title="23&#x2F;09&#x2F;18 地理75足矣"></a>23&#x2F;09&#x2F;18 地理75足矣</h4><blockquote><p>校内初高衔接小测，教室后面发现一张计划表。<br>$\begin{array}{|c|c|c|c|}<br>\hline语文&amp;12*&amp;数学&amp;145\\<br>\hline英语&amp;14*&amp;地理&amp;75\\<br>\hline生物&amp;98&amp;历史&amp;98\\<br>\hline道法&amp;100&amp;\cdots&amp;\cdots\\<br>\hline\end{array}$</p></blockquote><hr><h4 id="23-09-26-爆装备了"><a href="#23-09-26-爆装备了" class="headerlink" title="23&#x2F;09&#x2F;26 爆装备了"></a>23&#x2F;09&#x2F;26 爆装备了</h4><p>ljq: 爆装备了，四个金币。  </p><blockquote><p>体育课，操场上四个卫生纸团。</p></blockquote><hr><h4 id="23-10-03-就不加"><a href="#23-10-03-就不加" class="headerlink" title="23&#x2F;10&#x2F;03 就不加"></a>23&#x2F;10&#x2F;03 就不加</h4><p>tmc: 所以说，是无水硫酸铜，还是五水硫酸铜？<br>gtr: 加个“合”就可以了，五水合硫酸铜。<br>tmc: 就不加。</p><hr><h4 id="23-10-07-可以食言"><a href="#23-10-07-可以食言" class="headerlink" title="23&#x2F;10&#x2F;07 可以食言"></a>23&#x2F;10&#x2F;07 可以食言</h4><p>gtr: 不是说跑两圈吗，怎么食言了？<br>zyzx: 当然可以食言了，盐已经被英语老师听写完了。</p><blockquote><p>早读刚听写完单词salty。</p></blockquote><hr><h4 id="23-10-09-发芽了"><a href="#23-10-09-发芽了" class="headerlink" title="23&#x2F;10&#x2F;09 发芽了"></a>23&#x2F;10&#x2F;09 发芽了</h4><p>Ma Sun: 就你们两个组没浇水，怎么还没发芽？<br>wzh: 老师，其实发芽了，只不过没浇水干死了。</p><hr><h4 id="23-10-09-你们活该"><a href="#23-10-09-你们活该" class="headerlink" title="23&#x2F;10&#x2F;09 你们活该"></a>23&#x2F;10&#x2F;09 你们活该</h4><p>Ma Sun: 昨天月考，我们班有同学作弊，这里不说是谁了，ta应该自己知道。……那位同学，猜到了，算你们赢；猜不到，你们活该。</p><hr><h4 id="23-10-10-调戏"><a href="#23-10-10-调戏" class="headerlink" title="23&#x2F;10&#x2F;10 调戏"></a>23&#x2F;10&#x2F;10 调戏</h4><p>Ch Guo: wcy，你来概括一下拳打镇关西。<br>wcy: ……第二天鲁智深调戏了镇关西。</p><blockquote><p>应该是第二天鲁智深捉弄了镇关西一番，然后痛打镇关西三拳，拳拳正中要害，镇关西一命呜呼。</p></blockquote><hr><h4 id="23-10-11-废话"><a href="#23-10-11-废话" class="headerlink" title="23&#x2F;10&#x2F;11 废话"></a>23&#x2F;10&#x2F;11 废话</h4><p>En Zhang: “talk to”和”talk with”有什么区别啊，hyx？<br>hyx: 一个后面是”to”，一个后面是”with”。<br>En Zhang: 你这不废话吗。</p><hr><h4 id="23-10-27-超导体"><a href="#23-10-27-超导体" class="headerlink" title="23&#x2F;10&#x2F;27 超导体"></a>23&#x2F;10&#x2F;27 超导体</h4><p>Ph Yang: 好，根据$R&#x3D;\frac{U}{I}$，我说，电阻和电压成正比，电阻和电流成反比，对不对？<br>class: 不对。<br>Ph Yang: 电阻跟什么有关？<br>class: 长度，横截面积，材料，温度。<br>Ph Yang: 那电阻和电流有没有关系？<br>class: 没有。<br>Ph Yang: 和电压有没有关系？<br>class: 没有。<br>Ph Yang: 电压为零，电流为零，导体有没有电阻？<br>class: 没有。<br>Ph Yang: 那你们自己通电了吗？照你们这么说你们都没有电阻，早就被抓去做实验去了。</p><blockquote><p>惯性思维，导致全班下意识喊出“没有”。</p></blockquote><hr><h4 id="23-10-30-统统扔掉"><a href="#23-10-30-统统扔掉" class="headerlink" title="23&#x2F;10&#x2F;30 统统扔掉"></a>23&#x2F;10&#x2F;30 统统扔掉</h4><p>gtr: 这两个U盘分不清了，一个是Ch Guo的，一个是En Zhang的。<br>qsy: 管它呢，全给它扔垃圾桶里。</p><hr><h4 id="23-10-30-诶嘿，忘啦！"><a href="#23-10-30-诶嘿，忘啦！" class="headerlink" title="23&#x2F;10&#x2F;30 诶嘿，忘啦！"></a>23&#x2F;10&#x2F;30 诶嘿，忘啦！</h4><hr><h4 id="23-10-31-极限摸鱼"><a href="#23-10-31-极限摸鱼" class="headerlink" title="23&#x2F;10&#x2F;31 极限摸鱼"></a>23&#x2F;10&#x2F;31 极限摸鱼</h4><p>lyc: 就这半个足球场，我八步就跳过去了。</p><blockquote><p>体育课力量练习，我们需要蛙跳跳过半个足球场，lyc他们的策略是跳出老师视线之后跑到终点。</p></blockquote><hr><h4 id="23-11-02-上天的旨意"><a href="#23-11-02-上天的旨意" class="headerlink" title="23&#x2F;11&#x2F;02 上天的旨意"></a>23&#x2F;11&#x2F;02 上天的旨意</h4><p>lyc: 随机抽学号上来分享。来，ljq。<br>ljq: 不是抽学号吗？<br>lyc: 好，抽学号。$\small\textcolor{darkgrey}{随后找到音频，划了一下。}$来，16号。<br>ljq: $\small\textcolor{darkgrey}{拿着lyc的思维导图上台分享。}$</p><blockquote><p>语文现代文答题思路结构化展示，Ch Guo指定lyc安排。<br>我们班取随机数最朴素的方法是取一个较长的音频，随机划一下，二位秒数就是取的随机数。这个方法由gtr提议。虽然后来用了gtr写的随机数代码，但换了教室后就没再拷过来。</p></blockquote><hr><h4 id="23-11-03-复活点"><a href="#23-11-03-复活点" class="headerlink" title="23&#x2F;11&#x2F;03 复活点"></a>23&#x2F;11&#x2F;03 复活点</h4><p>lyc: 到复活点了，因为上一圈被刷下去的这一圈会在这里复活。</p><blockquote><p>每天四圈环校跑，上午下午各两圈，每圈1000米。<br>校门口有大上坡，第一圈体力不支的会选择停下，躲在树后面，等队伍套圈后再出来继续跟队跑。</p></blockquote><hr><h4 id="23-11-06-有理有据"><a href="#23-11-06-有理有据" class="headerlink" title="23&#x2F;11&#x2F;06 有理有据"></a>23&#x2F;11&#x2F;06 有理有据</h4><p>Ch Yang: 你要灭火，首先要干啥？<br>class: 要有火。</p><blockquote><p>化学课，学习燃烧条件。</p></blockquote><hr><h4 id="23-11-09-记仇的monitor"><a href="#23-11-09-记仇的monitor" class="headerlink" title="23&#x2F;11&#x2F;09 记仇的monitor"></a>23&#x2F;11&#x2F;09 记仇的monitor</h4><p>Ma Sun: 说一件事，lyc今天早上被抓到没按地方下车。下次不允许了。</p><p>zsh: 怎么回事？<br>lyc: 怎么了？<br>zsh: $\small\textcolor{darkgrey}{沉重语气：}$怎么没按地方下车？<br>class: $\small\textcolor{darkgrey}{Laughed.}$<br>lyc: 安静安静。<br>zsh: $\small\textcolor{darkgrey}{细声：}$Monitor~ Monitor~<br>class: $\small\textcolor{darkgrey}{Laughed.}$<br>lyc: 安静！再笑的记名字了！</p><p>zsh: 班长可以去接水吗？<br>lyc: 回位坐着去，你是闲的还是闲的还是闲的还是闲的啊？</p><blockquote><p>Ma Sun前天刚刚强调了校门口家长接送下车位置，lyc家长忘了，导致被抓住记了名。<br>Monitor这个外号来自一次英语公开课，中文意思是班长。当时全班基本上没有人愿意举手回答问题，所以老师只能问：”Who would like to share your opinion? … Monitor, please stand up and answer my question.”</p></blockquote><hr><h4 id="23-11-11-新型伸展跳"><a href="#23-11-11-新型伸展跳" class="headerlink" title="23&#x2F;11&#x2F;11 新型伸展跳"></a>23&#x2F;11&#x2F;11 新型伸展跳</h4><p>Ph Zhang: 怎么跳呢，跟蛤蟆似的。</p><blockquote><p>伸展跳，lyc没伸展开，双手和膝盖弯曲。</p></blockquote><hr><h4 id="23-11-16-亮了，亮了"><a href="#23-11-16-亮了，亮了" class="headerlink" title="23&#x2F;11&#x2F;16 亮了，亮了"></a>23&#x2F;11&#x2F;16 亮了，亮了</h4><p>zlj: 闭合开关$S_1$和$S_2$时，灯泡亮，电铃也亮。</p><hr><h4 id="23-11-16-突然文雅"><a href="#23-11-16-突然文雅" class="headerlink" title="23&#x2F;11&#x2F;16 突然文雅"></a>23&#x2F;11&#x2F;16 突然文雅</h4><p>zyx: 今天迟到的有，xxx，xxx……<br>Ma Sun: 这个声音，不甚清楚。<br>class: $\small\textcolor{darkgrey}{Confused.}$<br>Ch Guo: 不是很清楚，不是很清楚。</p><hr><h4 id="23-11-16-吟诗一首"><a href="#23-11-16-吟诗一首" class="headerlink" title="23&#x2F;11&#x2F;16 吟诗一首"></a>23&#x2F;11&#x2F;16 吟诗一首</h4><p>lcs: 有tr和jq官比我大，<br>      还有zyx我根本不怕。<br>     如果明天孙翔找我爸，<br>  我直接扑通一声给他跪下。</p><blockquote><p>当天晚自习路队很乱，人少，班长lyc和值班的Ch Guo都掉队了。</p></blockquote><hr><h4 id="23-11-27-最难的题"><a href="#23-11-27-最难的题" class="headerlink" title="23&#x2F;11&#x2F;27 最难的题"></a>23&#x2F;11&#x2F;27 最难的题</h4><p>zlj: 这道题难吗？<br>gtr: 不难。<br>zlj: 确实不难。我觉得最难的是这道题。<br>gtr: $\small\textcolor{darkgrey}{愣了一下。}$嗯，确实，许多大数学家都搞不清楚这个数的意义是什么。<br>zlj: 还有这个！这个也非常难。<br>gtr: 确实，每个答案看上去都对，实际上没有恰当的答案。  </p><blockquote><p>第一个是个性超市下面的页码，第二个是封面上的名字。</p></blockquote><hr><h4 id="23-11-29-凭空产生"><a href="#23-11-29-凭空产生" class="headerlink" title="23&#x2F;11&#x2F;29 凭空产生"></a>23&#x2F;11&#x2F;29 凭空产生</h4><p>Ch Yang: 来，zxh，上黑板上默写化学方程式。<br>Ch Yang: ……第三个，盐酸除铁锈。<br>zxh: $Fe_2O_3+2HCl\xlongequal{\hspace{0.7cm}}H_2O+CO_2\uparrow+2NaCl$。</p><hr><h4 id="23-11-29-一会下来"><a href="#23-11-29-一会下来" class="headerlink" title="23&#x2F;11&#x2F;29 一会下来"></a>23&#x2F;11&#x2F;29 一会下来</h4><p>IT Ji: wxm去哪了？<br>lss: 他被英语老师留下了，一会下来。  </p><blockquote><p>然而，微机室在五楼，上面没有其它楼层。</p></blockquote><hr><h4 id="23-11-30-化学老师生气了"><a href="#23-11-30-化学老师生气了" class="headerlink" title="23&#x2F;11&#x2F;30 化学老师生气了"></a>23&#x2F;11&#x2F;30 化学老师生气了</h4><p>Ch Yang: 来，zsh，上来默写方程式。<br>zsh: $Fe_2O_3+HSO_4\xlongequal{\hspace{0.7cm}}Fe_2(SO_4)_3+H_2O$<br>zsh: $Fe_2O_3+3HSO_4\xlongequal{\hspace{0.7cm}}Fe_2(SO_4)_3+3H_2O$<br>zsh: $2Fe_2O_3+6HSO_4\xlongequal{\hspace{0.7cm}}2Fe_2(SO_4)_3+3H_2O$<br>Ch Yang: 回去吧。给你个机会，100遍硫酸。<br>zsh: $Fe_2O_3+3H_2SO_4\xlongequal{\hspace{0.7cm}}Fe_2(SO_4)_3+3H_2O$<br>Ch Yang: 化学式都写不对，配配配，配你……$\small\textcolor{darkgrey}{扶额，停顿了两秒}$<br>class: $\small\textcolor{darkgrey}{Laughed.}$</p><hr><h4 id="23-12-01-填满"><a href="#23-12-01-填满" class="headerlink" title="23&#x2F;12&#x2F;01 填满"></a>23&#x2F;12&#x2F;01 填满</h4><p>Ch Guo: 先达德隆望尊，门人弟子填其室，未敢稍降辞色。lcs，你来翻译一下这个句子。<br>lcs: 先辈德高望重，门人学生填满了他的房间……</p><blockquote><p>填：挤满。</p></blockquote><hr><h4 id="23-12-01-初三真好"><a href="#23-12-01-初三真好" class="headerlink" title="23&#x2F;12&#x2F;01 初三真好"></a>23&#x2F;12&#x2F;01 初三真好</h4><p>En Zhang: ……，一会这些同学留下来重新默写，到三班去找我。<br>lcs: 上面是什么声音？他们不考试吗？<br>qsy: 就我们三个班考。<br>class: 啊……<br>Ch Guo: 多么幸福的初三生活啊！<br>Ch Guo: 一会古诗默写不合格的留下来补。<br>lcs: 不是明天不上课了，是移到今天晚上了。<br>qsy: 好，直接在这上晚自习。</p><blockquote><p>由于学校有活动，周六不需要上课了。<br>自习课考物理，但只有Ph Yang带的4班、5班和6班考。<br>楼上九班不考试，在搬桌子，哐当哐当的。<br>qsy所言既是，18:30放学，还差5分钟开始上晚自习。</p></blockquote><hr><h4 id="23-12-15-一瓶"><a href="#23-12-15-一瓶" class="headerlink" title="23&#x2F;12&#x2F;15 一瓶"></a>23&#x2F;12&#x2F;15 一瓶</h4><p>Ch Fang: $NaCl$沸点1465℃……现在花掉1000元，容不容易啊？我们十班那小孩一瓶鞋子花了1000多块钱</p><hr><h4 id="23-12-21-沉默是金"><a href="#23-12-21-沉默是金" class="headerlink" title="23&#x2F;12&#x2F;21 沉默是金"></a>23&#x2F;12&#x2F;21 沉默是金</h4><p>Ch Yang: $Na_2CO_3$除$NaOH$，加什么，来，有主动的吗？<br>lcs: 沉默是金。<br>Ch Yang: 沉默是金……来，jjh。</p><h4 id="23-12-24-正解"><a href="#23-12-24-正解" class="headerlink" title="23&#x2F;12&#x2F;24 正解"></a>23&#x2F;12&#x2F;24 正解</h4><blockquote><p>对于诗句“饿死真吾志，梦中行采薇”的理解，下列说法正确的一项是？<br>D. 文天祥受元朝虐待，不给饭吃，只好在梦中采野菜吃。</p></blockquote><hr><h4 id="23-12-26-半径"><a href="#23-12-26-半径" class="headerlink" title="23&#x2F;12&#x2F;26 半径"></a>23&#x2F;12&#x2F;26 半径</h4><p>lcs: 半径！<br>ljq: 安静！<br>lcs: 连半径！这个是弦！<br>ljq: 安静，一会记名字了！<br>lcs: 那叫半径！</p><hr><h4 id="23-12-29-轮子"><a href="#23-12-29-轮子" class="headerlink" title="23&#x2F;12&#x2F;29 轮子"></a>23&#x2F;12&#x2F;29 轮子</h4><p>Hi Wang: 快，《论语》是谁写的？你们不都学过吗？<br>lcs: 论子写的。</p><hr><h4 id="24-01-02-数学代入历史"><a href="#24-01-02-数学代入历史" class="headerlink" title="24&#x2F;01&#x2F;02 数学代入历史"></a>24&#x2F;01&#x2F;02 数学代入历史</h4><p>Hi Wang: 秦始皇统一货币，使用圆形方孔半两钱，又称“秦半两”。<br>lcs: 圆内接四边形。</p><hr><h4 id="24-01-09-潦草"><a href="#24-01-09-潦草" class="headerlink" title="24&#x2F;01&#x2F;09 潦草"></a>24&#x2F;01&#x2F;09 潦草</h4><p>xwh: 老师，作业太潦草了怎么办？<br>En Zhang: 太潦草了怎么办？重写一遍就不潦草了。</p><hr><h4 id="24-01-10-生日快乐"><a href="#24-01-10-生日快乐" class="headerlink" title="24&#x2F;01&#x2F;10 生日快乐"></a>24&#x2F;01&#x2F;10 生日快乐</h4><p>zsh: 全体目光对准xwh！生日快乐！<br>class: $\small\textcolor{darkgrey}{Clapped.}$<br>wsc: 一月十号，诶，十号！<br>class: $\small\textcolor{darkgrey}{Shouted.}$</p><p>gtr: 十五岁啦！长大啦！<br>xwh: 生日考道法，一点也不快乐。<br>wsc: 要找自己的”Other Half”了！</p><hr><h4 id="24-01-30-老大"><a href="#24-01-30-老大" class="headerlink" title="24&#x2F;01&#x2F;30 老大"></a>24&#x2F;01&#x2F;30 老大</h4><p>gtr: 我刚从校门口进来，看到Ch Yang开车进来了。<br>lcs: 居然不是直升机，差评。</p><blockquote><p>为什么Ch Yang的外号叫“老大”，要追溯到原子相对质量。<br>Ch Yang: 取$_6^{12}C$原子质量的$\frac{1}{12}$作为相对原子质量的单位。我是老大，我就是这么规定的。</p></blockquote><hr><h4 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h4><p>九上很快，很短，也很愉快。<br>这是我们人生中的一抹彩。</p>]]></content>
    
    
    <categories>
      
      <category>趣闻</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于我</title>
    <link href="/articles/About-Me/"/>
    <url>/articles/About-Me/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><p>Taoran<br>来自山大辅仁学校 2015级7班 &amp; 2021级6班，文化课成绩一般。<br>一名普普通通的$\text{OIer}$，成绩十分不出众，机房里最菜的一个。<br>$$<br>\Large{\textcolor{black}{\textbf{长}}}<br>\LARGE{_\textcolor{black}{\textbf{江}}}<br>\LARGE{^\textcolor{darkred}{\textbf{后}}}<br>\large{\textcolor{darkred}{\textbf{浪}}}<br>\Large{^\textcolor{black}{\textbf{推}}}<br>\LARGE{_\textcolor{darkgreen}{\textbf{前}}}<br>\LARGE{^\textcolor{darkgreen}{\textbf{浪}}}<br>\large{\textcolor{black}{\textbf{，}}}<br>\large{\textcolor{black}{\textbf{世}}}<br>\LARGE{_\textcolor{black}{\textbf{上}}}<br>\LARGE{^\textcolor{red}{\textbf{新}}}<br>\large{\textcolor{red}{\textbf{人}}}<br>\Large{\textcolor{black}{\textbf{赶}}}<br>\LARGE{^\textcolor{purple}{\textbf{旧}}}<br>\LARGE{_\textcolor{purple}{\textbf{人}}}<br>\LARGE{_\textcolor{black}{\textbf{。}}}<br>$$</p><hr><h3 id="码风"><a href="#码风" class="headerlink" title="码风"></a>码风</h3><p>一直用快读，不用<code>cin</code>和<code>cout</code>。<br>不喜欢用万能头<br>数组的名字叫<code>d[]</code>，<code>g[]</code>和<code>f[]</code>，从1开始。<br>不常用<code>const int</code>，一般是<code>#define</code>  。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> ll;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>ll x=<span class="hljs-number">0</span>, f=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">while</span> (ch&lt;<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>) &#123;<span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;-&#x27;</span>) f=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">while</span> (ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) &#123;x=(x&lt;&lt;<span class="hljs-number">3</span>)+(x&lt;&lt;<span class="hljs-number">1</span>)+(ch^<span class="hljs-number">48</span>);ch=<span class="hljs-built_in">getchar</span>();&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//freopen(&quot;***.in&quot;, &quot;r&quot;, stdin);</span><br><span class="hljs-comment">//freopen(&quot;***.out&quot;, &quot;w&quot;, stdout);</span><br><br><span class="hljs-comment">//fclose(stdin);</span><br><span class="hljs-comment">//fclose(stdout);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="打OI的步骤"><a href="#打OI的步骤" class="headerlink" title="打OI的步骤"></a>打OI的步骤</h3><p>暴一；骗二；Rand(三)；<code>system(&quot;shutdown -s -t 0&quot;)</code>四。</p><hr><h3 id="原笔记-链接表"><a href="#原笔记-链接表" class="headerlink" title="原笔记&amp;链接表"></a>原笔记&amp;链接表</h3><p>详见洛谷<a href="https://www.luogu.com.cn/paste/tioy7p8y">剪贴板</a></p><hr><h3 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h3><p>详见 <a href="/about">About</a> 页面</p>]]></content>
    
    
    <categories>
      
      <category>介绍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
